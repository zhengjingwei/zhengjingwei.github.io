<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[网络协议栈性能影响因素及优化技术]]></title>
      <url>/2018/05/23/network-stack-overhead/</url>
      <content type="html"><![CDATA[<p>影响网络协议栈的性能开销及优化方法如下。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180523/1EBgD6m6mf.png?imageslim" alt="mark"></p>
<h1 id="1-网卡中断开销"><a href="#1-网卡中断开销" class="headerlink" title="1 网卡中断开销"></a>1 网卡中断开销</h1><p><strong>轮询</strong>与<strong>中断</strong>是操作系统与外设进行 I/O 通信的两种主要方式。一般情况下，网络中数据分组的到来具有不可预测性。若采用轮询模式对数据分组进行持续监听，会造成很高的CPU占用率，进而影响系统其他进程的运行效率，故主流操作系统都采用中断来处理网络的请求。<strong>中断处理方式在低速网络I/O场景下非常有效</strong>，<strong>高速网络</strong>中，随着网络 I/O速率的不断上升，网卡面对大量高速数据分组引发频繁的中断，<strong>中断引起的上下文切换开销将变得不可忽视</strong>，造成较高的时延，并引起吞吐量下降。</p>
<h2 id="1-1-轮询代替中断"><a href="#1-1-轮询代替中断" class="headerlink" title="1.1 轮询代替中断"></a>1.1 轮询代替中断</h2><p>轮询不存在中断所固有的开销。以网卡接收分组为例，在轮询模式下，系统会在初始化时屏蔽收发分组中断， 并使用一个线程或进程不断检测收取分组描述符里的收取分组成功标志是否被网卡置位，以此来判断是否有数据分组，整个收取过程没有发生上下文切换，因此也就避免了相应的开销。在高速网络I/O下，轮询带来的性能提升是非常显著的。    </p>
<p><strong>轮询不一定总是优于中断</strong>。只有当I/O速率接近CPU速率时，中断的开销变得不可忽略，轮询模式的优势才能体现；相反，如果数据吞吐率很低，中断能有更好的CPU利用率，此时不宜采用中断模式。 基于以上分析，针对<strong>网络流量抖动较大</strong>的场景， 可以选用<strong>中断与轮询的混合模式</strong>，即：在流量小时使用中断模式，当遇到大流量时切换为轮询模式。</p>
<p>目前Linux内核（NAPI）与DPDK都支持这种混合中断轮询模式。<strong>NAPI</strong>（Linux New API）：可以动态地决定中断还是轮询。中断只有在一个batch的第一个数据包时是enable，然后polling定期enabled，用来检查收到数据包的设备。数据包参数存到DMA-able memory，等待CPU available。当DMA-able memory里面没有数据包时中断重新使能。这样使得，IO低时候用中断；IO高用轮询。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180523/BICB96cAG5.png?imageslim" alt="mark"></p>
<h1 id="2-内存复制开销"><a href="#2-内存复制开销" class="headerlink" title="2 内存复制开销"></a>2 内存复制开销</h1><p> 提供服务的应用进程运行在<strong>用户空间</strong>，而通常情况下，操作系统首先将到来的数据分组读取到<strong>内核空间</strong>，为了使上层应用能够对接收到的数据进行相应处理，需要将内核将数据从内核空间复制到用户空间；而对于应用进程产生的数据， 也需要由用户空间复制到内核空间，最后由网卡发出。操作系统在处理数据过程中往往需要 进行多次复制操作，严重影响了高速网络服务的性能。</p>
<h2 id="2-1-零拷贝技术-Zero-copy"><a href="#2-1-零拷贝技术-Zero-copy" class="headerlink" title="2.1 零拷贝技术(Zero-copy)"></a>2.1 零拷贝技术(Zero-copy)</h2><p>零拷贝指的是除网卡将数据DMA复制进内存外（非CPU参与）， 从数据分组接收到应用程序处理数据分组，整个过程中不存在数据复制。高速网络下，网络IO性能甚至超过CPU处理能力，频繁数据拷贝会耗尽CPU计算资源，使CPU成为性能瓶颈。同时，数据从内核空间进入应用程序所处的用户空间，该过程中引发的上下文切换开销同样不可忽略。</p>
<p>DPDK、Netmap、PF-ring等高性能数据分组处理框架都用了零拷贝技术。</p>
<p>PF-ring：将内核中的数据包缓存区暴露给用户态程序，数据包缓存区预分配。PF_Ring DNA (Direct NIC Access)：利用特殊的driver，提供NIC内存到用户空间内存的映射。缺点：通过DMA可能错误使用内存地址，导致系统崩溃。</p>
<h1 id="3-锁开销"><a href="#3-锁开销" class="headerlink" title="3 锁开销"></a>3 锁开销</h1><p> 当多个线程或进程需要对某一<strong>共享资源</strong>进行操作时，往往需要通过<strong>锁机制来保证数据的一致性和同步性</strong>，而加锁带来的开销会显著降低数据处理的性能。具体来说，锁机制造成的开销主要有两方面：一方面，<strong>线程在为共享资源上锁或者去锁的过程</strong>中通常需要耗时几十纳秒；另一方面，在<strong>竞争锁</strong>的过程中，等待线程在<strong>阻塞</strong>过程中无法进行有效的数据处理和计算，从而降低了整个系统的并发性能。无论是宿主机还是客户机的内核协议栈中，都存在大量的共享资源，这也制约着整个系统的可扩展性。</p>
<h2 id="3-1-连接本地化"><a href="#3-1-连接本地化" class="headerlink" title="3.1 连接本地化"></a>3.1 连接本地化</h2><p>​    将共享的数据结构分区 &amp; 连接本地化以减少锁开销/跨核开销。即设法将同<strong>一个流的所有数据分组交由同一个CPU核处理</strong>，从而<strong>避免不同核对于同一资源的竞争</strong>， 进而也就避免了加锁的开销。同时， 在同一个CPU核处理同一条流也可以<strong>提升缓存的命中率</strong>，避免跨核的开销。</p>
<h1 id="4-上下文切换开销"><a href="#4-上下文切换开销" class="headerlink" title="4 上下文切换开销"></a>4 上下文切换开销</h1><p>数据平面进行资源的分配调度过程中涉及多种类型的上下文切换：在<strong>网卡中断</strong>、<strong>系统调用</strong>、<strong>进程调度</strong>与<strong>跨核资源访问</strong> 等上下文切换过程中，操作系统均需要保存当前状态，上下文切换开销大，严重影响系统性能。</p>
<h2 id="4-1-用户态协议栈"><a href="#4-1-用户态协议栈" class="headerlink" title="4.1 用户态协议栈"></a>4.1 用户态协议栈</h2><p>直接将协议栈移动到应用层实现，避免昂贵的上下文切换开销， 如mTCP、 lwIP等方案</p>
<h2 id="4-2-批处理系统调用"><a href="#4-2-批处理系统调用" class="headerlink" title="4.2 批处理系统调用"></a>4.2 批处理系统调用</h2><p>批处理系统调用平摊开销，MegaPipe、FlexSC、 VOS均使用批量系统调用来减小开销。</p>
<h1 id="5-文件系统管理开销"><a href="#5-文件系统管理开销" class="headerlink" title="5 文件系统管理开销"></a>5 文件系统管理开销</h1><p>socket是一种文件抽象，Linux 为了实现统一文件管理，通过虚拟文件系统（virtual file system，<strong>VFS</strong>）为套接字绑定了一系列对应的数据结构如inode、dentry等。通常情况下， 这些<strong>重量级的数据结构</strong>对于套接字本身的功能来说是不必要的<strong>[Fastsocket]</strong>。而在NFV的应用场景下（或者高并发的短连接），往往需要对 socket进行频繁的分配和释放，因而操作系统在管理这些数据结构的过程中会引起较大的性能开销。</p>
<h2 id="5-1-自定义轻量级socket"><a href="#5-1-自定义轻量级socket" class="headerlink" title="5.1 自定义轻量级socket"></a>5.1 自定义轻量级socket</h2><p>自定义轻量级的 socket，一些优化方案如mTCP、lwIP等，选择直接绕过VFS，在<strong>用户态重新定义实现socket</strong>结构体；另外一些优化 方案如MegaPipe等，虽然在内核实现，但也通过<strong>自定义API</strong>避免了原有VFS的文件操作</p>
<h2 id="5-2-继承VFS的socket实现但简化"><a href="#5-2-继承VFS的socket实现但简化" class="headerlink" title="5.2 继承VFS的socket实现但简化"></a>5.2 继承VFS的socket实现但简化</h2><p>继承VFS的socket实现，但是简化掉inode与 dentry 的初始化与销毁过程，抛弃其中的锁。这是因为对于socket而言，inode与dentry是完全无用的。代表性工作是Fastsocket。 相比前一种方案，该方案的优点在于能够完全兼容传统 socket，便于应用抑制 继承VFS的socket实现，但是简化掉inode与 dentry 的初始化与销毁过程，抛弃其中的锁。这是因为对于socket而言，inode与dentry是完全无用的。代表性工作是Fastsocket。 相比前一种方案，该方案的优点在于能够完全兼容传统 socket，便于应用抑制 </p>
<h1 id="6-缓存未命中开销"><a href="#6-缓存未命中开销" class="headerlink" title="6 缓存未命中开销"></a>6 缓存未命中开销</h1><p>如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性</p>
]]></content>
      
        <categories>
            
            <category> 网络协议栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 13. Roman to Integer]]></title>
      <url>/2018/02/11/leetcode-13/</url>
      <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a><a href="https://leetcode.com/problems/roman-to-integer/description/" target="_blank" rel="noopener">13. Roman to Integer</a></h1><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将输入罗马数字字符串转换为数字</p>
<h2 id="罗马数字"><a href="#罗马数字" class="headerlink" title="罗马数字"></a>罗马数字</h2><p>罗马数字采用七个罗马字母作数字、即</p>
<p>I - 1<br>V - 5<br>X - 10<br>L - 50<br>C - 100<br>D - 500<br>M - 1000</p>
<p>记数的方法：</p>
<ol>
<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3；</li>
<li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12；</li>
<li>小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9；</li>
</ol>
<p>使用unordered_map存储罗马数字和阿拉伯数字的kv对，然后遍历字符串进行统计和处理。</p>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; T = &#123; &#123; <span class="string">'I'</span> , <span class="number">1</span> &#125;,</span><br><span class="line">	                                   &#123; <span class="string">'V'</span> , <span class="number">5</span> &#125;,</span><br><span class="line">	                                   &#123; <span class="string">'X'</span> , <span class="number">10</span> &#125;,</span><br><span class="line">	                                   &#123; <span class="string">'L'</span> , <span class="number">50</span> &#125;,</span><br><span class="line">	                                   &#123; <span class="string">'C'</span> , <span class="number">100</span> &#125;,</span><br><span class="line">	                                   &#123; <span class="string">'D'</span> , <span class="number">500</span> &#125;,</span><br><span class="line">	                                   &#123; <span class="string">'M'</span> , <span class="number">1000</span> &#125; &#125;;</span><br><span class="line">	    <span class="keyword">int</span> num = T[s[<span class="number">0</span>]] ; </span><br><span class="line">    	<span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span> ;i&lt;s.size();i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(T[s[i]] &gt; T[s[i<span class="number">-1</span>]]) </span><br><span class="line">    			num += T[s[i]] - <span class="number">2</span>*T[s[i<span class="number">-1</span>]] ;</span><br><span class="line">    		<span class="keyword">else</span> </span><br><span class="line">    			num += T[s[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 12. Integer to Roman]]></title>
      <url>/2018/02/10/leetcode-12/</url>
      <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a><a href="https://leetcode.com/problems/integer-to-roman/description/" target="_blank" rel="noopener">12. Integer to Roman</a></h1><p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将输入整数转换为罗马数字</p>
<h2 id="罗马数字"><a href="#罗马数字" class="headerlink" title="罗马数字"></a>罗马数字</h2><p>罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法：</p>
<ol>
<li>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3；</li>
<li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12；</li>
<li>小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9；</li>
</ol>
<p>某一位上数字表示的规律：</p>
<p>1：直接表示</p>
<p>2、3：小数叠加</p>
<p>4：5-1</p>
<p>5：直接表示</p>
<p>6：5+1</p>
<p>7：5+2</p>
<p>8：5+3</p>
<p>9：10-1</p>
<p>10：直接表示</p>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>自己写的，比较长</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        	num -=<span class="number">1000</span>;</span><br><span class="line">        	str += <span class="string">'M'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> hun = (num%<span class="number">1000</span>)/<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">switch</span>(hun)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:str+=<span class="string">"C"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:str+=<span class="string">"CC"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:str+=<span class="string">"CCC"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:str+=<span class="string">"CD"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:str+=<span class="string">"D"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:str+=<span class="string">"DC"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:str+=<span class="string">"DCC"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:str+=<span class="string">"DCCC"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:str+=<span class="string">"CM"</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> dec = (num%<span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">switch</span>(dec)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:str+=<span class="string">"X"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:str+=<span class="string">"XX"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:str+=<span class="string">"XXX"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:str+=<span class="string">"XL"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:str+=<span class="string">"L"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:str+=<span class="string">"LX"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:str+=<span class="string">"LXX"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:str+=<span class="string">"LXXX"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:str+=<span class="string">"XC"</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> unit = num%<span class="number">10</span> ;</span><br><span class="line">		<span class="keyword">switch</span>(unit)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:str+=<span class="string">"I"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:str+=<span class="string">"II"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:str+=<span class="string">"III"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:str+=<span class="string">"IV"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:str+=<span class="string">"V"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:str+=<span class="string">"VI"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:str+=<span class="string">"VII"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:str+=<span class="string">"VIII"</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:str+=<span class="string">"IX"</span>;<span class="keyword">break</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考网上精简的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> M[] = &#123;<span class="string">""</span>,<span class="string">"M"</span>,<span class="string">"MM"</span>,<span class="string">"MMM"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> C[] = &#123;<span class="string">""</span>,<span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> X[] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> I[] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span>  M[num/<span class="number">1000</span>] + C[(num%<span class="number">1000</span>)/<span class="number">100</span>] + X[(num%<span class="number">100</span>)/<span class="number">10</span>] + I[num%<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 9. Palindrome Number]]></title>
      <url>/2018/02/07/leetcode-9/</url>
      <content type="html"><![CDATA[<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a><a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener">9. Palindrome Number</a></h1><p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求不能使用额外的空间，所以不能转成字符串来处理。解题思路很简单，将比较原来的数和倒置后的数是否为同一个数即可。</p>
<p>注意:</p>
<ul>
<li>负数不是回文数</li>
<li>在倒置过程中不需要判断是否溢出，因为逆序后溢出的数必然和原来的数不同，肯定不是回文数</li>
</ul>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>, num = x;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        	rev = rev *<span class="number">10</span> + num%<span class="number">10</span>;</span><br><span class="line">        	num= num/<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rev == x) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 8. String to Integer (atoi)]]></title>
      <url>/2018/02/06/leetcode-8/</url>
      <content type="html"><![CDATA[<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="noopener">8. String to Integer (atoi)</a></h1><p>Implement <code>atoi</code> to convert a string to an integer.</p>
<p><strong>Hint:</strong> Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p><strong>Notes:</strong> It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p><strong>Requirements for atoi:</strong></p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题难度不高，主要是要理解题目的要求</p>
<p>题目的要求：</p>
<ol>
<li><p>首先需要丢弃字符串前面的空格；</p>
</li>
<li><p>然后可能有正负号（注意只取一个，如果有多个正负号，那么说这个字符串是无法转换的，返回0。比如测试用例里就有个<code>“+-2”</code>）；</p>
</li>
<li><p>字符串可以包含0~9以外的字符，如果遇到非数字字符，那么只取该字符之前的部分，如<code>“-00123a66”</code>返回为<code>“-123”</code>；</p>
</li>
<li><p>如果超出<code>int</code>的范围，返回边界值（<code>2147483647</code>或<code>-2147483648</code>，INT_MAX和INT_MIN）。</p>
</li>
<li><p>注意判断是否溢出的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ret &gt;INT_MAX/<span class="number">10</span> || (ret == INT_MAX/<span class="number">10</span> &amp;&amp; str[i]-<span class="string">'0'</span> &gt;<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>其中一个测试用例就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:&quot;2147483648&quot;</span><br><span class="line">Expected:2147483647</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> ret = <span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> sign = <span class="string">'+'</span>; 	</span><br><span class="line">    	<span class="keyword">while</span>(str[i]==<span class="string">' '</span>) ++i;</span><br><span class="line">    	<span class="keyword">if</span>(str[i]==<span class="string">'+'</span>||str[i]== <span class="string">'-'</span>)&#123; <span class="comment">// if string has sign</span></span><br><span class="line">    		<span class="keyword">if</span>((str[i]==<span class="string">'+'</span>&amp;&amp;str[i+<span class="number">1</span>]==<span class="string">'-'</span>) || (str[i]==<span class="string">'-'</span>&amp;&amp;str[i+<span class="number">1</span>]==<span class="string">'+'</span>)) <span class="comment">// 2 sign</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    		sign = str[i]; <span class="comment">// get the sign</span></span><br><span class="line">    		++i;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">while</span>(i &lt; str.size())&#123;</span><br><span class="line">    		<span class="keyword">if</span>(str[i]&gt; <span class="string">'9'</span> || str[i] &lt;<span class="string">'0'</span>)</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		<span class="keyword">if</span>(ret &gt;INT_MAX/<span class="number">10</span> || (ret == INT_MAX/<span class="number">10</span> &amp;&amp; str[i]-<span class="string">'0'</span> &gt;<span class="number">7</span>))&#123; <span class="comment">// if overflow</span></span><br><span class="line">    			<span class="keyword">if</span>(sign ==<span class="string">'+'</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(sign = <span class="string">'-'</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">			&#125;</span><br><span class="line">			ret = ret * <span class="number">10</span> + (str[i] -<span class="string">'0'</span>);</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sign == <span class="string">'-'</span>) ret = -ret;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 7. Reverse Integer]]></title>
      <url>/2018/02/05/leetcode-7/</url>
      <content type="html"><![CDATA[<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a><a href="https://leetcode.com/problems/reverse-integer/description/" target="_blank" rel="noopener">7. Reverse Integer</a></h1><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output:  321</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>注意一点就是乘10的时候可能溢出，需要进行判断乘10之前是否已经大于 <code>INT_MAX/10</code>。</p>
<p>INT_MAX = 2147483647 = 2^31 -1 = 1&lt;&lt;31 -1</p>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (x==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> sign = (x&gt;<span class="number">0</span>)?<span class="number">1</span>:<span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(ret&gt;INT_MAX/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        	ret = ret*<span class="number">10</span> +x%<span class="number">10</span>;</span><br><span class="line">        	x = x/<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sign * ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 6. ZigZag Conversion]]></title>
      <url>/2018/02/04/leetcode-6/</url>
      <content type="html"><![CDATA[<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a><a href="https://leetcode.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener">6. ZigZag Conversion</a></h1><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>And then read line by line: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string text, int nRows);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(&quot;PAYPALISHIRING&quot;, 3)</span><br></pre></td></tr></table></figure>
<p> should return </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>就是把字符串原顺序012345……按下图所示排列：</p>
<p><img src="http://img.blog.csdn.net/20141026161841654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>比较直观的解法是，用一个字符串数组 string[rows] 来存储每一行，最后一拼接就是最终结果。</p>
<p>用一个flag表示正向还是反向，即上图中从第一行到最后一行还是最后一行到第一行。</p>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">		<span class="built_in">string</span> str[numRows];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span> ,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">        	str[row] += s[i];</span><br><span class="line">        	<span class="keyword">if</span>(!flag&amp;&amp;row&lt;numRows<span class="number">-1</span>) </span><br><span class="line">				++row;</span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">if</span>(row==numRows<span class="number">-1</span>)&#123;</span><br><span class="line">        		flag=<span class="number">1</span>;</span><br><span class="line">        		row--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; row&gt;<span class="number">0</span>) </span><br><span class="line">				row--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(row==<span class="number">0</span>) &#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				++row;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">string</span> ret;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">			ret +=str[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 5. Longest Palindromic Substring]]></title>
      <url>/2018/02/03/leetcode-5/</url>
      <content type="html"><![CDATA[<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">5. Longest Palindromic Substring</a></h1><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最长回文子串。就是给定一个字符串S，找出其中的最长回文子串，并返回该子串。</p>
<p>解法1：暴力枚举     时间复杂度$O(n^3)$</p>
<p>解法2：中心扩展法    时间复杂度$O(n^2)$    空间复杂度$O(1)$</p>
<p>解法3：动态规划    时间复杂度$O(n^2)​$    空间复杂度$O(n^2)​$</p>
<p>解法4：Manacher算法    时间复杂度$O(N)$    空间复杂度$O(n)$</p>
<h2 id="解法1：暴力枚举"><a href="#解法1：暴力枚举" class="headerlink" title="解法1：暴力枚举"></a>解法1：暴力枚举</h2><p>遍历该字符串的每一个子串，判断是不是回文串，最后给出最长回文子串。 </p>
<p>时间复杂度$O(n^3)$，运行超时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">string</span> max_sub_string = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &lt; len ;j++)&#123;</span><br><span class="line">				<span class="built_in">string</span> sub_string = s.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(isPalindrome(sub_string))&#123;</span><br><span class="line">					<span class="keyword">if</span>(sub_string.size()&gt;maxlen)&#123;</span><br><span class="line">						maxlen = sub_string.size();</span><br><span class="line">						max_sub_string = sub_string;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max_sub_string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> slen = s.size();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;(slen+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(s[i]!=s[slen<span class="number">-1</span>-i])</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法2：中心扩展法"><a href="#解法2：中心扩展法" class="headerlink" title="解法2：中心扩展法"></a>解法2：中心扩展法</h2><p>优化：枚举回文串的中点</p>
<p>从某一个字符开始，左右向外扩展得到一个更长的子串，看是否是回文子串，如果是回文子串，则继续向外遍历，知道遇到非回文子串或者超出子串范围。需要注意针对一个字符向外扩张时，需要同时<strong>偶数</strong>字符个数回文子串和<strong>奇数</strong>字符个数回文子串两种情况。</p>
<p>时间复杂度$O(n^2)$        </p>
<p>空间复杂度$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>, left = <span class="number">0</span>,right = <span class="number">0</span>,substr_left,substr_right,substr_len;</span><br><span class="line">		<span class="built_in">string</span> max_sub_string = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">			left = i <span class="number">-1</span> ;</span><br><span class="line">			right = i;</span><br><span class="line">			<span class="comment">// even Palindrome  eg. "abba"</span></span><br><span class="line">			<span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right &lt; len &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">				--left;</span><br><span class="line">				++right;</span><br><span class="line">			&#125;</span><br><span class="line">			substr_left = left +<span class="number">1</span>;</span><br><span class="line">			substr_right = right <span class="number">-1</span>;</span><br><span class="line">			substr_len = substr_right -substr_left +<span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span>(substr_len &gt; maxlen)&#123;</span><br><span class="line">				max_sub_string = s.substr(substr_left,substr_len);</span><br><span class="line">				maxlen = substr_len;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// odd Palindrome eg. "abcba"</span></span><br><span class="line">			left = i<span class="number">-1</span>;</span><br><span class="line">			right = i+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right &lt; len &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">				--left;</span><br><span class="line">				++right;</span><br><span class="line">			&#125;</span><br><span class="line">			substr_left = left +<span class="number">1</span>;</span><br><span class="line">			substr_right = right <span class="number">-1</span>;</span><br><span class="line">			substr_len = substr_right -substr_left +<span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span>(substr_len &gt; maxlen)&#123;</span><br><span class="line">				max_sub_string = s.substr(substr_left,substr_len);</span><br><span class="line">				maxlen = substr_len;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max_sub_string;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法3：动态规划"><a href="#解法3：动态规划" class="headerlink" title="解法3：动态规划"></a>解法3：动态规划</h2><p>时间复杂度$O(n^2)$    </p>
<p>空间复杂度$O(n^2)$</p>
<p>首先写出动态转移方程：P[ i, j ] ← ( P[ i+1, j-1 ] and Si = Sj ) 显然，如果一个子串是回文串，并且如果从它的左右两侧分别向外扩展的一位也相等，那么这个子串就可以从左右两侧分别向外扩展一位。</p>
<p>其中的base case是</p>
<p>P[ i, i ] ← true<br>P[ i, i+1 ] ← ( Si = Si+1 )</p>
<p>假设有个字符串是adade，现在要找到其中的最长回文子串。使用上面的动态转移方程，有如下的过程:</p>
<p><img src="http://img.blog.csdn.net/20131218010537093" alt="img"></p>
<p>按照红箭头-&gt;黄箭头-&gt;蓝箭头-&gt;绿箭头-&gt;橙箭头的顺序依次填入矩阵，通过这个矩阵记录从i到j是否是一个回文串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span> ,begin;</span><br><span class="line">		<span class="keyword">bool</span> dp[len][len]; <span class="comment">// dp[i][j] == true -&gt; s[i..j] is palindrome</span></span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len ;i++)&#123;</span><br><span class="line">			dp[i][i] = <span class="literal">true</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; len <span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">				dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">				maxlen = <span class="number">2</span>;</span><br><span class="line">				begin = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> substr_len = <span class="number">3</span>; substr_len &lt;= len ;substr_len ++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;= len -substr_len; i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> j = i + substr_len <span class="number">-1</span> ;</span><br><span class="line">				<span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="literal">true</span>)&#123; </span><br><span class="line">					dp[i][j] = <span class="literal">true</span> ;</span><br><span class="line">					begin = i;</span><br><span class="line">					maxlen = substr_len;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.substr(begin,maxlen);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>##解法4：Manacher算法</p>
<p>时间复杂度$O(n)$</p>
<p>空间复杂度$O(n)$</p>
<p><a href="http://blog.csdn.net/dyx404514/article/details/42061017" target="_blank" rel="noopener">Manacher算法</a></p>
<p>该算法首先对字符串进行预处理，在字符串的每个字符前后都加入一个特殊符号，比如字符串 abcd 处理成 <code>#a#b#c#d#</code>,为了避免处理越界，在字符串首尾加上不同的两个特殊字符(c类型的字符串尾部不用加，因为自带‘\0’)，这样预处理后最终变成$#a#b#c#d#^，经过这样处理后有个好处是原来的偶数长度和奇数长度的回文在处理后的字符串中都是奇数长度。假设处理后的字符串为s。</p>
<p>对于已经预处理好的字符串我们用数组p[i]来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]）,以字符串“<code>12212321</code>”为例，p数组如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：   $   #  1  #  2  #  2  #  1  #  2  #  3  #  2  #  1  #  ^ </span><br><span class="line">p：       1  2  1  2   5  2  1  4  1   2  1  6  1   2  1  2  1</span><br></pre></td></tr></table></figure>
<p> 可以看出，<strong>P[i]-1正好是原字符串中回文串的总长度,</strong> 如果p数组已知，遍历p数组找到最大的p[i]就可以求出最长回文的长度，也可以求出回文的位置</p>
<p>下面给出求p[]数组的方法：</p>
<p>设id是当前求得的最长回文子串中心的位置，mx为当前最长回文子串的右边界（回文子串不包括该右边界），即<strong>mx = id + p[id]。</strong>记j = 2*id – i ，即 j 是 i 关于 id 的对称点。</p>
<p><strong>1</strong>、 当i &lt; mx 时，如下图。此时可以得出一个非常神奇的结论<strong>p[i] &gt;= min(p[2*id - i], mx - i)，</strong>下面我们来解释这个结论</p>
<p><a href="http://images.cnitblog.com/blog/517264/201404/192355292135569.png" target="_blank" rel="noopener"><img src="http://images.cnitblog.com/blog/517264/201404/192355300257453.png" alt="image"></a></p>
<p>如何根据p[j]来求p[i]呢，又要分成两种情况</p>
<p>（1.1）当mx – i &gt; p[j], 这时候以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以 P[i]  至少等于 p[j], 后面的再继续匹配。如下图</p>
<p><strong>*注：这里其实p[i]一定等于p[j],后面不用再匹配了。因为如果p[i]后面还可以继续匹配，根据对称性，p[j]也可以继续扩展了*</strong></p>
<p><a href="http://images.cnitblog.com/blog/517264/201404/192355301664411.png" target="_blank" rel="noopener"><img src="http://images.cnitblog.com/blog/517264/201404/192355304635854.png" alt="image"></a></p>
<p>（1.2）当mx – i &lt;= p[j]， 以S[j]为中心的回文子串不完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] 至少等于 mx - i，至于mx之后的部分是否对称，就只能老老实实去匹配了。</p>
<p><strong>注：如果mx – i &lt; p[j] ，这时p[i]一定等于mx - i, 因为如果p[i]在mx之后还可以继续匹配，根据对称性，mx之后匹配的点(包括mx)一定会出现在my的前面，这说明p[id]也可以继续扩展了</strong></p>
<p><a href="http://images.cnitblog.com/blog/517264/201404/192355306978082.png" target="_blank" rel="noopener"><img src="http://images.cnitblog.com/blog/517264/201404/192355308851026.png" alt="image"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> id=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Manacher Algorithm</span></span><br><span class="line">        <span class="built_in">string</span> str = preProcess(s);</span><br><span class="line">        <span class="keyword">int</span> len = str.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt; len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        	p[i] = mx &gt; i ? min(p[<span class="number">2</span>*id -i],mx-i):<span class="number">1</span>; <span class="comment">//mx为当前最长回文子串的右边界</span></span><br><span class="line">        	<span class="keyword">while</span>(str[i+p[i]] == str[i-p[i]]) <span class="comment">// 计算P[i] </span></span><br><span class="line">        		p[i]++;</span><br><span class="line">        	<span class="keyword">if</span>( i + p[i] &gt; mx)&#123;</span><br><span class="line">        		mx = i+ p[i];</span><br><span class="line">        		id = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历p，寻找最大回文长度 </span></span><br><span class="line">		<span class="keyword">int</span> maxlen =<span class="number">0</span>,index =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[i] &gt; maxlen)&#123;</span><br><span class="line">				maxlen = p[i];</span><br><span class="line">				index = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.substr((index - maxlen)/<span class="number">2</span>,maxlen<span class="number">-1</span>);	<span class="comment">//p[i]-1为原字符串中的回文子串长度 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = s.size();</span><br><span class="line">		<span class="built_in">string</span> res;</span><br><span class="line">		res.push_back(<span class="string">'$'</span>);</span><br><span class="line">		res.push_back(<span class="string">'#'</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n ;i++)&#123;</span><br><span class="line">			res.push_back(s[i]);</span><br><span class="line">			res.push_back(<span class="string">'#'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		res.push_back(<span class="string">'^'</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 4. Median of Two Sorted Arrays]]></title>
      <url>/2018/02/02/leetcode-4/</url>
      <content type="html"><![CDATA[<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays</a></h1><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>要求在给定的两个有序数组中里面找其中的中位数，硬性要求时间复杂度为$O(log(m+n))$</p>
<p>问题可以转化为两个有序序列找第num大的数，由于时间复杂度被限制死，所以不能采用排序后再找中位数的方法（时间复杂度高）。以下参考 <a href="http://blog.csdn.net/hk2291976/article/details/51107778" target="_blank" rel="noopener">两个有序数组中的中位数和Top K问题</a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h1><h2 id="先解释下“割”"><a href="#先解释下“割”" class="headerlink" title="先解释下“割”"></a><strong>先解释下“割”</strong></h2><blockquote>
<p>我们通过切一刀，能够把<strong>有序</strong>数组分成左右两个部分，切的那一刀就被称为割(Cut)，割的左右会有两个元素，分别是左边最大值和右边最小值。</p>
<p>我们定义L = Max(LeftPart)，R = Min(RightPart)</p>
</blockquote>
<p>Ps. 割可以割在两个数中间，也可以割在1个数上，如果割在一个数上，那么这个数即属于左边，也属于右边。（后面讲单数组中值问题的时候会说）</p>
<p>比如说[2 3 5 7]这个序列，割就在3和5之间<br>[2 3 / 5 7]<br>中值就是（3+5）/2 = 4</p>
<p>如果[2 3 4 5 6]这个序列，割在4上，我们可以把4分成2个<br>[2 3 (4/4) 5 7]<br>中值就是（4+4）/2 = 4</p>
<p>这样可以保证不管中值是1个数还是2个数都能统一运算。</p>
<h2 id="割和第k个元素"><a href="#割和第k个元素" class="headerlink" title="割和第k个元素"></a><strong>割和第k个元素</strong></h2><p>对于单数组，<strong>找其中的第k个元素特别好做</strong>，我们用割的思想就是：如果在k的位置割一下，A[k]属于左边部分的最大值。</p>
<h1 id="双数组"><a href="#双数组" class="headerlink" title="双数组"></a><strong>双数组</strong></h1><p>我们设:<br><strong>Ci</strong>为第i个数组的割。<br><strong>Li</strong>为第i个数组割后的左元素.<br><strong>Ri</strong>为第i个数组割后的右元素。</p>
<p><img src="http://img.blog.csdn.net/20160409212629209" alt="这里写图片描述"></p>
<h2 id="如何从双数组里取出第k个元素"><a href="#如何从双数组里取出第k个元素" class="headerlink" title="如何从双数组里取出第k个元素"></a><strong>如何从双数组里取出第k个元素</strong></h2><ol>
<li>首先Li&lt;=Ri是肯定的（因为数组有序，左边肯定小于右边）</li>
<li>如果我们让L1&lt;=R2 &amp;&amp; L2&lt;=R1</li>
</ol>
<p><img src="http://img.blog.csdn.net/20160409212649178" alt="这里写图片描述"></p>
<ol>
<li>那么左半边 全小于右半边，如果左边的元素个数相加刚好等于k，那么第k个元素就是Max(L1,L2)，参考上面常识1。</li>
<li>如果 L1&gt;R2，说明数组1的左边元素太大（多），我们把C1减小，把C2增大。L2&gt;R1同理，把C1增大，C2减小。</li>
</ol>
<h3 id="假设k-3"><a href="#假设k-3" class="headerlink" title="假设k=3"></a><strong>假设k=3</strong></h3><p>对于<br>[1 4 7 9]<br>[2 3 5]</p>
<p>设C1 = 2，那么C2 = k-C1 = 1<br>[1 4/7 9]<br>[2/3 5]</p>
<p>这时候，L1(4)&gt;R2(3)，说明C1要减小，C2要增大，C1 = 1，C2=k-C1 = 2<br>[1/4 7 9]<br>[2 3/5]</p>
<p>这时候，满足了L1&lt;=R2 &amp;&amp; L2&lt;=R1，第3个元素就是Max(1,3) = 3。</p>
<p>如果对于上面的例子，把k改成4就恰好是中值。</p>
<p>下面具体来看特殊情况的中值问题。</p>
<h2 id="双数组的奇偶"><a href="#双数组的奇偶" class="headerlink" title="双数组的奇偶"></a><strong>双数组的奇偶</strong></h2><p>中值的关键在于，如何处理奇偶性，单数组的情况，我们已经讨论过了，那双数组的奇偶问题怎么办，m+n为奇偶处理方案都不同，</p>
<h2 id="让数组恒为奇数"><a href="#让数组恒为奇数" class="headerlink" title="让数组恒为奇数"></a><strong>让数组恒为奇数</strong></h2><p>有没有办法让两个数组长度相加一定为奇数或偶数呢？</p>
<p>其实有的，<strong>虚拟</strong>加入‘#’(这个trick在<a href="http://blog.csdn.net/hk2291976/article/details/51107886" target="_blank" rel="noopener">manacher算法</a>中也有应用)，让数组长度恒为奇数（2n+1恒为奇数）。<br>Ps.注意是虚拟加，其实根本没这一步，因为通过下面的转换，我们可以保证虚拟加后每个元素跟原来的元素一一对应</p>
<table>
<thead>
<tr>
<th>之前</th>
<th>len</th>
<th>之后</th>
<th>len</th>
</tr>
</thead>
<tbody>
<tr>
<td>[1 4 7 9]</td>
<td>4</td>
<td>[# 1 # 4 # 7 # 9 #]</td>
<td>9</td>
</tr>
<tr>
<td>[2 3 5]</td>
<td>3</td>
<td>[# 2 # 3 # 5 #]</td>
<td>7</td>
</tr>
</tbody>
</table>
<h2 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a><strong>映射关系</strong></h2><p>这有什么好处呢，为什么这么加?因为这么加完之后，<strong>每个位置可以通过/2得到原来元素的位置。</strong></p>
<table>
<thead>
<tr>
<th>/</th>
<th>原位置</th>
<th>新位置</th>
<th>除2后</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>5</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="在虚拟数组里表示“割”"><a href="#在虚拟数组里表示“割”" class="headerlink" title="在虚拟数组里表示“割”"></a><strong>在虚拟数组里表示“割”</strong></h2><p>不仅如此，割更容易，如果割在‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分。</p>
<p>奇妙的是不管哪种情况：</p>
<blockquote>
<p>Li = (Ci-1)/2<br>Ri = Ci/2</p>
</blockquote>
<p>例： </p>
<ol>
<li>割在4/7之间‘#’，C = 4，L=(4-1)/2=1 ，R=4/2=2 </li>
</ol>
<p>刚好是4和7的原来位置！ </p>
<ol>
<li>割在3上，C = 3，L=(3-1)/2=1，R=3/2 =1，刚好都是3的位置！</li>
</ol>
<hr>
<p>剩下的事情就好办了，把2个数组看做一个虚拟的数组A，目前有2m+2n+2个元素，割在m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。<br>左边：A[m+n+1] = Max(L1+L2)<br>右边：A[m+n+2] = Min(R1+R2)</p>
<blockquote>
<p>Mid = (A[m+n+1]+A[m+n+2])/2<br>= (Max(L1+L2) + Min(R1+R2) )/2</p>
</blockquote>
<p>至于在两个数组里找割的方案，就是上面的方案。</p>
<h1 id="分治的思路"><a href="#分治的思路" class="headerlink" title="分治的思路"></a><strong>分治的思路</strong></h1><p>有了上面的知识后，现在的问题就是如何利用分治的思想。</p>
<h2 id="怎么分？"><a href="#怎么分？" class="headerlink" title="怎么分？"></a><strong>怎么分？</strong></h2><p>最快的分的方案是二分，有2个数组，我们对哪个做二分呢？<br>根据之前的分析，我们知道了，只要C1或C2确定，另外一个也就确定了。这里，<strong>为了效率，我们肯定是选长度较短的做二分，假设为C1</strong>。</p>
<h2 id="怎么治？"><a href="#怎么治？" class="headerlink" title="怎么治？"></a><strong>怎么治？</strong></h2><p>也比较简单，我们之前分析了：就是比较L1,L2和R1,R2。 </p>
<ul>
<li>L1&gt;R2，把C1减小，C2增大。—&gt; C1向左二分</li>
<li>L2&gt;R1，把C1增大，C2减小。—&gt; C1向右二分</li>
</ul>
<h2 id="越界问题"><a href="#越界问题" class="headerlink" title="越界问题"></a><strong>越界问题</strong></h2><p><strong>如果C1或C2已经到头了怎么办？</strong><br>这种情况出现在：<strong>如果有个数组完全小于或大于中值</strong>。可能有4种情况：<br>C1 == 0 —— 数组1整体都比中值大</p>
<p>C1 == 2 x n —— 数组1整体比中值小</p>
<p>C2 == 0 —— 数组1整体都比中值小</p>
<p>C2 == 2 x m —— 数组1整体比中值大</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><code>nums1</code>大小为n，<code>nums2</code>大小为m。默认在长度小的数组上进行二分查找。如果n&gt;m，交换。</p>
<p>根据“虚拟数组”，两个虚拟数组包含<code>#</code>一共<code>有2m+2n+2</code>个元素。若<code>nums1</code>割<code>c1</code>，则表示<code>nums1</code>左边有<code>c1</code>个数字，而总共数字有<code>m+n</code>个，为了两个数组在割的左右边总数相等，所以<code>c2= m+n-c1</code></p>
<p><code>low</code>和<code>high</code>是二分查找的区间头和尾。<code>low</code>初始值为0（<code>[# 1 # 4 # 7 # 9 #]最左边的#</code>），<code>high</code>初始值为<code>2*n</code> （<code>[# 1 # 4 # 7 # 9 #]最右边的#</code>），割<code>c1=(low+high)/2</code>，表示<code>c1</code>从<code>nums1</code>数组正中间位置开始，<code>c2=m+n-c1</code>，nums1左边和nums2左边元素数量 = nums1右边和nums2右边元素数量。</p>
<p>当越界时，巧妙设置<code>INT_MIN</code>和<code>INT_MAX</code>，使其中一个割无效。</p>
<p>如<code>nums1 = [1 2]</code>    <code>nums2 = [3 4 5 6 7 8]</code>，因为nums1整体小于nums2，则经过几次循环后，c1 = 4，l1 = 2，r1 = INT_MAX。c2 = 4，l2 = 4，r2 = 5。low = high =4，此时因为满足了左边整体&lt;=右边，所以会break跳出循环，然后<code>return (max(l1,l2) + min(r1,r2))/2.0</code>，此时其实返回的就是nums2中割左右两端的中位数。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = nums1.size();</span><br><span class="line">		<span class="keyword">int</span> m = nums2.size();</span><br><span class="line">		<span class="keyword">if</span>(n &gt; m) </span><br><span class="line">			<span class="keyword">return</span> findMedianSortedArrays(nums2,nums1); </span><br><span class="line">		<span class="keyword">int</span> c1,c2,l1,l2,r1,r2,low =<span class="number">0</span>,high = <span class="number">2</span>*n; </span><br><span class="line">		<span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">			c1 = (low + high)/<span class="number">2</span>;</span><br><span class="line">			c2 = m + n - c1;</span><br><span class="line">			l1 = (c1==<span class="number">0</span>)?INT_MIN:nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];  </span><br><span class="line">			r1 = (c1==<span class="number">2</span>*n)?INT_MAX:nums1[c1/<span class="number">2</span>];</span><br><span class="line">			l2 = (c2==<span class="number">0</span>)?INT_MIN:nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">			r2 = (c2==<span class="number">2</span>*m)?INT_MAX:nums2[c2/<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">if</span>(l1 &gt; r2)&#123;</span><br><span class="line">				high = c1 - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (l2 &gt; r1)&#123;</span><br><span class="line">				low = c1 + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (max(l1,l2) + min(r1,r2))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode具体实现代码和详细解题报告</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 3. Longest Substring Without Repeating Characters]]></title>
      <url>/2018/02/01/leetcode-3/</url>
      <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.Longest Substring Without Repeating Characters</a></h1><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>
<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>
<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code>is a <em>subsequence</em> and not a substring.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>没有重复字符的最长子串</p>
<p>使用map来存储字符串以及对应的索引，建立一张索引表。以起点<code>start</code>开始查找，若无重复字符，则<code>maxlen = i-start</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcabcbb</span><br><span class="line">^  ^</span><br><span class="line">s  i</span><br></pre></td></tr></table></figure>
<p>当字符查表已存在，更新起点<code>start</code>为当前字符索引</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; char_map;</span><br><span class="line">        <span class="keyword">int</span> maxlen= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(char_map.count(s[i])!=<span class="number">0</span>)&#123;</span><br><span class="line">                start = max(start,char_map[s[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            char_map[s[i]]=i;</span><br><span class="line">            maxlen = max(maxlen,i-start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LeetCode代码和详细解题报告 Github地址</strong>：<a href="https://github.com/zhengjingwei/LeetCode" target="_blank" rel="noopener">https://github.com/zhengjingwei/LeetCode</a></p>
]]></content>
      
        <categories>
            
            <category> LeetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP实验3:CacheLab]]></title>
      <url>/2018/01/31/CSAPP-lab3-cachelab/</url>
      <content type="html"><![CDATA[<h1 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h1><p>​    Cache LAB分为Part A和B两部分，这次实验的任务很明确，就是制作自己的缓存系统，具体来说是</p>
<ul>
<li>实现一个缓存模拟器，根据给定的 trace 文件来输出对应的操作</li>
<li>利用缓存机制加速矩阵运算</li>
</ul>
<p>我们需要修改的是 <code>csim.c</code>（Part A） 和 <code>trans.c</code>（Part B）。编译的时候只需要简单 <code>make clean</code> 和 <code>make</code>，然后就可以进行测试了。</p>
<h1 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h1><p>Github地址：<a href="https://github.com/zhengjingwei/CSAPP-LAB/tree/master/lab4-cachelab" target="_blank" rel="noopener">Cache Lab</a></p>
<ul>
<li>csim.c：实现缓存模拟器的文件</li>
<li>trans.c：实现矩阵转置的文件</li>
<li>csim-ref：标准的缓存模拟器</li>
<li>csim：由你实现的模拟器可执行程序</li>
<li>tracegen：测试你的矩阵转置是否正确，并给出错误信息</li>
<li>test-trans：测试你的矩阵转置优化的如何，并给出评分</li>
<li>driver.py：自动进行测试评分</li>
</ul>
<p>在每一次更新之后，首先用<code>make</code>生成文件，之后用相应的test跑分即可。</p>
<h1 id="Part-A：Writing-a-Cache-Simulator-实现一个缓存模拟器"><a href="#Part-A：Writing-a-Cache-Simulator-实现一个缓存模拟器" class="headerlink" title="Part A：Writing a Cache Simulator 实现一个缓存模拟器"></a>Part A：Writing a Cache Simulator 实现一个缓存模拟器</h1><p>讲义上首先给我们提供了一个程序示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</span><br></pre></td></tr></table></figure>
<p>执行，我们可以看到如下面这样的输出：（输入的trace文件的内容）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">I  04ead900,3</span><br><span class="line">I  04ead903,3</span><br><span class="line">I  04ead906,5</span><br><span class="line">I  04ead838,3</span><br><span class="line">I  04ead83b,3</span><br><span class="line">I  04ead83e,5</span><br><span class="line"> L 1ffefff968,8</span><br><span class="line">I  04ead843,3</span><br><span class="line">I  04ead846,3</span><br><span class="line">I  04ead849,5</span><br><span class="line"> L 1ffefff960,8</span><br><span class="line">I  04ead84e,3</span><br><span class="line">I  04ead851,3</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这样的trace文件中记载着每一次对内存的操作，前面的字母代表操作类型，统一的格式是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[空格][操作类型][空格][内存地址][逗号][大小]</span><br></pre></td></tr></table></figure>
<p>其中如果第一个不是空格而是I，则代表加载，没有实际意义。</p>
<p>操作类型有以下三种：</p>
<ul>
<li>L：读取，从内存中读取</li>
<li>S：存储，向内存中存储</li>
<li>M：修改，这涉及一次读取，一次存储操作</li>
<li>地址指的是一个 64 位的 16 进制内存地址；大小表示该操作内存访问的字节数</li>
<li>其中I指令无空格，M/S/L指令前有1个空格（解析指令时注意）</li>
</ul>
<p>然后实验给我们提供了一个程序<code>csim-ref</code>，我们要做的就是写出一个和它功能一样的程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;</span><br><span class="line">Options:</span><br><span class="line">  -h         Print this help message.</span><br><span class="line">  -v         Optional verbose flag.</span><br><span class="line">  -s &lt;num&gt;   Number of set index bits.</span><br><span class="line">  -E &lt;num&gt;   Number of lines per set.</span><br><span class="line">  -b &lt;num&gt;   Number of block offset bits.</span><br><span class="line">  -t &lt;file&gt;  Trace file.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"><span class="meta">  linux&gt;</span>  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span><br><span class="line"><span class="meta">  linux&gt;</span>  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace</span><br></pre></td></tr></table></figure>
<p>样例输出：</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/EEhaBD13iF.jpg?imageslim" alt="mark"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>getopt</code>    获取命令行参数</p>
<p><code>fscanf</code>    读入trace文件内容</p>
<p><code>malloc</code>    分配空间给cache</p>
<p>数据访问带来的miss：</p>
<ul>
<li>L：Load，数据载入，可能发生1次miss</li>
<li>S：Store，可能发生1次miss</li>
<li>M：store后再load，两次访存。1 miss &amp; 1 hit + 可能eviction</li>
</ul>
<p>所以L/S指令结果是miss或者hit或者miss+eviction；而M指令结果是hit+hit或者miss+hit 或者 miss+eviction+hit</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/bhkkm837CH.png?imageslim" alt="mark"></p>
<h3 id="1-Cache结构"><a href="#1-Cache结构" class="headerlink" title="1 Cache结构"></a>1 Cache结构</h3><p>设计Cache基本单元为 <code>block</code>，cache由cacheblock组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> tag;</span><br><span class="line">	<span class="keyword">unsigned</span> usedtime;</span><br><span class="line">&#125; block;</span><br><span class="line">block *cache;</span><br></pre></td></tr></table></figure>
<p>其中<code>usedtime</code>是判断LRU cache行。初始值为0表示没有用过，相当于invalid。非零值越小代表越少使用，<code>usedtime</code>最大代表刚使用。</p>
<h3 id="2-命令行参数解析"><a href="#2-命令行参数解析" class="headerlink" title="2 命令行参数解析"></a>2 命令行参数解析</h3><p>首先对命令行参数进行解析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOpt</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv,<span class="keyword">int</span> *s,<span class="keyword">int</span> *E,<span class="keyword">int</span> *b,<span class="keyword">int</span> *verbose,<span class="keyword">char</span> *tracefile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> oc;</span><br><span class="line">	<span class="keyword">while</span>((oc=getopt(argc,argv,<span class="string">"hvs:E:b:t:"</span>))!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(oc)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'h'</span>: printHelpMenu();<span class="keyword">break</span>; <span class="comment">// print usage</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">'v'</span>: *verbose=<span class="number">1</span>;<span class="keyword">break</span>; 	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'s'</span>: *s = atoi(optarg);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'E'</span>: *E = atoi(optarg);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'b'</span>: *b = atoi(optarg);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'t'</span>: <span class="built_in">strcpy</span>(tracefile,optarg);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span> : <span class="built_in">printf</span>(<span class="string">"input error\n"</span>);<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-初始化cache"><a href="#3-初始化cache" class="headerlink" title="3 初始化cache"></a>3 初始化cache</h3><p>然后初始化cache：    E&lt;&lt;s 是cache行数也就是E*2^s</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cache = (block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block)* E&lt;&lt;s);</span><br><span class="line"><span class="built_in">memset</span>(cache,<span class="number">0</span>,<span class="keyword">sizeof</span>(block)* E&lt;&lt;s);</span><br></pre></td></tr></table></figure>
<h3 id="4-读取文件参数"><a href="#4-读取文件参数" class="headerlink" title="4 读取文件参数"></a>4 读取文件参数</h3><p><code>fscanf</code>读取trace文件中的指令、地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen (tracefile,<span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">"%s%x,%d\n"</span>,op,&amp;addr,&amp;size) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(verbose)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %x,%d "</span>,op,addr,size);</span><br><span class="line">  <span class="keyword">switch</span>(op[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'M'</span>: hit++;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>: find(op[<span class="number">0</span>],addr,size,++t);     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-数据访问"><a href="#5-数据访问" class="headerlink" title="5 数据访问"></a>5 数据访问</h3><p>获取<code>tag</code>和 <code>set index</code></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/GJkm8I2hd3.png?imageslim" alt="mark"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> tag = addr &gt;&gt;b &gt;&gt;s ;</span><br><span class="line"><span class="keyword">unsigned</span> set_index = addr &gt;&gt; b &amp;((<span class="number">1</span>&lt;&lt;s) <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>找到对应的set</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block *cache_set = cache + E * set_index ;  <span class="comment">// set address</span></span><br><span class="line">block *eviction_block = cache_set;            <span class="comment">// LRU cacheline</span></span><br></pre></td></tr></table></figure>
<p>进行数据查找，其中eviction_block表示查询过程中LRU的cache行，也就是<code>usedtime</code>最小的（但是非0）在一个set里面遍历cache行</p>
<ul>
<li>如果<code>usedtime</code>！=0且tag匹配：hit</li>
<li>如果<code>usedtime</code>=0，是个空block，使用这个block：miss</li>
<li>如果<code>usedtime</code>！=0，tag不匹配，跟<code>eviction_block.usedtime</code>比较，如果时间更小，更新<code>eviction_block</code>=该cacheblock</li>
</ul>
<p>如果循环结束，也就证明这个set的所有cache行都满了，就替换LRU cache行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> op, <span class="keyword">unsigned</span> addr,<span class="keyword">unsigned</span> size,<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> tag = addr &gt;&gt;b &gt;&gt;s ;</span><br><span class="line">    <span class="keyword">unsigned</span> set_index = addr &gt;&gt; b &amp;((<span class="number">1</span>&lt;&lt;s) <span class="number">-1</span>);</span><br><span class="line">    block *cache_set = cache + E * set_index ;  <span class="comment">// set address</span></span><br><span class="line">    block *eviction_block = cache_set;            <span class="comment">// LRU cacheline</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache_set[i].usedtime&gt;<span class="number">0</span> &amp;&amp; cache_set[i].tag ==tag)&#123; <span class="comment">//hit</span></span><br><span class="line">            cache_set[i].usedtime = time;</span><br><span class="line">            hit++;</span><br><span class="line">            <span class="keyword">if</span>(verbose) cacheStateOut(op,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!cache_set[i].usedtime)&#123; <span class="comment">// empty block</span></span><br><span class="line">            miss++;</span><br><span class="line">            cache_set[i].tag = tag;</span><br><span class="line">            cache_set[i].usedtime = time;</span><br><span class="line">            <span class="keyword">if</span>(verbose) cacheStateOut(op,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cache_set[i].usedtime &lt; eviction_block-&gt;usedtime) <span class="comment">// !=tag , current block is older</span></span><br><span class="line">            eviction_block = cache_set+i;                          </span><br><span class="line">    &#125;</span><br><span class="line">    miss ++;</span><br><span class="line">    eviction ++;</span><br><span class="line">    eviction_block-&gt;tag = tag; <span class="comment">// replace sacrifice cacheline</span></span><br><span class="line">    eviction_block-&gt;usedtime = time;</span><br><span class="line">    <span class="keyword">if</span>(verbose) cacheStateOut(op,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/igHA04Lg15.png?imageslim" alt="mark"></p>
<p>结果正确</p>
<h1 id="Part-B：Optimizing-Matrix-Transpose-优化矩阵转置"><a href="#Part-B：Optimizing-Matrix-Transpose-优化矩阵转置" class="headerlink" title="Part B：Optimizing Matrix Transpose 优化矩阵转置"></a>Part B：Optimizing Matrix Transpose 优化矩阵转置</h1><p>要求优化对不同规格的矩阵的转置操作。 这里有三个矩阵，他们的miss次数要求分别如下：</p>
<ul>
<li>32 * 32: 8 points if m &lt; 300, 0 points if m &gt; 600</li>
<li>64 × 64: 8 points if m &lt; 1300, 0 points if m &gt; 2000</li>
<li>61 × 67: 10 points if m &lt; 2000, 0 points if m &gt; 3000</li>
</ul>
<p>要求</p>
<ul>
<li>在tranc.c里进行完成 transpose_submit函数</li>
<li>最多使用12个int型变量，不能使用数组和malloc函数，不能使用位运算，不能改变矩阵A</li>
</ul>
<p>Tips</p>
<p>题目的cache参数如下：s=5，E=1，b=5</p>
<ul>
<li>是一个直接映射高速缓存</li>
<li>32字节的Block size</li>
<li>有32个set</li>
</ul>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即<u>不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写</u>）。 但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。</p>
<p>在该实验中，缓存采用的是直接映射高速缓存，<code>s = 5，b = 5，E = 1</code>。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，矩阵大小&gt;cache大小。主要需要解决以下两个问题：</p>
<ol>
<li>直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，<strong>矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组</strong>。当进行<strong>对角线的引用</strong>时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。 </li>
<li>所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。</li>
</ol>
<p>为了解决第一个问题，我们需要仔细地考虑对于矩阵访问顺序；第二个问题，采用矩阵的分块（Blocking）方法降低miss</p>
<blockquote>
<p>矩阵分块的目的在于将大的、不能完全加载进入缓存的大矩阵分块成小的、可以完全加载进入缓存的小矩阵块来处理。小矩阵块具有良好的局部性，性能显著增加。 但同时也要注意，分块使得程序的可阅读性大大降低，因此一般只在常用的库函数中采用分块优化。</p>
</blockquote>
<h2 id="32-32"><a href="#32-32" class="headerlink" title="32 * 32"></a>32 * 32</h2><p>对于<code>32 * 32</code>的矩阵，一次可以装下8行的值。于是我们用<code>8 * 8</code>的分块来处理，增加缓存命中。</p>
<p>在<code>32*32</code>的情况中，一行是32个int，也就是4个block，所以cache可以存8行，由此可以推出映射冲突的情况：<strong>只要两个int之间相差8行的整数倍，那么读取这两个元素所在的block就会发生替换</strong></p>
<p>但是转置的过程中这样的情况会发生吗？不会。<strong>图中的BCD三点对于A来说仅仅是行差了8K，这在转置中是不可能发生的！</strong>因为转置是将<code>A[i][j]</code>送到<code>B[j][i]</code>，不会有<code>B[i+8k][j]</code>的情况出现（不会在行相差8整数倍的块中，除非对角线上的块）。所以B在写入时miss概率也是1/8（强制失效）。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/bEfJH10E8a.jpg?imageslim" alt="mark"></p>
<p>一个cache block只有32个Byte，可以装下8个int。这个cache可以容纳矩阵的前8行。所以分块采用8 * 8合适。先读取A的一行，然后放入B的一列。12个int变量，4个用来循环，其余8个用来存A中块的一行。</p>
<p>简单<code>8 * 8</code>分块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(M == <span class="number">32</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j+=<span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = i ;k &lt; i + <span class="number">8</span> &amp;&amp; k&lt;N;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(l = j ; l &lt; j + <span class="number">8</span> &amp;&amp; l &lt; M;l++)</span><br><span class="line">                    &#123;                            </span><br><span class="line">                        a0 = A[k][l];</span><br><span class="line">                        B[l][k] = a0;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：超过了300miss，原因是<strong>对角线访问问题</strong></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/j8hHgF5K80.jpg?imageslim" alt="mark"></p>
<blockquote>
<p>对角线上的block访问miss问题：</p>
</blockquote>
<p><strong>矩阵A和矩阵B的同一行实际上被映射到了同一个cache block</strong>。当进行<strong>对角线的引用</strong>时，一定会发生缓存的冲突不命中。并且，由于A和B的元素时一个一个处理的，必定会造成反复多次的冲突不命中。（如下图A第一个元素读miss，B第一个元素存miss，A读第二个元素miss）</p>
<p>解决方法：通过变量一次性读出A的一整行，再存入B</p>
<p><strong>cache miss分析</strong></p>
<p>（经过对角线块优化后）对于32 × 32的矩阵，总共存在1024次读(32*32)和1024次写。</p>
<p>对于非对角线的分块（总共12个），其缓存不命中率是1/8（仅强制不命中）；</p>
<p>对于对角线的分块（总共4个），A读缓冲不命中率1/8（仅强制不命中），B写不命中率1/4（强制失效 1/8 + 冲突不命中 1/8（A刚读的那行B写的时候会miss））</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/E5ec7Cb7Dj.jpg?imageslim" alt="mark"></p>
<p>因此，理论上优化之后的总缓存不命中数为2048 × 0.75 × 0.125 + 1024 × 0.25 × 0.125 + 1024 × 0.25 × 0.25 = 288次。最后跑出来的答案是287，非常接近。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j+=<span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(k = i ;k &lt; i + <span class="number">8</span> &amp;&amp; k&lt;N;k++)&#123; </span><br><span class="line">                        a0 = A[k][j];   </span><br><span class="line">                        a1 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                        a2 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                        a3 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                        a4 = A[k][j+<span class="number">4</span>]; </span><br><span class="line">                        a5 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                        a6 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                        a7 = A[k][j+<span class="number">7</span>];</span><br><span class="line">                        B[j][k]   = a0;</span><br><span class="line">                        B[j+<span class="number">1</span>][k] = a1;</span><br><span class="line">                        B[j+<span class="number">2</span>][k] = a2;</span><br><span class="line">                        B[j+<span class="number">3</span>][k] = a3;</span><br><span class="line">                        B[j+<span class="number">4</span>][k] = a4;</span><br><span class="line">                        B[j+<span class="number">5</span>][k] = a5;</span><br><span class="line">                        B[j+<span class="number">6</span>][k] = a6;</span><br><span class="line">                        B[j+<span class="number">7</span>][k] = a7;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(k = i ;k &lt; i + <span class="number">8</span> &amp;&amp; k&lt;N;k++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(l = j ; l &lt; j + <span class="number">8</span> &amp;&amp; l &lt; M;l++)</span><br><span class="line">                            B[l][k] = A[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：287miss</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/mIdL8B1Hl3.jpg?imageslim" alt="mark"></p>
<h2 id="64-64"><a href="#64-64" class="headerlink" title="64 * 64"></a>64 * 64</h2><p>这题难度是最大的，miss必须1300以下</p>
<p>首先考虑Cache中只能放4行A中的行，如果再用8×8的块，前面4行可以填入，后面4行会在Cache中发生冲突，导致miss次数增加。</p>
<p>如果只用<code>4×4</code>的块呢？那么每次Cache中放入8个int，我们却只用4个，浪费严重，这个方法最少也只能做到1677次miss。</p>
<p>题目说不能对A进行操作，但是可以<strong>对B进行操作</strong>！将B作为缓存使用</p>
<p><strong>改进方法</strong>：将<code>8 * 8</code> 块再分成4个<code>4 * 4</code>的块进一步处理，经过改进，达到1171miss</p>
<p>首先对左上角和右上角进行处理：</p>
<ol>
<li>B左上角 = A左上角转置。B右上角=A右上角转置。</li>
<li>我们最后只需要把这部分平移到B的左下角就好。</li>
</ol>
<p>现在B左上角完成</p>
<ol>
<li>首先用四个变量存储A的左下角的一列。</li>
<li>再用四个变量存储B的右上角的一行。</li>
<li>把四个变量存储的A的左下角的一列移动到B右上角的一行</li>
<li>把四个变量存储的B的右上角的一行平移到B左下角的一列</li>
<li>B的右下角=A的右下角转置</li>
</ol>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/jbfAdE5iA2.jpg?imageslim" alt="mark"></p>
<p>关键的操作在第二步</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (k = i; k &lt; i + <span class="number">4</span>; k++) &#123;</span><br><span class="line">               a0 = A[k][j];</span><br><span class="line">               a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">               a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">               a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">               a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">               a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">               a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">               a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">               B[j][k] = a0;</span><br><span class="line">               B[j + <span class="number">1</span>][k] = a1;</span><br><span class="line">               B[j + <span class="number">2</span>][k] = a2;</span><br><span class="line">               B[j + <span class="number">3</span>][k] = a3;</span><br><span class="line"></span><br><span class="line">               B[j][k + <span class="number">4</span>] = a4;</span><br><span class="line">               B[j + <span class="number">1</span>][k + <span class="number">4</span>] = a5;</span><br><span class="line">               B[j + <span class="number">2</span>][k + <span class="number">4</span>] = a6;</span><br><span class="line">               B[j + <span class="number">3</span>][k + <span class="number">4</span>] = a7;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (l = j + <span class="number">4</span>; l &lt; j + <span class="number">8</span>; l++) &#123;</span><br><span class="line"></span><br><span class="line">               a4 = A[i + <span class="number">4</span>][l - <span class="number">4</span>]; <span class="comment">// A left-down col</span></span><br><span class="line">               a5 = A[i + <span class="number">5</span>][l - <span class="number">4</span>];</span><br><span class="line">               a6 = A[i + <span class="number">6</span>][l - <span class="number">4</span>];</span><br><span class="line">               a7 = A[i + <span class="number">7</span>][l - <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">               a0 = B[l - <span class="number">4</span>][i + <span class="number">4</span>]; <span class="comment">// B right-above line</span></span><br><span class="line">               a1 = B[l - <span class="number">4</span>][i + <span class="number">5</span>];</span><br><span class="line">               a2 = B[l - <span class="number">4</span>][i + <span class="number">6</span>];</span><br><span class="line">               a3 = B[l - <span class="number">4</span>][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">               B[l - <span class="number">4</span>][i + <span class="number">4</span>] = a4; <span class="comment">// set B right-above line </span></span><br><span class="line">               B[l - <span class="number">4</span>][i + <span class="number">5</span>] = a5;</span><br><span class="line">               B[l - <span class="number">4</span>][i + <span class="number">6</span>] = a6;</span><br><span class="line">               B[l - <span class="number">4</span>][i + <span class="number">7</span>] = a7;</span><br><span class="line"></span><br><span class="line">               B[l][i] = a0;         <span class="comment">// set B left-down col</span></span><br><span class="line">               B[l][i + <span class="number">1</span>] = a1;</span><br><span class="line">               B[l][i + <span class="number">2</span>] = a2;</span><br><span class="line">               B[l][i + <span class="number">3</span>] = a3;</span><br><span class="line"></span><br><span class="line">               B[l][i + <span class="number">4</span>] = A[i + <span class="number">4</span>][l];</span><br><span class="line">               B[l][i + <span class="number">5</span>] = A[i + <span class="number">5</span>][l];</span><br><span class="line">               B[l][i + <span class="number">6</span>] = A[i + <span class="number">6</span>][l];</span><br><span class="line">               B[l][i + <span class="number">7</span>] = A[i + <span class="number">7</span>][l];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：1171miss 通过</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/2ja1lD75JF.jpg?imageslim" alt="mark"></p>
<h2 id="61-67"><a href="#61-67" class="headerlink" title="61 * 67"></a>61 * 67</h2><p>不规则的matrix，本质也是用分块来优化Cache的读写，但是不能找到比较显然的规律看出来间隔多少可以填满一个Cache。但是由于要求比较松，因此无需考虑处理对角线，直接进行转置操作，仅尝试换用不同的边长分块即可。16 × 16的分块已可以保证满分。</p>
<p>测试：1992miss &lt;2000</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180125/CC18K27db0.jpg?imageslim" alt="mark"></p>
<p>自动评分脚本输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">zjw@ubuntu:~/Desktop/cachelab-handout$ ./driver.py </span><br><span class="line">Part A: Testing cache simulator</span><br><span class="line">Running ./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     <span class="number">3</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)       <span class="number">9</span>       <span class="number">8</span>       <span class="number">6</span>       <span class="number">9</span>       <span class="number">8</span>       <span class="number">6</span>  traces/yi2.trace</span><br><span class="line">     <span class="number">3</span> (<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>)       <span class="number">4</span>       <span class="number">5</span>       <span class="number">2</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">2</span>  traces/yi.trace</span><br><span class="line">     <span class="number">3</span> (<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>)       <span class="number">2</span>       <span class="number">3</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">1</span>  traces/dave.trace</span><br><span class="line">     <span class="number">3</span> (<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)     <span class="number">167</span>      <span class="number">71</span>      <span class="number">67</span>     <span class="number">167</span>      <span class="number">71</span>      <span class="number">67</span>  traces/trans.trace</span><br><span class="line">     <span class="number">3</span> (<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)     <span class="number">201</span>      <span class="number">37</span>      <span class="number">29</span>     <span class="number">201</span>      <span class="number">37</span>      <span class="number">29</span>  traces/trans.trace</span><br><span class="line">     <span class="number">3</span> (<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)     <span class="number">212</span>      <span class="number">26</span>      <span class="number">10</span>     <span class="number">212</span>      <span class="number">26</span>      <span class="number">10</span>  traces/trans.trace</span><br><span class="line">     <span class="number">3</span> (<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>)     <span class="number">231</span>       <span class="number">7</span>       <span class="number">0</span>     <span class="number">231</span>       <span class="number">7</span>       <span class="number">0</span>  traces/trans.trace</span><br><span class="line">     <span class="number">6</span> (<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>)  <span class="number">265189</span>   <span class="number">21775</span>   <span class="number">21743</span>  <span class="number">265189</span>   <span class="number">21775</span>   <span class="number">21743</span>  traces/<span class="keyword">long</span>.trace</span><br><span class="line">    <span class="number">27</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Part B: Testing transpose function</span><br><span class="line">Running ./test-trans -M <span class="number">32</span> -N <span class="number">32</span></span><br><span class="line">Running ./test-trans -M <span class="number">64</span> -N <span class="number">64</span></span><br><span class="line">Running ./test-trans -M <span class="number">61</span> -N <span class="number">67</span></span><br><span class="line"></span><br><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          <span class="number">27.0</span>        <span class="number">27</span></span><br><span class="line">Trans perf <span class="number">32</span>x32           <span class="number">8.0</span>         <span class="number">8</span>         <span class="number">287</span></span><br><span class="line">Trans perf <span class="number">64</span>x64           <span class="number">8.0</span>         <span class="number">8</span>        <span class="number">1171</span></span><br><span class="line">Trans perf <span class="number">61</span>x67          <span class="number">10.0</span>        <span class="number">10</span>        <span class="number">1992</span></span><br><span class="line">          Total points    <span class="number">53.0</span>        <span class="number">53</span></span><br></pre></td></tr></table></figure>
<h1 id="Referrence"><a href="#Referrence" class="headerlink" title="Referrence"></a>Referrence</h1><p><a href="http://zxcpyp.com/csapp/2017/11/20/Cache-Lab#part-awriting-a-cache-simulator-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F%E5%99%A8" target="_blank" rel="noopener">http://zxcpyp.com/csapp/2017/11/20/Cache-Lab#part-awriting-a-cache-simulator-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F%E5%99%A8</a></p>
]]></content>
      
        <categories>
            
            <category> 体系结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux网络协议栈结构]]></title>
      <url>/2018/01/30/linux-network-stack-structure/</url>
      <content type="html"><![CDATA[<p>网络栈层次结构如下图：</p>
<p><img src="http://my.csdn.net/uploads/201204/25/1335324208_7578.png" alt="img"></p>
<ul>
<li><strong>应用层</strong>  由应用程序提供。它通常是一个语义层，能够理解要传输的数据。例如，超文本传输协议（HTTP）就负责传输服务器和客户机之间对 Web 内容的请求与响应</li>
<li><strong>传输层</strong>  负责端到端的通信（一台机子内部）-TCP、UDP</li>
<li><strong>网络层 </strong> 负责管理主机之间的通信 -IP</li>
<li><strong>链路层 </strong> 对物理层访问的设备驱动程序，如网卡驱动</li>
<li><strong>物理层</strong>  主要提供各种连接的物理设备，如各种网卡，串口卡等</li>
</ul>
<h1 id="Linux网络协议栈结构"><a href="#Linux网络协议栈结构" class="headerlink" title="Linux网络协议栈结构"></a>Linux网络协议栈结构</h1><ol>
<li><strong>系统调用接口层</strong>  实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。</li>
<li><strong>协议无关的接口层</strong>，就是<strong>SOCKET层</strong>，这一层的目的是屏蔽底层的不同协议（更准确的来说主要是TCP与UDP，当然还包括RAW IP， SCTP等），以便与系统调用层之间的接口可以简单，统一。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个SOCKET，这个SOCKET其实是一个巨大的<code>sock</code>结构，它和下面一层的网络协议层联系起来，屏蔽了不同的网络协议的不同，只把数据部分呈现给应用层（通过系统调用接口来呈现）。</li>
<li><strong>网络协议实现层</strong>，毫无疑问，这是整个协议栈的核心。这一层主要实现各种网络协议，最主要的当然是IP，ICMP，ARP，RARP，TCP，UDP等。这一层包含了很多设计的技巧与算法，相当的不错。</li>
<li><strong>与具体设备无关的驱动接口层</strong>，这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如open，close，init等，这一层可以屏蔽底层不同的驱动程序。</li>
<li><strong>驱动程序层</strong>，这一层的目的就很简单了，就是建立与硬件的接口层。</li>
</ol>
<p><img src="http://7xir15.com1.z0.glb.clouddn.com/ANS-figure2.gif" alt="图2"></p>
<p><img src="http://my.csdn.net/uploads/201205/19/1337417897_6792.jpg" alt="img"></p>
<h2 id="1-系统调用接口层"><a href="#1-系统调用接口层" class="headerlink" title="1 系统调用接口层"></a>1 系统调用接口层</h2><p>系统调用接口层实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。系统调用接口可以从两个角度进行描述：<strong>当用户进行网络调用时</strong>，通过系统调用接口多路复用到内核中。这最终作为 <code>sys_socketcall</code>(<code>./net/socket.c</code>)中的调用，然后进一步解复用到其预期目标的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(socket, <span class="keyword">int</span>, family, <span class="keyword">int</span>, type, <span class="keyword">int</span>, protocol)</span><br><span class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)</span><br><span class="line">SYSCALL_DEFINE2(listen, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, backlog)</span><br><span class="line">SYSCALL_DEFINE3(accept, <span class="keyword">int</span>, fd, struct sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		<span class="keyword">int</span> __user *, upeer_addrlen)</span><br><span class="line">        SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line">        		<span class="keyword">int</span>, addrlen)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>系统调用接口的另一个角度是<strong>使用正常的文件操作进行网络I/O</strong>。例如，典型的读写操作可以在网络socket（由文件描述符表示，就像普通文件）一样执行。因此，虽然存在一些特定于网络的操作（调用<code>socket</code>创建socket，调用<code>connect</code>将socket连接到目的地等等），但还是有一些适用于网络对象的标准文件操作，就像常规文件一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">socket_file_ops</span> = &#123;</span></span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.llseek =	no_llseek,</span><br><span class="line">	.read_iter =	sock_read_iter,</span><br><span class="line">	.write_iter =	sock_write_iter,</span><br><span class="line">struct file *sock_alloc_file(struct socket *sock, <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dname)</span><br><span class="line">&#123;</span><br><span class="line">    file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE,</span><br><span class="line">		  &amp;socket_file_ops);</span><br></pre></td></tr></table></figure>
<p>最后，系统调用接口提供了在用户空间应用程序和内核之间传输控制的手段。</p>
<h2 id="2-协议无关接口层-Socket层"><a href="#2-协议无关接口层-Socket层" class="headerlink" title="2 协议无关接口层(Socket层)"></a>2 协议无关接口层(Socket层)</h2><p>socket层是协议无关接口，其<strong>提供一组通用功能，以支持各种不同的协议</strong>。socket层不仅支持典型的TCP和UDP协议，还支持原始以太网和其他传输协议，如流控制传输协议（SCTP）。</p>
<p>网络栈使用socket通信。Linux中的socket结构<code>struct sock</code>是在<code>include/net/sock.h</code>中定义的。该大型结构包含特定socket的所有必需状态，包括socket使用的特定协议以及可能在其上执行的操作。它屏蔽了不同网络协议的区别，只把数据部分呈现给应用层（通过系统调用接口）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now struct inet_timewait_sock also uses sock_common, so please just</span></span><br><span class="line"><span class="comment">	 * don't add nothing before this first member (__sk_common) --acme</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span>	__<span class="title">sk_common</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sk_prot			__sk_common.skc_prot</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>		*<span class="title">sk_prot_creator</span>;</span></span><br></pre></td></tr></table></figure>
<p>网络子系统通过定义了其功能的特殊结构（即<code>proto</code>）来了解各个可用协议。每个协议维护一个名为<code>proto</code>（在<code>linux/include/net/sock.h</code>中找到）的结构。<u>该结构定义了可以从socket层到传输层执行的特定socket操作</u>（例如，如何创建socket，如何与socket建立连接，如何关闭socket等，由各自协议决定如何实现）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> = &#123;</span></span><br><span class="line">	.name			= <span class="string">"TCP"</span>,</span><br><span class="line">	.owner			= THIS_MODULE,</span><br><span class="line">	.close			= tcp_close,</span><br><span class="line">	.connect		= tcp_v4_connect,</span><br><span class="line">	.disconnect		= tcp_disconnect,</span><br><span class="line">	.accept			= inet_csk_accept,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="3-网络协议层"><a href="#3-网络协议层" class="headerlink" title="3 网络协议层"></a>3 网络协议层</h2><p>网络协议部分定义了可用的特定网络协议（如TCP，UDP等的具体实现）。这些是在<code>linux/net/ipv4/af_inet.c</code>中的<code>inet_init</code>函数的开头进行初始化的（因为TCP和UDP是协议inet族的一部分）。<code>inet_init</code>函数调用<code>proto_register</code>注册每个内置协议。<code>proto_register</code>在<code>linux/net/core/sock.c</code>中定义，除了将协议添加到活动协议列表之外，还可以根据需要分配一个或多个slab缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proto_register</span><span class="params">(struct proto *prot, <span class="keyword">int</span> alloc_slab)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (alloc_slab) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">	  ...</span><br><span class="line">	mutex_lock(&amp;proto_list_mutex);</span><br><span class="line">	list_add(&amp;prot-&gt;node, &amp;proto_list);</span><br><span class="line">	assign_proto_idx(prot);</span><br><span class="line">	mutex_unlock(&amp;proto_list_mutex);</span><br><span class="line">...  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">inet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">r</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">	sock_skb_cb_check_size(<span class="keyword">sizeof</span>(struct inet_skb_parm));</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line">..</span><br><span class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">		inet_register_protosw(q);</span><br><span class="line"></span><br><span class="line">		arp_init();</span><br><span class="line">		ip_init();</span><br><span class="line">		tcp_init();</span><br><span class="line">		udp_init();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_STREAM,</span><br><span class="line">		.protocol =   IPPROTO_TCP,</span><br><span class="line">		.prot =       &amp;tcp_prot,</span><br><span class="line">		.ops =        &amp;inet_stream_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">			      INET_PROTOSW_ICSK,</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>
<p>您可以通过<code>linux/net/ipv4/</code>中的文件<code>tcp_ipv4.c</code>，<code>udp.c</code>和<code>raw.c</code>中的proto结构来了解各自的协议。这些协议的proto结构体都按照类型和协议映射到<code>inetsw_array</code>，将内部协议映射到对应的操作(which maps the built-in protocols to their operations.)。结构体<code>inetsw_array</code>及其关系如图3所示。该数组中的每个协议都在初始化<code>inetsw</code>时，通过在<code>inet_init</code>调用<code>inet_register_protosw</code>来初始化。函数<code>inet_init</code>还初始化各种inet模块，如ARP，ICMP，IP模块，TCP和UDP模块。</p>
<p>图3. Internet协议数组的结构</p>
<p><img src="http://7xir15.com1.z0.glb.clouddn.com/ANS-figure3.gif" alt="图3. Internet协议数组的结构"></p>
<p><strong>Socket协议关联</strong></p>
<p>回想下，当创建一个socket时，它定义了类型和协议，如 <code>my_sock = socket( AF_INET, SOCK_STREAM, 0 )</code>。其中AF_INET表示基于Internet地址族，SOCK_STREAM表示其为流式socket（如上所示<code>inetsw_array</code>）。</p>
<p>从图3可以看出， <u><code>proto</code>结构定义了特定传输协议的方法，而<code>proto_ops</code>结构定义了一般的socket方法</u>。其他额外的协议可以通过调用<code>inet_register_protosw</code>将自己加入到<code>inetsw</code>协议开关机(protocol switch) 。例如，SCTP通过在<code>linux/net/sctp/protocol.c</code>中调用<code>sctp_init</code>来添加自己。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>		family;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>	*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">int</span>		(*release)   (struct socket *sock);</span><br><span class="line">	<span class="keyword">int</span>		(*bind)	     (struct socket *sock,</span><br><span class="line">				      struct sockaddr *myaddr,</span><br><span class="line">				      <span class="keyword">int</span> sockaddr_len);</span><br><span class="line">	<span class="keyword">int</span>		(*connect)   (struct socket *sock,</span><br><span class="line">				      struct sockaddr *vaddr,</span><br><span class="line">				      <span class="keyword">int</span> sockaddr_len, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span>		(*socketpair)(struct socket *sock1,</span><br><span class="line">				      struct socket *sock2);</span><br><span class="line">	<span class="keyword">int</span>		(*accept)    (struct socket *sock,</span><br><span class="line">				      struct socket *newsock, <span class="keyword">int</span> flags);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：<code>prot</code>/<code>prot_ops</code>二者有点相似，这里特意说明下：<u>kernel的调用顺序是先inet(即prot_ops)，后protocal（即prot）</u>，inet层处于socket和具体protocol之间。下面以connect为例，<code>ops</code>即为prot_ops，它调用的connect是<code>inet_listen</code>，然后才是具体protocol的<code>tcp_v4_connect</code>。这一关系主要记录在<code>inetsw_array</code>中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line">		<span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">...</span><br><span class="line">	err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</span><br><span class="line">				 sock-&gt;file-&gt;f_flags);</span><br><span class="line"> <span class="keyword">int</span> __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line"> 			  <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags, <span class="keyword">int</span> is_sendmsg)</span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">	<span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">	<span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">		err = -EISCONN;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>socket的数据移动使用核心结构socket缓冲区（<code>sk_buff</code>）来进行。一个<code>sk_buff</code> 包含包数据(package data)，和状态数据（state data, 覆盖协议栈的多个层）。每个发送或接收的数据包都用一个<code>sk_buff</code>来表示。该<code>sk_buff</code> 结构是在<code>linux/include/linux/skbuff.h</code>中定义的，并在图4中示出。</p>
<p>图4. Socket缓冲区及其与其他结构的关系</p>
<p><img src="http://7xir15.com1.z0.glb.clouddn.com/ANS-figure4.gif" alt="图4. Socket缓冲区及其与其他结构的关系"></p>
<p>如图所示，一个给定连接的多个sk_buff可以串联在一起。每个sk_buff标识了要发送数据包或从其接收数据包的设备结构（<code>net_device *dev</code>）。由于每个包都表示为一个<code>sk_buff</code>，数据包报头可方便地通过一组指针来寻址（<code>th</code>，<code>iph</code>以及<code>mac</code>（MAC报头）），内核会保证这块内存是连续的。由于<code>sk_buff</code> 是socket数据管理的核心，因此kernel已经创建了许多支撑函数来管理它们，包括sk_buff的创建和销毁，克隆和队列管理等函数。</p>
<p>总的来说，<strong>内核socket缓冲器设计思路是，某一的socket的sk_buff串链接在一起，并且sk_buff包括许多信息，包括到协议头的指针，时间戳（发送或接收数据包的时间）以及与数据包相关的网络设备。</strong></p>
<h2 id="4-设备无关接口层"><a href="#4-设备无关接口层" class="headerlink" title="4 设备无关接口层"></a>4 设备无关接口层</h2><p>协议层下面是另一个无关的接口层，<strong>将协议连接到具有不同功能的各种硬件设备的驱动程序</strong>。该层提供了一组通用的功能，由较低级别的网络设备驱动程序使用，以允许它们使用较高级协议栈进行操作。</p>
<p>首先，设备驱动程序可以通过调用<code>register_netdevice</code>/<code>unregister_netdevice</code>将自己注册/去注册到内核。调用者首先填写<code>net_device</code>结构，然后将其传入<code>register_netdevice</code>进行注册。内核调用其init功能（如果有定义），执行许多健全检查，创建一个 sysfs条目，然后将新设备添加到设备列表（在内核中Active设备的链表）。你可以 在<code>linux/include/linux/netdevice.h</code>中找到<code>net_device</code>结构。各个函数在<code>linux/net/core/dev.c</code>中实现。</p>
<p>使用<code>dev_queue_xmit</code>函数将<code>sk_buff</code>从协议层发送到网络设备。<code>dev_queue_xmit</code>函数会将<code>sk_buff</code>添加到底层网络设备驱动程序最终要传输的队列中（网络设备在<code>net_device</code>或者<code>sk_buff-&gt;dev</code>中定义）。<code>dev</code>结构包含函数<code>hard_start_xmit</code>，保存用于启动sk_buff传输的驱动程序功能的方法。</p>
<p>通常使用<code>netif_rx</code>接收报文数据。当下级设备驱动程序接收到一个包（包含在新分配的<code>sk_buff</code>）时，内核通过调用<code>netif_rx</code>将<code>sk_buff</code>传递给网络层。然后，<code>netif_rx</code>通过调用<code>netif_rx_schedule</code>将<code>sk_buff</code>排队到上层协议的队列以进行进一步处理。您可以在<code>linux/net/core/dev.c</code> 中找到<code>dev_queue_xmit</code>和<code>netif_rx</code>函数。</p>
<p>最近，在内核中引入了一个新的应用程序接口（NAPI），以允许驱动程序与设备无关层（dev）进行交互。一些驱动程序使用NAPI，但绝大多数仍然使用较旧的帧接收接口（by a rough factor of six to one）。NAPI可以通过避免每个传入帧的中断，在高负载下得到更好的性能。</p>
<h2 id="5-设备驱动程序"><a href="#5-设备驱动程序" class="headerlink" title="5 设备驱动程序"></a>5 设备驱动程序</h2><p>网络栈的底部是管理物理网络设备的设备驱动程序。该层的设备示例包括串行接口上的SLIP驱动程序或以太网设备上的以太网驱动程序。</p>
<p>在初始化时，设备驱动程序分配一个<code>net_device</code>结构，然后用其必需的例程进行初始化。<code>dev-&gt;hard_start_xmit</code>就是其中一个例程，它定义了上层如何排队<code>sk_buff</code>用以传输。这个程序需要一个<code>sk_buff</code>。此功能的操作取决于底层硬件，但通常将<code>sk_buff</code>中的数据包移动到硬件环或队列。如设备无关层所述，帧接收使用该<code>netif_rx</code>接口或符合NAPI的网络驱动程序的<code>netif_receive_skb</code>。NAPI驱动程序对底层硬件的功能提出了约束。</p>
<p>在设备驱动程序配置其结构中的<code>dev</code>接口后，调用<code>register_netdevice</code>以后驱动就可以使用了。您可以在<code>linux/drivers/net</code>中找到网络设备专用的驱动程序。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://ieevee.com/tech/2017/06/12/kernel-network-stack.html" target="_blank" rel="noopener">Linux网络栈解剖</a></p>
]]></content>
      
        <categories>
            
            <category> 网络协议栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> 网络协议栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP实验2:BombLab]]></title>
      <url>/2018/01/30/CSAPP-lab2-bomblab/</url>
      <content type="html"><![CDATA[<h1 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h1><p>​    Bomb LAB 目的是熟悉汇编。</p>
<p>​    一共有7关，六个常规关卡和一个隐藏关卡，每次我们需要输入正确的拆弹密码才能进入下一关，而具体的拆弹密码藏在汇编代码中。实验中的<code>bomb</code>实际上是一个程序的二进制文件，该程序由一系列phase组成，每个phase需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印BOOM!!!</p>
<p>​    完成整个实验的思路是通过<code>objdump</code>对<code>bomb</code>进行反编译（<code>objdump -d bomb &gt; bomb.txt</code>），获取所有的汇编代码。提取每个阶段对应的代码并借助<code>gdb</code>进行分析，逐一拆弹。</p>
<p>Github地址：<a href="https://github.com/zhengjingwei/CSAPP-LAB/tree/master/lab2-bomblab" target="_blank" rel="noopener">Bomb Lab</a></p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="汇编复习"><a href="#汇编复习" class="headerlink" title="汇编复习"></a>汇编复习</h2><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>例子</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>常量</td>
<td>符号<code>$</code> 开头</td>
<td><code>$-42</code>, <code>$0x15213</code></td>
<td>一定要注意十进制还是十六进制</td>
</tr>
<tr>
<td>寄存器</td>
<td>符号 <code>%</code> 开头</td>
<td><code>%esi</code>, <code>%rax</code></td>
<td>可能存的是值或者地址</td>
</tr>
<tr>
<td>内存地址</td>
<td>括号括起来</td>
<td><code>(%rbx)</code>, <code>0x1c(%rax)</code>, <code>0x4(%rcx, %rdi, 0x1)</code></td>
<td>括号实际上是去寻址的意思</td>
</tr>
</tbody>
</table>
<p>一些汇编语句与实际命令的转换：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov %rbx, %rdx</code></td>
<td><code>rdx = rbx</code></td>
</tr>
<tr>
<td><code>add (%rdx), %r8</code></td>
<td><code>r8 += value at rdx</code></td>
</tr>
<tr>
<td><code>mul $3, %r8</code></td>
<td><code>r8 *= 3</code></td>
</tr>
<tr>
<td><code>sub $1, %r8</code></td>
<td><code>r8--</code></td>
</tr>
<tr>
<td><code>lea (%rdx, %rbx, 2), %rdx</code></td>
<td><code>rdx = rdx + rbx*2</code></td>
</tr>
</tbody>
</table>
<p>比较与跳转是拆弹的关键，基本所有的字符判断就是通过比较来实现的，比方说 <code>cmp b,a</code> 会计算 <code>a-b</code> 的值，<code>test b, a</code> 会计算 <code>a&amp;b</code>，注意运算符的顺序。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl %r9, %r10</span><br><span class="line">jg   8675309</span><br></pre></td></tr></table></figure>
<p>等同于 <code>if %r10 &gt; %r9, jump to 8675309</code></p>
<p>各种不同的跳转：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>指令</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>jmp</td>
<td>Always jump</td>
<td>ja</td>
<td>Jump if above(unsigned &gt;)</td>
</tr>
<tr>
<td>je/jz</td>
<td>Jump if eq / zero</td>
<td>jae</td>
<td>Jump if above / equal</td>
</tr>
<tr>
<td>jne/jnz</td>
<td>Jump if !eq / !zero</td>
<td>jb</td>
<td>Jump if below(unsigned &lt;)</td>
</tr>
<tr>
<td>jg</td>
<td>Jump if greater</td>
<td>jbe</td>
<td>Jump if below / equal</td>
</tr>
<tr>
<td>jge</td>
<td>Jump if greater / eq</td>
<td>js</td>
<td>Jump if sign bits is 1(neg)</td>
</tr>
<tr>
<td>jl</td>
<td>Jump if less</td>
<td>jns</td>
<td>Jump if sign bit is 0 (pos)</td>
</tr>
<tr>
<td>jle</td>
<td>Jump if less / eq</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>举几个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp $0x15213, %r12</span><br><span class="line">jge deadbeef</span><br></pre></td></tr></table></figure>
<p>若 <code>%r12 &gt;= 0x15213</code>，则跳转到 <code>0xdeadeef</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp %rax, %rdi</span><br><span class="line">jae 15213b</span><br></pre></td></tr></table></figure>
<p>如果 <code>%rdi</code> 的无符号值大于等于 <code>%rax</code>，则跳转到 <code>0x15213b</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test %r8, %r8</span><br><span class="line">jnz (%rsi)</span><br></pre></td></tr></table></figure>
<p>如果 <code>%r8 &amp; %r8</code> 不为零，那么跳转到 <code>%rsi</code> 存着的地址中。</p>
<p><code>x86-64</code>寄存器规则：    默认函数的第一个参数是<code>%rdi</code>    第二个参数<code>%rsi</code>    第三个参数<code>%rdx</code></p>
<h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 检查符号表</span><br><span class="line"><span class="meta">#</span> 然后可以寻找跟 bomb 有关的内容</span><br><span class="line">objdump -t bomb | less </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 反编译</span><br><span class="line"><span class="meta">#</span> 搜索 explode_bomb</span><br><span class="line">objdump -d bomb &gt; bomb.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示所有字符</span><br><span class="line">strings bomb | less</span><br></pre></td></tr></table></figure>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">help	# 获取帮助</span><br><span class="line"></span><br><span class="line">break explode_bomb	# 设置断点</span><br><span class="line">break phase_1</span><br><span class="line"></span><br><span class="line">run	# 开始运行</span><br><span class="line"></span><br><span class="line">disas # 反汇编</span><br><span class="line"></span><br><span class="line">info registers	# 查看寄存器内容</span><br><span class="line"></span><br><span class="line">print $rsp	# 打印指定寄存器</span><br><span class="line"></span><br><span class="line">stepi	# （单步跟踪进入）执行一行代码，如果函数调用，则进入该函数 可以使用s简化</span><br><span class="line"></span><br><span class="line">n	# （单步跟踪） 执行一行代码，如果函数调用，则一并执行</span><br><span class="line"></span><br><span class="line">x/4wd $rsp	# 检查寄存器或某个地址，查看内存地址里面的内容（常用）</span><br></pre></td></tr></table></figure>
<p>用 <code>ctl+c</code> 可以退出，每次进入都要设置断点（保险起见），炸弹会用 <code>sscanf</code> 来读取字符串，了解清楚到底需要输入什么。</p>
<h1 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:    sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:    mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br></pre></td></tr></table></figure>
<p>先 <code>gdb bomb</code>，然后设置断点 <code>break explode_bomb</code> 和 <code>break phase_1</code></p>
<p>这段代码还是挺好理解的，保存Stack pointer,将<code>$0x402400</code>传给<code>%esi</code>,调用位于<code>0x401338</code>的<code>strings_not_equal</code>函数，比较<code>%eax</code>是否为0，不为零则调用<code>explode_bomb</code>函数，为零则返回设置断点 <code>phase_1</code>和<code>explode_bomb</code>，输入命令<code>r</code>运行会在断点处停下，此时随便输入一个字符串用于测试<code>“abcd”</code>，然后<code>disas</code>查看反汇编代码：=&gt;箭号为当前运行的位置</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/3gL82EBKel.png?imageslim" alt="mark"></p>
<p>查看寄存器内容 <code>info register</code>，<code>eax</code>就是<code>rax</code>的低位用<code>print $eax</code>    打印出来，是一个地址用<code>x/s $eax</code>，查看出地址里的内容，发现是<strong>输入字符串</strong></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/0GGK67dFj6.png?imageslim" alt="mark"></p>
<p>用<code>stepi</code> 逐步执行，执行完 <code>mov</code> 之后，把地址中的内容传到<code>%esi</code>中，用<code>print</code>查看！得到字符串，这就是第一关的答案。退出后新建一个文本 <code>touch sol.txt</code>，方便之后输入</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/IKC3CkCC4G.png?imageslim" alt="mark"></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/KeE6jHk5me.png?imageslim" alt="mark"></p>
<h1 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h1><p>这次我们有了第一关的答案，进入gdb后设置好断点，和命令参数。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/0GehKbDKJ2.png?imageslim" alt="mark"></p>
<p>试运行，在<code>phase_1</code>停住，然后<code>continue</code>，答案正确，触发 <code>phase_2</code>的断点，这次输入<code>abc</code></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/kkeii7BbCc.png?imageslim" alt="mark"></p>
<p>反汇编Phase2部分的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">=&gt; 0x0000000000400efc &lt;+0&gt;:    push   %rbp</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:    push   %rbx</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:    sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:    mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:    callq  0x40145c &lt;read_six_numbers&gt;   #读取6个数字</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)                  #第一个数字和1比较，不相等则爆炸</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;        #相等，跳转到&lt;52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax               #将(%rbx)前一个数字存到%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax                     #%eax数字加倍</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)                   #%eax和(%rbx)比较，=(%rbx)则跳过爆炸</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx                     #(%rbx)地址+4，下一个数字</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx                     #比较%rbp和%rbx，循环是否结束 </span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx                #指向第2个数字，%rbx保存第2个数字地址</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp               #0x18 = 0x0 + 4 bit * 6 个数字 </span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:    retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>根据Phase1,很敏感的会发现<code>movl $0x4025c3, %esi</code>这行。通过之前一样的方法，得到<code>0x4025c3</code>内存里的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s $esi</span><br><span class="line">0x4025c3:    &quot;%d %d %d %d %d %d</span><br></pre></td></tr></table></figure>
<p>再根据<code>bomb[0x40148a] &lt;+46&gt;: callq 0x400bf0 ; symbol stub for: __isoc99_sscanf</code>这句，猜一下，立马就能联想到<code>scanf(&quot;%d %d %d %d %d %d&quot;,a,b,c,d,e,f);</code>，也就是说，输入的格式已经确定了。</p>
<p>解读出循环中，从1开始，是一个等比数列，公比为2。<code>1 2 4 8 16 32</code></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180130/LKAlJKjHlG.png?imageslim" alt="mark"></p>
<h1 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">=&gt; 0x0000000000400f43 &lt;+0&gt;:    sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:    lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:    lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi                </span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt; # 调用函数sscanf</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax                     # 说明%eax&gt;1，即输入参数个数&gt;1，跳过爆炸</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)                # 说明第一个数0x8(%rsp)&lt;7，否则爆炸</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax                # 第一个数存到%eax</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)            # 跳转，起始地址0x402470+ rax*8（第一个数）内数据所指行数</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax                    # case0：   0xcf = 207</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax                   # case2:    0x2c3</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:    mov    $0x137,%eax                # 1    0x137</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:    cmp    0xc(%rsp),%eax             # 比较第2个数</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:    je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:    add    $0x18,%rsp                 # rsp+24</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:    retq</span><br></pre></td></tr></table></figure>
<p>查看地址内的内容，为输入格式，需要输入两个数，后面的    <code>cmp    $0x1,%eax</code>    表明输入参数大于1个，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:    "%d %d"</span><br></pre></td></tr></table></figure>
<p>看到多个分片语句，反应类似siwtch语句，所以第一个数字是用来进行跳转的</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180131/mC4gk85Ilj.png?imageslim" alt="mark"></p>
<p><code>p/x</code> 命令查看跳转表，可以看到</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180131/K459AL4e1D.png?imageslim" alt="mark"></p>
<p>用  <code>p/x</code>可以看跳转表的地址，但是没有<code>x/s</code>直观。用 <code>x/s</code> 命令可以查看跳转表，如<code>case0</code>，对应的就是<code>&lt;phase_3+57&gt;</code>，内容是<code>$0xcf,%eax</code> ，所以（0，207）就是一组输入，同理还可以得到其他的解</p>
<p>（0，207）    （1，311）    （2，707）    （3,256）    （4，389）    （5，206）    （6，682）    （7，327）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s *(0x402470)</span><br><span class="line">0x400f7c &lt;phase_3+57&gt;:    "\270", &lt;incomplete sequence \317&gt; //0:0xcf</span><br><span class="line">(gdb) x/s *(0x402470+8)</span><br><span class="line">0x400fb9 &lt;phase_3+118&gt;:    "\270\067\001"    //1:0x137    </span><br><span class="line">(gdb) x/s *(0x402470+16)</span><br><span class="line">0x400f83 &lt;phase_3+64&gt;:    "\270\303\002"    //2:0x2c3</span><br><span class="line">(gdb) x/s *(0x402470+24)</span><br><span class="line">0x400f8a &lt;phase_3+71&gt;:    "\270"            //3:0x100</span><br><span class="line">(gdb) x/s *(0x402470+32):</span><br><span class="line">0x400f91 &lt;phase_3+78&gt;:    "\270\205\001"    //4:0x185</span><br><span class="line">(gdb) x/s *(0x402470+40)</span><br><span class="line">0x400f98 &lt;phase_3+85&gt;:    "\270", &lt;incomplete sequence \316&gt;    //5:0xce</span><br><span class="line">(gdb) x/s *(0x402470+48)</span><br><span class="line">0x400f9f &lt;phase_3+92&gt;:    "\270\252\002"    //6:0x2aa</span><br><span class="line">(gdb) x/s *(0x402470+56)</span><br><span class="line">0x400fa6 &lt;phase_3+99&gt;:    "\270G\001"       //7:0x147</span><br><span class="line">(gdb) x/s *(0x402470+64)</span><br><span class="line">0x7564616d:    &lt;error: Cannot access memory at address 0x7564616d&gt;</span><br></pre></td></tr></table></figure>
<p>输入一组解，成功</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180131/DjBDldlFBk.png?imageslim" alt="mark"></p>
<h1 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:    sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:    lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:    lea    0x8(%rsp),%rdx</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi            //%d %d</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax                // 参数数量为2</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)           // 第一个参数&lt;=14</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx                //14</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi                //0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi           //a1</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;         //把a1,0,14分别作为参数传到func4</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax                //%eax！=0，爆炸，所以fun4调用后要使得%eax=0</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)           //第二个数据为0</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>跟上题一样，先看看可疑的<code>0x4025cf</code>中的内容</p>
<p>看到输入格式和上题一样都是两个整数。在执行 <code>callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</code>  指令后，返回值（参数数量）存储于<code>%eax</code>，然后判断<code>%eax</code>是否等于2，若不等于则爆炸。否则执行<code>cmpl   $0xe,0x8(%rsp)</code>  ，该指令将输入的第一个数和常数<code>0xe</code>进行比较，如果第一个数&gt;<code>0xe</code>，拆弹失败。否则跳转到<code>0x40103a</code>执行  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx                //14</span><br><span class="line">0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi                //0</span><br><span class="line">0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi           //a1</span><br></pre></td></tr></table></figure>
<p>这三条指令用来设置<code>func4</code>的参数，根据x86-64寄存器使用规范，第1,2,3,个参数分别存储在寄存器<code>%edi</code>，<code>%esi</code>，<code>%edx</code>中<br>在查看<code>func4</code>对应的代码之前，先观察执行<code>callq 400fce &lt;func4&gt;</code>指令之后<code>phase_4</code>的操作：<code>test %eax,%eax</code>指令检查<code>%eax</code>的值是否等于0，如果不等于0，则会引爆炸弹，否则执行指令<code>cmpl $0x0,0xc(%rsp)</code>，该指令将输入的第二个数与0做比较，如果相等，那么<code>phase_4</code>正常退出，拆弹成功。因此，<code>phase_4</code>的第二个输入值即为0。经过以上的分析，可以意识到<code>phase_4</code>的核心目标在于要让<code>func4</code>执行后，<code>%eax</code>的值等于0，这取决于输入的第一个数。接着需要分析<code>func4</code>执行的操作，其对应代码如下所示。</p>
<p>反汇编<code>func4</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:    48 83 ec 08              sub    $0x8,%rsp    //x = %edi    y = %esi   z = %edx</span><br><span class="line">  400fd2:    89 d0                    mov    %edx,%eax    //</span><br><span class="line">  400fd4:    29 f0                    sub    %esi,%eax    //t = z-y    t = %eax</span><br><span class="line">  400fd6:    89 c1                    mov    %eax,%ecx    //</span><br><span class="line">  400fd8:    c1 e9 1f                 shr    $0x1f,%ecx   //k=t&gt;&gt;31    t = %ecx</span><br><span class="line">  400fdb:    01 c8                    add    %ecx,%eax    //t = t+k</span><br><span class="line">  400fdd:    d1 f8                    sar    %eax         //t&gt;&gt;1</span><br><span class="line">  400fdf:    8d 0c 30                 lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  400fe2:    39 f9                    cmp    %edi,%ecx</span><br><span class="line">  400fe4:    7e 0c                    jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:    8d 51 ff                 lea    -0x1(%rcx),%edx</span><br><span class="line">  400fe9:    e8 e0 ff ff ff           callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:    01 c0                    add    %eax,%eax</span><br><span class="line">  400ff0:    eb 15                    jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:(+0x24)    b8 00 00 00 00    mov    $0x0,%eax    </span><br><span class="line">  400ff7:    39 f9                    cmp    %edi,%ecx</span><br><span class="line">  400ff9:    7d 0c                    jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:    8d 71 01                 lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:    e8 cb ff ff ff           callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:    8d 44 00 01              lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:(+0x39)    48 83 c4 08       add    $0x8,%rsp</span><br><span class="line">  40100b:    c3                       retq</span><br></pre></td></tr></table></figure>
<p>在分析<code>func4</code>之前，不要忘了传递到<code>func4</code>的三个参数分别存储于寄存器<code>%edi</code>、<code>%esi</code>和<code>%edx</code>，其值分别为x(输入的第一个数)、0和14。在<code>0x400fe9</code>处执行了指令<code>callq 400fce &lt;func4&gt;</code>，因此<code>func4</code>很可能是个递归函数，我们将<code>func4</code>翻译成等价的C代码，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = z - y;</span><br><span class="line">    <span class="keyword">int</span> k = t &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    t = (t + k) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    k = t + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= x) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            y = k + <span class="number">1</span>;</span><br><span class="line">            func4(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        z = k - <span class="number">1</span>;</span><br><span class="line">        func4(x, y, z);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func4</code>的目的是要让函数退出后<code>%eax</code>的值为0，而在<code>0x400ff2</code>处<code>mov $0x0,%eax</code>显示的将<code>%eax</code>的值设置为0，该指令对应于C代码中的t = 0。并且，<code>func4</code>执行递归的退出条件为k == x，其中x对应于输入的第一个数，而k则可以通过一系列计算得到，由于y = 0且z = 14，易知k = 7，因此输入的第一个数即为7。将字符串<code>7 0</code>作为<code>phase_4</code>的输入，拆弹成功，如下图所示。</p>
<h1 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:    push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:    sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:    mov    %rdi,%rbx            //把字符串起始地址保存在%rbx中</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:    mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax         //%eax清零</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax         //字符串输入长度=6</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx    //</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi        //字符串 flyers</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:    nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:    jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:    jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:    mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:    je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:    callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:    add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:    retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>根据x86-64寄存器使用规范，<code>%rdi</code>寄存器存储的是第一个参数的值，由于输入的是字符串，因此%rdi存储的应该是输入字符串的起始地址。<code>0x401067</code>处的指令<code>mov %rdi,%rbx</code>将字符串起始地址保存在<code>%rbx</code>中，即<code>%rbx</code>为基址寄存器。指令<code>xor %eax,%eax</code>的作用是将<code>%eax</code>清零，接着调用<code>string_length</code>函数获取输入字符串的长度，并将长度值（返回值）存储于<code>%eax</code>。指令<code>cmp $0x6,%eax</code>将<code>string_length</code>的返回值与常数6作比较，若不相等则会引爆炸弹，由此可以得知，<code>phase_5</code>的输入字符串长度应该等于6。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:    "flyers"</span><br></pre></td></tr></table></figure>
<p>待比较的字符串为<code>flyers</code>，且长度也为6。所以，接下来的关键任务是需要对循环操作进行分析，理解该循环操作对输入字符串做了哪些操作。提取循环操作的代码，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40108b:    0f b6 0c 03              movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:    88 0c 24                 mov    %cl,(%rsp)</span><br><span class="line">401092:    48 8b 14 24              mov    (%rsp),%rdx</span><br><span class="line">401096:    83 e2 0f                 and    $0xf,%edx</span><br><span class="line">401099:    0f b6 92 b0 24 40 00     movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:    88 54 04 10              mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:    48 83 c0 01              add    $0x1,%rax</span><br><span class="line">4010a8:    48 83 f8 06              cmp    $0x6,%rax</span><br><span class="line">4010ac:    75 dd                    jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure>
<p>由于<code>%rbx</code>存储的是输入字符串的起始地址，<code>%rax</code>初始化为0，其作用等价于下标，因此<code>movzbl (%rbx,%rax,1),%ecx</code>指令的作用是将字符串的第%rax个字符存储于<code>%ecx</code>，<code>movzbl</code>意味做了零扩展。接着，<code>mov %cl,(%rsp)</code>指令取<code>%ecx</code>的低8位，即一个字符的大小，通过内存间接存储至<code>%rdx</code>中。<code>and $0xf,%edx</code>指令将<code>%edx</code>的值与常数<code>0xf</code>进行位与，由指令<code>movzbl 0x4024b0(%rdx),%edx</code>可知，位与后的值将会作为偏移量，以<code>0x4024b0</code>为基址，将偏移后的值存储至%edx。最后，指令<code>mov %dl,0x10(%rsp,%rax,1)</code>以<code>%edx</code>低8位的值作为新的字符，对原有字符进行替换。综上，<code>phase_5</code>遍历输入字符串的每个字符，将字符的低4位作为偏移量，以<code>0x4024b0</code>为起始地址，将新地址对应的字符替换原有字符，最终得到<code>flyers</code>字符串。打印<code>0x4024b0</code>处的内容，如下图所示。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180131/mF6jd7j4e6.png?imageslim" alt="mark"></p>
<p>例如，如果要得到字符f，那么偏移量应为9，二进制表示为<code>1001</code>，通过查找ASCII表，可知字符i的ASCII编码为<code>01101001</code>，满足要求。（或者字符y（<code>01111001</code>）所以解不唯一）剩余5个字符采用同样的策略可以依次求得，最终，<code>phase_5</code>的输入字符串的一个解为<code>ionefg</code>。</p>
<h1 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase 6"></a>Phase 6</h1><p><code>phase_6</code>的代码很长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">=&gt; 0x00000000004010f4 &lt;+0&gt;:    push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:    push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:    push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:    push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:    push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:    sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14           # %r14存储数组起始地址</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d          # 将%r12d初始化为0</span><br><span class="line">#################### Section 1:确认数组中所有的元素小于等于6且不存在重复值 ###################</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp           # %r13和%rbp存储数组某个元素的地址，并不是第1个元素，意识到这点需要结合0x40114d处的指令</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax        # 将%eax的值减1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax        # 将%eax的值与常数5做比较</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d        # 如果%eax的值小于等于5，%r12d加1</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d        # 将%r12d与常数6做比较</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx        # %ebx起了数组下标的作用</span><br><span class="line"></span><br><span class="line"># 用于判断数组6个数是否存在重复值，若存在，引爆炸弹</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax        # 将数组下标存储至%rax</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax        # 将下一个数存储至%eax</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)            # 将第1个数与%eax的值(当前数)做比较</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;    # 若相等，引爆炸弹</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx                # 数组下标加1</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx                 # 判断数组下标是否越界(&lt;=5)</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13                # %r13存储数组下一个数的地址</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">####################################### Section 1 end ######################################</span><br><span class="line"></span><br><span class="line">################ Section 2：用7减去数组的每个元素，并将相减后的元素替换原有元素 #################</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi        # 0x18(%rsp)是数组的边界地址：0x18 = 24</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:    mov    %r14,%rax            # 将数组起始地址存储于%rax</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:    mov    $0x7,%ecx</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:    mov    %ecx,%edx            # %edx = 7</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:    sub    (%rax),%edx            # %edx = 7 - 数组元素</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:    mov    %edx,(%rax)            # 用相减后的元素(%edx)替换原有元素</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:    add    $0x4,%rax                # %rax存储数组下一个元素的地址</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:    cmp    %rsi,%rax                # 判断是否越界</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:    jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">####################################### Section 2 end ######################################</span><br><span class="line"></span><br><span class="line">########################## Section 3：根据输入数组重排结构体数组 ##############################</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:    mov    $0x0,%esi        # 将%esi初始化为0，作为数组下标</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:    jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:    mov    0x8(%rdx),%rdx        # 0x8(%rdx)为下一个元素的地址</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:    add    $0x1,%eax</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:    cmp    %ecx,%eax            # %ecx存储了数组当前值(第%esi个元素)</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:    jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:    jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:    mov    $0x6032d0,%edx        # %edx存储结构体数组第1个元素的地址</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:    mov    %rdx,0x20(%rsp,%rsi,2)    # %rsi的初始值为0；该指令的作用是将结构体数组的第%ecx个元素的地址存储在内存的某个位置(以%rsp + 0x20为基地址，%rsi为偏移量)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:    add    $0x4,%rsi        # 增加偏移量</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:    cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:    je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:    mov    (%rsp,%rsi,1),%ecx    # %ecx存储数组第%esi个元素</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:    cmp    $0x1,%ecx        # 将数组第%esi个元素与常数1做比较</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:    jle    0x401183 &lt;phase_6+143&gt;    # 实际上不会小于1，如果数组的第1个元素等于1，那么跳转至0x401183处</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:    mov    $0x1,%eax</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:    mov    $0x6032d0,%edx        # %edx存储结构体数组第1个元素的地址</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:    jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">####################################### Section 3 end ######################################</span><br><span class="line"></span><br><span class="line">######################### Section 4：修改结构体数组元素的next域值 #############################</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:    mov    0x20(%rsp),%rbx    # %rbx存储地址数组的第1个元素的值</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:    lea    0x28(%rsp),%rax    # %rax存储地址数组的第2个元素的地址</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:    lea    0x50(%rsp),%rsi</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:    mov    %rbx,%rcx        # %rcx存储地址数组的第1个元素的值</span><br><span class="line"># 下面用i和i+1来表示元素位置</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:    mov    (%rax),%rdx    # %rdx存储地址数组的第i+1个元素的值</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:    mov    %rdx,0x8(%rcx)    # 把第i+1和元素的值存储于第i个结构体元素的next域中，next域的地址为0x8(%rcx)的值</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:    add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:    cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:    je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:    mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:    jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">####################################### Section 4 end ######################################</span><br><span class="line"></span><br><span class="line">######################### Section 5：判断结构体数组是否是递减序列 #############################</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:    movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:    mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:    mov    0x8(%rbx),%rax</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:    mov    (%rax),%eax</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:    cmp    %eax,(%rbx)</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:    jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:    mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:    sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:    jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">####################################### Section 5 end ######################################</span><br><span class="line"></span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:    add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:    pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:    pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:    pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:    pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:    retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>分析清楚phase_6非常需要耐心，我将<code>phase_6</code>划分为5个Section，每个Section完成特定的功能，详细的注释直接附到了相关代码。前两个Section不难理解：<code>Section 1</code>确保输入数组的值的范围在<code>1 ~ 6</code>且不存在重复值；<code>Section 2</code>用7减去输入数组的每个元素，相当于求补。<code>Section</code> 3中出现了一个常数地址，使用gdb将该地址存储的内容打印出来，如下图所示。</p>
<p>可以意识到这其实是一个链表数据结构，链表的节点由3部分组成：<code>value 1</code>、<code>value 2</code>和一个地址值(<code>next</code>域，指向下一个节点)。<code>Section 3</code>根据我们输入的数组，按照数组元素的值将对应结构体数组中的元素的首地址存储到内存的某个位置(<code>mov %rdx,0x20(%rsp,%rsi,2)</code>)。例如，假设输入数组为<code>[3, 4, 5, 6, 1, 2]</code>，那么<code>Section 3</code>首先会将结构体数组的第3个元素的地址存储到<code>0x20(%rsp,%rsi,2)</code>处，接着将结构体数组的第4个元素……依次类推。<code>Section 4</code>根据<code>Section 3</code>构建的地址数组，修改结构体数组的next域的值，实现单链表的排序操作。<code>Section 5</code>进行验证，要求单链表递减排序，若满足要求，那么拆弹成功。</p>
<p>综上，根据已有的结构体数组以及<code>phase_6</code>的操作，若要实现单链表的递减排序，应将第3个节点放在第1位，将第4个节点放在第2位……最终得到序列：<code>[3, 4, 5, 6, 1, 2]</code>。不要忘记<code>Section 2</code>中的求补操作，所以<code>phase_6</code>的输入序列应该为<code>[4, 3, 2, 1, 6, 5]</code>。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180131/1bGi2lDK4c.png?imageslim" alt="mark"></p>
<p><strong>reference</strong></p>
<p>1.<a href="http://wdxtub.com/2016/04/16/thick-csapp-lab-2/" target="_blank" rel="noopener">http://wdxtub.com/2016/04/16/thick-csapp-lab-2/</a></p>
]]></content>
      
        <categories>
            
            <category> 体系结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Soft-RoCE环境搭建]]></title>
      <url>/2018/01/27/Soft-RoCE-setup/</url>
      <content type="html"><![CDATA[<p>Soft-RoCE是RoCE协议的软件栈版本，可以在普通网卡上搭建RDMA环境</p>
<p>先确保安装以下软件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install libibverbs1 libibcm1libibcm-dev ibverbs-utils libibverbs-dev </span><br><span class="line">sudo apt-get install libibverbs1librdmacm-dev librdmacm1 rdmacm-utils </span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line">sudo apt-get install libswitch-perl</span><br></pre></td></tr></table></figure>
<h1 id="Install-Kernel"><a href="#Install-Kernel" class="headerlink" title="Install Kernel"></a>Install Kernel</h1><p>Clone kernel </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/SoftRoCE/rxe-dev.git</span><br></pre></td></tr></table></figure>
<p>切换到 ‘rxe_submission_v18’ 分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout rxe_submission_v18</span><br></pre></td></tr></table></figure>
<p>进入到rxe-dev 目录 <code>cd rxe-dev</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /boot/config-$(uname –r) .config</span><br></pre></td></tr></table></figure>
<p>切换到root用户权限，运行<code>make menuconfig</code> ，出现选择界面。（在使用 <code>make menuconfig</code> 之前需要安装ncurse-devel</p>
<p>输入”/“ ，然后输入<code>RDMA_RXE</code>，按下 enter，会查找有关<code>RDMA_RXE</code> 的选择项. 输入数字 1，就会选择到<code>RDMA_RXE</code> 的设置，输入”M” ，选中 RDMA 的配置. </p>
<p>然后 <code>vi.config</code> 来确认<code>CONFIG_RDMA_RXE</code> 为 m ，<code>CONFIG_INFINIBAND_ADDR_TRANS</code>和<code>CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS</code> 为 y</p>
<p>建议在Generalsetup –&gt;Local version中填写一个名称，便于之后编译出的内核与其他内核区别开。</p>
<p>##编译内核</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make –j 32</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br><span class="line">make headers_install INSTALL_HDR_PATH=/usr</span><br></pre></td></tr></table></figure>
<p>上述步骤如果遇到permission denied，命令前加上sudo 再执行。且上述命令均应在源码目录即 <code>/rxe-dev</code> 下执行</p>
<p>确认新的内核是否在grub引导中，可以查看 <code>/boot/grub/grub.conf</code></p>
<p>用新内核启动后查看内核版本号和<code>rdma_rxe</code>模块</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kevin@ubuntu:~$ uname -r</span><br><span class="line">4.7.0-rc3kevin+</span><br><span class="line">kevin@ubuntu:~$ modinfo rdma_rxe</span><br><span class="line">filename:      /lib/modules/4.7.0-rc3kevin+/kernel/drivers/infiniband/hw/rxe/rdma_rxe.ko</span><br><span class="line">version:        0.2</span><br><span class="line">license:        DualBSD/GPL</span><br><span class="line">description:    SoftRDMA transport</span><br><span class="line">author:         BobPearson, Frank Zago, John Groves, Kamal Heib</span><br><span class="line">srcversion:    85F0433D44A5DAF81FBFE5C</span><br><span class="line">depends:       ib_core,ip6_udp_tunnel,udp_tunnel</span><br><span class="line">intree:         Y</span><br><span class="line">vermagic:      4.7.0-rc3kevin+ SMP mod_unload modversions </span><br><span class="line">parm:           add:Create RXE device over network interface</span><br><span class="line">parm:          remove:Remove RXE device over network interface</span><br></pre></td></tr></table></figure>
<h1 id="Install-user-space-library-librxe"><a href="#Install-user-space-library-librxe" class="headerlink" title="Install user space library (librxe)"></a>Install user space library (librxe)</h1><p>安装以下的包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">libswitch-perl</span><br><span class="line">libibverbs</span><br><span class="line">libibverbs-devel</span><br><span class="line">libibverbs-utils</span><br><span class="line">librdmacm</span><br><span class="line">librdmacm-devel</span><br><span class="line">librdmacm-utils</span><br></pre></td></tr></table></figure>
<p>编译安装 install userspace library <code>librxe</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/SoftRoCE/librxe-dev.git</span><br><span class="line">cd librxe-dev</span><br><span class="line">./configure --libdir=/usr/lib64/ --prefix=</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>（<code>./configure --libdir=/usr/lib64/ --prefix=</code> 中如果路径只有<code>/lib</code> 就用<code>/lib</code>）</p>
<h1 id="Configure-Soft-RoCE-RXE"><a href="#Configure-Soft-RoCE-RXE" class="headerlink" title="Configure Soft-RoCE (RXE)"></a>Configure Soft-RoCE (RXE)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kevin@ubuntu:~$ rxe_cfg status</span><br><span class="line">rxe modules not loaded</span><br><span class="line">  Name   Link  Driver  Speed  NMTU  IPv4_addr        RDEV  RMTU  </span><br><span class="line">  ens33  yes   e1000          1500  192.168.188.132</span><br></pre></td></tr></table></figure>
<p>Load <code>ib_rxe</code> kernel module, using the <code>rxe_cfg</code> script included in the librxe RPM:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kevin@ubuntu:~$ sudo rxe_cfg start</span><br><span class="line">sh: echo: I/O error</span><br><span class="line">  Name   Link  Driver  Speed  NMTU  IPv4_addr        RDEV  RMTU          </span><br><span class="line">  ens33  yes   e1000          1500  192.168.188.132  rxe0  1024</span><br></pre></td></tr></table></figure>
<p>To verify RXE kernel module is loaded, run:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kevin@ubuntu:~$ lsmod |grep rdma_rxe</span><br><span class="line">rdma_rxe              102400  0</span><br><span class="line">ip6_udp_tunnel         16384  1 rdma_rxe</span><br><span class="line">udp_tunnel             16384  1 rdma_rxe</span><br><span class="line">ib_core               208896  6 rdma_cm,ib_cm,iw_cm,ib_uverbs,rdma_rxe,rdma_ucm</span><br></pre></td></tr></table></figure>
<p>Create RXE device over network interface (e.g. <code>ens33</code>):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rxe_cfg add ens33</span><br></pre></td></tr></table></figure>
<p>Check the status of <code>rxe_cfg</code>, make sure that <code>rxe0</code> was added under RDEV (rxe device).It is also possible to check the <code>ibv_devices</code> command.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kevin@ubuntu:~$ rxe_cfg </span><br><span class="line">  Name   Link  Driver  Speed  NMTU  IPv4_addr        RDEV  RMTU          </span><br><span class="line">  ens33  yes   e1000          1500  192.168.188.132  rxe0  1024  (3)  </span><br><span class="line">kevin@ubuntu:~$ ibv_devices</span><br><span class="line">    device          	   node GUID</span><br><span class="line">    ------          	----------------</span><br><span class="line">    rxe0            	020c29fffebd5e22</span><br></pre></td></tr></table></figure>
<p>Test connectivity.</p>
<ul>
<li>On the server:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibv_rc_pingpong -d rxe0 -g 0</span><br></pre></td></tr></table></figure>
<ul>
<li>On the client:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibv_rc_pingpong -d rxe0 -g 0 &lt;server_management_ip&gt;</span><br></pre></td></tr></table></figure>
<p>e.g Client:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kevin@ubuntu:~$ ibv_rc_pingpong -g 0 -d rxe0 -i 1 192.168.188.129</span><br><span class="line">  local address:  LID 0x0000, QPN 0x000011, PSN 0x2cd726, GID fe80::20c:29ff:febd:5e22</span><br><span class="line">  remote address: LID 0x0000, QPN 0x000011, PSN 0x767a62, GID fe80::20c:29ff:fe44:4345</span><br></pre></td></tr></table></figure>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="rping"><a href="#rping" class="headerlink" title="rping"></a>rping</h2><p>server</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180127/80KJ950a9B.png?imageslim" alt="mark"></p>
<p>client</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180127/55c5AB4idD.png?imageslim" alt="mark"></p>
<h2 id="perftest"><a href="#perftest" class="headerlink" title="perftest"></a>perftest</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install perftest</span><br></pre></td></tr></table></figure>
<p>测试时需切换到root</p>
<p>Sever:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ib_send_bw –a</span><br></pre></td></tr></table></figure>
<p>Client:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ib_send_bw 192.168.46.132 –a</span><br></pre></td></tr></table></figure>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180127/3BjC7c2fgk.png?imageslim" alt="mark"></p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180127/kI3KI62ikc.png?imageslim" alt="mark"></p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul>
<li>用sudoapt-get update时出现“ E: 无法获得锁/var/lib/apt/lists/lock”错误</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/lock</span><br></pre></td></tr></table></figure>
<ul>
<li>如果出现缺少ssl的错误，就安装ssl</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure>
<ul>
<li>ERROR: make <em>*</em>No rule to make target”menuconfig”.stop. </li>
</ul>
<p>原因是没有在内核源码目录下进行。例如，要编译或升级的内核解压后的目录为/usr/src/<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>-2.4.24,一定要进入到该目录后使用makemenuconfig命令，这样就不会提示上面的错误了。(在本文中就是在rxe-dev目录下编译)</p>
<ul>
<li><p>克隆的虚拟机中找不到eth0。因为网卡是克隆的，所以在测试连通性的时候不能用。要手动修改网卡信息。</p>
</li>
<li><p>在试验 rdma 的时候，记得关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- sudo iptables -F </span><br><span class="line">chkconfig iptables off  #开机不启动</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RDMA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP实验1:DataLab]]></title>
      <url>/2018/01/27/CSAPP-lab1-datalab/</url>
      <content type="html"><![CDATA[<h1 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h1><p>​    Data LAB 目的是熟悉位运算</p>
<p>要求：    </p>
<ul>
<li>只修改<code>bit.c</code>    </li>
<li>使用 <code>btest</code> 进行验证    </li>
<li>每次修改完之后都要<code>make clean</code>再<code>make</code>    </li>
<li>整数部分：要求只能使用规定的操作符并且不能使用循环、条件语句    </li>
<li>在函数开始时声明所有变量，只能使用局部变量    </li>
<li>不能使用其他函数/宏/int外的类型/类型转换    </li>
<li><code>int</code>都是默认二进制补码编码 2’s complement，32bit    </li>
<li>要考虑数据溢出的情况，比如相减，同号才能相减，否则结果出错</li>
</ul>
<a id="more"></a>
<p>Tips：    </p>
<ul>
<li><code># ./btest -f [函数名]</code>，检验某个函数 <code>./btest</code> 检验所有函数    </li>
<li><p>关注<code>int</code>型的表示范围 -2^31~2^31-1以及一些特殊的数字的补码编码  <code>-2^31：0x80 00 00 00</code>   <code>-1：0xff ff ff ff</code>    </p>
</li>
<li><p>一个数的相反数是 <code>~x+1</code>   </p>
</li>
<li>在float的实验中要对该数是不是规格化分情况    </li>
<li>逻辑右移不带符号，<code>&gt;&gt;</code>是算术右移，带符号    </li>
<li>0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00</li>
</ul>
<p>个人认为最难的是ilog2    </p>
<h1 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h1><p>Github地址：<a href="https://github.com/zhengjingwei/CSAPP-LAB/tree/master/lab1-datalab" target="_blank" rel="noopener">Data Lab</a></p>
<ul>
<li>bit.c：实现缓存模拟器的文件<ul>
<li>Examples：表示用例‘</li>
<li>Legal ops：允许的操作符</li>
<li>Max ops：最多操作数</li>
<li>Rating：难度系数</li>
</ul>
</li>
</ul>
<p>在每一次更新之后，首先用<code>make</code>生成文件，之后用相应的<code>test</code>跑分即可</p>
<h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><h2 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val = ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>) ; <span class="comment">// 0x7f ff ff ff </span></span><br><span class="line">  val = ((val &gt;&gt; n) &lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span>  val &amp; (x&gt;&gt;n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑右移：需要去掉负数带来的符号位。产生一个数，前n-1位0，之后全为1，和算数右移后的数进行按位与操作，使左边n-1位为0。</p>
<h2 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = ((<span class="number">0x01</span>&lt;&lt;<span class="number">8</span>|<span class="number">0x01</span>)&lt;&lt;<span class="number">8</span>|<span class="number">0x01</span>)&lt;&lt;<span class="number">8</span>|<span class="number">0x01</span> ;</span><br><span class="line">  <span class="keyword">int</span> val = mask &amp; x;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">3</span>;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">5</span>;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">6</span>;</span><br><span class="line">  val += mask &amp; x&gt;&gt;<span class="number">7</span>;</span><br><span class="line">  val += val&gt;&gt;<span class="number">16</span>;</span><br><span class="line">  val += val&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  <span class="keyword">return</span> val&amp;<span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：计算32进制数x中1的个数</p>
<p>思路：如果依次检测，ops必然超过。可以每次检测4位，然后再进行累加。先初始化mask=0x01010101，用来检测x&gt;&gt;i的0,8,16,24位是否为1然后x顺序移动重复上述检测，一共8次。相当于将一个32位分成4段同时进行，结果存储在分别四段的8位中。整合：将前16位加到后16位上，然后把8~16位加到低8位。取最低8位为最后结果。</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180127/4mI0d8IE6g.png?imageslim" alt="mark"></p>
<h2 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((~((~x+<span class="number">1</span>)^x))&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：输出！x。即x!=0, !x =0 ; x=0, !x =1</p>
<p>思路：根据0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00,所以不能用^）或运算之后取反，再取符号位。</p>
<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x01</span>&lt;&lt;<span class="number">31</span>; <span class="comment">// 0x80 00 00 00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：32位二进制补码的最小整数，也就是0x80 00 00 00。（如8位整数，补码编码最小数就是-128，和128是相等的，也就是1000 0000(2)）</p>
<h2 id="fitBits"><a href="#fitBits" class="headerlink" title="fitBits"></a>fitBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shiftBits = <span class="number">32</span> + (~n+<span class="number">1</span>); <span class="comment">// 32-n</span></span><br><span class="line">  <span class="keyword">return</span> !(x^((x&lt;&lt;shiftBits)&gt;&gt;shiftBits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：判断x是否可以用n位补码来表示。考虑的是数字是否在范围内能表示，也就是移动后符号位是否会变化</p>
<p>先左移32-n位，再右移32-n位。即保留最后n位。再和x进行异或，若两者相同，表示x可以被表示成一个n为整数，！0为1。eg.以5为例，5 =000….. 101（2），左移27位后再右移27位得到的是 1111….101，与原来不同。而-4 = 111…100（2），移动后得到的还是111…100，同一个数。</p>
<h2 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sgn = x &gt;&gt; <span class="number">31</span>; <span class="comment">// 0xffffffff or 0x0</span></span><br><span class="line">  <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; n )+ (~<span class="number">0</span>) ; <span class="comment">//2^n -1</span></span><br><span class="line">  <span class="keyword">int</span> bias = sgn &amp; mask; <span class="comment">//if x &gt;= 0 bias = 0</span></span><br><span class="line">  <span class="keyword">return</span> (x+bias) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：求x /(2^n)，向0取整。</p>
<p>若是非负数，可以直接右移。如果是负数需要分情况。eg. -33 &gt;&gt;4 =-3 。因为负数右移的结果是，如果除以2次幂出现小数，取小于它的最大整数。所以除非是-4 -8这类后几位全为0的负数，其他的都得+1。</p>
<p>构造一个偏置量，因为要右移n位，如果是负数的话，加上2^n-1（后几位全0的话不变，其余的数进1）后再移位。</p>
<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取反加一</p>
<h2 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//int nsgn = ((~x)&gt;&gt;31)&amp;0x01; //nsgn = !sgn</span></span><br><span class="line">  <span class="keyword">int</span> nsgn = !(x&gt;&gt;<span class="number">31</span>);</span><br><span class="line">  <span class="keyword">return</span> nsgn ^ !x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断正数。x&gt;0，返回1。其余返回0。主要是处理0的情况。取符号位，再取反，再和 !x 进行异或。</p>
<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sgnx = (x&gt;&gt;<span class="number">31</span>) &amp;<span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">int</span> sgny = (y&gt;&gt;<span class="number">31</span>) &amp;<span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">int</span> sgn = (sgnx ^ sgny) &amp; sgnx; <span class="comment">// x&lt;0 ,y&gt;=0</span></span><br><span class="line">  <span class="keyword">int</span> val = y + (~x +<span class="number">1</span>); <span class="comment">// y-x</span></span><br><span class="line">  val = ((val &gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x01</span>) | (sgnx^sgny); <span class="comment">// x-y&lt;0 &amp;&amp; sgnx=sgny</span></span><br><span class="line">  <span class="keyword">return</span> (sgn|!val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：判断x&lt;=y是否成立可以转化为判断x-y的正负。</p>
<p>注意：当x和y同号时，x-y不会发生溢出，判断符号位即可，当x和y异号时，x-y可能发生溢出，其结果不一定和x的符号一致。所以分解为三部分：x和y异号 / 同号 / 相等。</p>
<h2 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bitNum =<span class="number">0</span>;</span><br><span class="line">  bitNum  = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+<span class="number">8</span>)))&lt;&lt;<span class="number">3</span>);</span><br><span class="line">  bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+<span class="number">4</span>)))&lt;&lt;<span class="number">2</span>);</span><br><span class="line">  bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+<span class="number">2</span>)))&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  bitNum = bitNum + (!!(x&gt;&gt;(bitNum+<span class="number">1</span>)));</span><br><span class="line">  <span class="keyword">return</span> bitNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：由多少位二进制可以表示。log（2）1 = 0 </p>
<p>二分法，先右移16位后，若大于0即得到（10000）2 =16，否则得到0，判断最高位是否为0（前16位部分是否为0），若不为0，则包含2^16，同理。</p>
<p>其实ilog2的结果不会超过31，可以想到用5位二进制来表示，也就是分成这5步.</p>
<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><p>浮点型数表示：</p>
<p><img src="http://oq8u5pr4b.bkt.clouddn.com/blog/180127/hhBaCcJBdb.png?imageslim" alt="mark"></p>
<h2 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp =<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">  ret = uf ^ <span class="number">0x80000000</span>; <span class="comment">// sign reverse</span></span><br><span class="line">  tmp = uf &amp; <span class="number">0x7fffffff</span>; <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span>(tmp &gt; <span class="number">0x7f800000</span>)   <span class="comment">// NaN</span></span><br><span class="line">    ret = uf;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：计算-x （unsigned表示的浮点型），可以使用条件语句和其他运算符，当x=NaN时，返回其NaN本身；x！=NaN时，返回-x。</p>
<p>非NaN的数，对最高位异或，将符号位取反。判断NaN，返回本身。</p>
<h2 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">int</span> frac_mask = <span class="number">0x7fffff</span>; <span class="comment">// (1&lt;&lt;23) -1</span></span><br><span class="line">  <span class="keyword">int</span> frac=<span class="number">0</span>,<span class="built_in">exp</span>=<span class="number">0</span>,delta=<span class="number">0</span>; </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">if</span>(!x)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0x80000000</span>)<span class="comment">// -2^31</span></span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">158</span>;          <span class="comment">// 158 = 127 +31</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sign)  x=-x;     <span class="comment">// abs(x)</span></span><br><span class="line">    i=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(x&gt;&gt;i))</span><br><span class="line">      i--;</span><br><span class="line">    <span class="built_in">exp</span> = i+<span class="number">127</span>;        <span class="comment">// exp = Bias + E</span></span><br><span class="line">    x= x&lt;&lt;(<span class="number">31</span>-i);       <span class="comment">// clean all those zeroes of high bits</span></span><br><span class="line">    frac = (x&gt;&gt;<span class="number">8</span>) &amp; frac_mask;<span class="comment">//right shift 8 bits to become the fraction,sign and exp have 8 bits total</span></span><br><span class="line">    x = x &amp; <span class="number">0xff</span>;</span><br><span class="line">    delta = x&gt;<span class="number">0x80</span>||((x==<span class="number">0x80</span> )&amp;&amp; (frac&amp;<span class="number">0x01</span>)); <span class="comment">//if lowest 8 bits of x is larger than a half,or is 1.5,round up 1</span></span><br><span class="line">    frac += delta;</span><br><span class="line">    <span class="keyword">if</span>(frac&gt;&gt;<span class="number">23</span>)&#123; <span class="comment">//if after rounding fraction is larger than 23bits</span></span><br><span class="line">      <span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">      frac = frac &amp; frac_mask;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (sign&lt;&lt;<span class="number">31</span>)|(<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：int转float</p>
<p>分别求出符号位sign，指数部分exp和小数部分frac。原来整数称x</p>
<ul>
<li>首先把特殊情况的0x0 和 0x80 00 00 00（-2^31）挑出来，因为不能用移位的办法求exp和frac。</li>
<li>求绝对值，找出x的最高位（最左边的1），此时要从第30位找起，因为第31位是符号位。找到之后该位数就是$ v = (-1)^SM(2)^E $中的E，可以求得exp=E+127 </li>
<li>求frac：取x最高位后的23位。步骤：先去掉x高位的0，然后右移8位将最高位后的23位移到低23位。</li>
<li>求精度：int转float型会丢失最后8位的精度（31-23=8），所以要判断x的最后八位需不需要进位，如果最后8位超过128（0x80）或者最后8位=128且frac最后一位=1，则进位。</li>
<li>进位后：需要检查frac有没有再进位，frac&gt;&gt;23进行判断，如果frac进位了，那么exp+1，frac再取最后23位。把sign    exp    frac组合成结果</li>
</ul>
<h2 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = uf&gt;&gt;<span class="number">31</span>&amp;&amp;<span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = uf&gt;&gt;<span class="number">23</span> &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>!=<span class="number">0xff</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">exp</span>)  frac=frac&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0xff</span>)</span><br><span class="line">        frac=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> sign&lt;&lt;<span class="number">31</span>|<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>|frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：求2*uf，uf是一个用unsigned表示的float，当遇到NaN时返回该NaN</p>
<p>检查是否NaN：exp==0xff</p>
<p>然后分两种情况：</p>
<p>1、exp=全0的，frac&lt;&lt;1,exp不变</p>
<p>2、exp≠全0的，exp++，检查exp==0xff，若exp==0xff，此时该数超范围（无穷大），frac=0</p>
<p>取符号位：uf&gt;&gt;31&amp;0x01</p>
<p>取frac：uf&amp;((1&lt;&lt;23)-1)</p>
<p>取exp：(uf&gt;&gt;23)&amp;0xff</p>
]]></content>
      
        <categories>
            
            <category> 体系结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux添加新协议]]></title>
      <url>/2018/01/26/linux-add-new-protocol/</url>
      <content type="html"><![CDATA[<h1 id="添加协议号"><a href="#添加协议号" class="headerlink" title="添加协议号"></a>添加协议号</h1><p>​    <code>\include\linux\socket.h</code>中定义了地址协议族，修改AF_MAX+1（地址协议族数），并加上自己的协议族</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_KCM		41	<span class="comment">/* Kernel Connection Multiplexor*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_QIPCRTR	42	<span class="comment">/* Qualcomm IPC Router          */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_AS       43  <span class="comment">/* 新协议*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_MAX		44	<span class="comment">/* For now.. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_AS       AF_AS  <span class="comment">/* 新协议*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Protocol families, same as address families. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_UNSPEC	AF_UNSPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_UNIX		AF_UNIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_LOCAL	AF_LOCAL</span></span><br></pre></td></tr></table></figure>
<p>​    通过添加协议号的方式，需要重新编译内核</p>
<a id="more"></a>
<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>下载linux源码，进入源码根目录编译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">make menuconfig</span><br><span class="line">make -j <span class="number">32</span></span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br><span class="line">make headers_install INSTALL_HDR_PATH=/usr</span><br></pre></td></tr></table></figure>
<p>然后重启，查看新内核版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zjw@ubuntu:~$ uname -r</span><br><span class="line">4.10.0</span><br></pre></td></tr></table></figure>
<h1 id="添加新协议模块"><a href="#添加新协议模块" class="headerlink" title="添加新协议模块"></a>添加新协议模块</h1><p>添加一个空协议 <code>aproto.c</code>，大部分函数是空函数。根据<code>/net/rds.c</code>修改的，将原来<code>rds</code>改成<code>as</code>，<code>AF_INET</code>改成<code>AF_AS</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_release</span><span class="params">(struct socket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_bind</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_getname</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> *uaddr_len, <span class="keyword">int</span> peer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> payload_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_recvmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> size, <span class="keyword">int</span> msg_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">as_poll</span><span class="params">(struct file *file, struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">			     poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_ioctl</span><span class="params">(struct socket *sock, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> -ENOIOCTLCMD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret =<span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_getsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">char</span> __user *optval, <span class="keyword">int</span> __user *optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret =<span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">as_proto</span> = &#123;</span></span><br><span class="line">	.name	  = <span class="string">"A_PROTO"</span>,</span><br><span class="line">	.owner	  = THIS_MODULE,</span><br><span class="line">	.obj_size = <span class="keyword">sizeof</span>(struct sock),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">as_proto_ops</span> = &#123;</span></span><br><span class="line">	.family =	AF_AS, <span class="comment">// 自定义协议族</span></span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.release =	as_release,</span><br><span class="line">	.bind =		as_bind,</span><br><span class="line">	.connect =	as_connect,</span><br><span class="line">	.socketpair =	sock_no_socketpair,</span><br><span class="line">	.accept =	sock_no_accept,</span><br><span class="line">	.getname =	as_getname,</span><br><span class="line">	.poll =		as_poll,</span><br><span class="line">	.ioctl =	as_ioctl,</span><br><span class="line">	.listen =	sock_no_listen,</span><br><span class="line">	.shutdown =	sock_no_shutdown,</span><br><span class="line">	.setsockopt =	as_setsockopt,</span><br><span class="line">	.getsockopt =	as_getsockopt,</span><br><span class="line">	.sendmsg =	as_sendmsg, </span><br><span class="line">	.recvmsg =	as_recvmsg, </span><br><span class="line">	.mmap =		sock_no_mmap,</span><br><span class="line">	.sendpage =	sock_no_sendpage,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __as_create(struct socket *sock, struct sock *sk, <span class="keyword">int</span> protocol)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">as_sock</span> *<span class="title">as</span>;</span></span><br><span class="line"></span><br><span class="line">	sock_init_data(sock, sk);</span><br><span class="line">	sock-&gt;ops		= &amp;as_proto_ops;</span><br><span class="line">	sk-&gt;sk_protocol		= protocol;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">as_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">int</span> kern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type != SOCK_SEQPACKET || protocol)</span><br><span class="line">		<span class="keyword">return</span> -ESOCKTNOSUPPORT;</span><br><span class="line"></span><br><span class="line">	sk = sk_alloc(net, AF_AS, GFP_ATOMIC, &amp;as_proto, kern);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __as_create(sock, sk, protocol);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">as_family_ops</span> = &#123;</span></span><br><span class="line">	.family =	AF_AS,</span><br><span class="line">	.create =	as_create,</span><br><span class="line">	.owner	=	THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">as_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	printk(KERN_INFO <span class="string">"as_init\n"</span>);</span><br><span class="line"></span><br><span class="line">	ret = proto_register(&amp;as_proto, <span class="number">1</span>); <span class="comment">//注册协议</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"proto_register ERROR\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = sock_register(&amp;as_family_ops);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"sock_register ERROR\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">	printk(KERN_INFO <span class="string">"device has been registered\n"</span>);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">as_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">   printk(KERN_INFO <span class="string">"aproto exit\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(as_init);</span><br><span class="line">module_exit(as_exit);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_RELDATE     <span class="meta-string">"2017/12/07"</span></span></span><br><span class="line">MODULE_AUTHOR(<span class="string">"Jingwei Zheng"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"AS:A NEW PROTOCOL"</span> DRV_RELDATE);</span><br></pre></td></tr></table></figure>
<h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_AS 43</span></span><br><span class="line">...</span><br><span class="line">socket_fd = socket(AF_AS, SOCK_SEQPACKET, <span class="number">0</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 网络协议栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
