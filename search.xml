<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【论文笔记】Reaching agreement in the presence of faults (EIG)]]></title>
    <url>%2F2018%2F07%2F04%2Fpaper-eig%2F</url>
    <content type="text"><![CDATA[这篇论文在1980年发表，是1982年著名的拜占庭将军问题论文的前身。作者Leslie Lamport是2013图灵奖得主，两篇论文引用次数分别为5000+和2000+。该论文提出的算法现在被称为EIG算法（EIG全称指数信息收集），因为消息的数量是和节点数量呈指数关系。 “Reaching Aggrement in the Presence of Faults ” M. PEASE, R, SHOSTAK, AND L. LAMPORT, 1980. “The Byzantine General Problem” Leslie Lamport, Robert Shostak, and Marshall Pease ,1982 1 问题定义一个分布式的处理系统具有多个处理节点，要保证可靠就必须具有容错性，能够在部分节点故障的情况下正常工作。而本算法解决的问题是与一些相互隔离的处理节点相关，其中有一些节点可能是故障的，节点之间只能通过双方之间的消息传递进行通信。 问题定义如下： n个独立节点组成的集合，故障节点数量不超过m 节点之间只能通过双方之间的信息进行通信 （不存在第三方监听捣乱以及信道故障的问题，也就是说消息一定能传递到对方，并且认为传递的时延是几乎一致，不存在时延问题，并且接收方总是可以识别消息的发送方） 每个非故障的节点有一个私有值 (private value)，用来与其他节点进行通信 非故障节点总是“诚实地”进行通信，故障节点可能“说谎” （传递错误消息） 算法设计目标： 推断出的某非故障节点值必须是该节点的私有值 每个非故障节点推断出的故障节点的值必须一致 目标本质上是使非故障节点达成共识 2 交互一致性为了介绍算法该论文定义了一个叫做交互一致性的概念来阐述。交互一致性定义如下： 考虑由n个独立节点组成的集合，已知故障节点数量不超过m。假设节点之间通信只能有双方参与，传输时延可以忽略不计。接收方总是可以识别消息的发送方。假设节点p有某个私有值Vp (例如它的时钟值或者读某个传感器的值)。问题可以归结如下：对于给定的大于零的值m，n，是否可能设计一个基于消息传递的算法使每个非故障节点p计算一个值向量，其中每个元素对应每个节点。其中： 每个非故障节点计算出完全一致的向量 向量中对于指定某个非故障节点的元素值是该节点的私有值 注意：该算法并不需要确定出哪些节点是故障的，重点在于使所有非故障节点计算出的向量的值是相同的。 算法对于$n&gt;=3m+1$可解，其中n为节点总数，m为故障节点数 计算出的向量称为一致性向量(interactive consistency vector，ICV) 因为每个非故障节点可以根据应用需要对向量使用平均或者滤波函数，对同一个向量使用相同的函数，所以共识一定能够达成。 3 单点故障首先我们从满足该条件的最简单的例子m=1，n=4开始介绍。 整个处理流程包含两部分，消息的交换以及基于交换结果的交互一致性向量的计算。单点故障需要两轮信息交换。第一轮节点交换它们的私有值，第二轮它们交换第一轮得到的结果。 在整个过程中故障节点可能“说谎”，即传递错误的信息，或拒绝发送信息。 消息的交换 Round1：节点交换各自私有值 Round2：交换第一轮得到的值 ICV向量计算 投票 当消息交换完成后，每个非故障节点p在各自向量上对应p的位置记录自己的私有值Vp。而对应于另外三个节点q的元素，根据检验接收的三个q的值来确定。其中一个通过第一轮从q获得，其他两个通过第二轮从剩余两个节点获得。如果三个值中至少两个相同，则该数值被采用，否则采用一个默认值“NIL”。 m=1 n=4下面用图来详细说明整个过程：假设P1、P2、P4为非故障节点，而P3为故障节点。P1，P2，P3,P4的私有值分别为{1,2,3,4,}。P3在第一轮传递给P1、P2、P4的私有值分别为3、Z、Y。以P1收到的消息为例，P1收到来自P2的消息向量为{1,2,Z，4}，即P2在第一轮传递的P2私有值为2，在第二轮转发第一轮收到的P3私有值Z及P4私有值4。同理P1收到P3的消息向量为{1,B,3,4}，收到P4的消息向量为{1,2,Y,4}。两轮消息传递后，统计P2，P3，P4的消息向量同一单元位置出现次数大于2次的值，设为ICV元素值，如果没有则设置为NIL。得到P1的ICV为{1,2,NIL,4}。 按照以上方法分析，同理可以得到剩余两个非故障节点P2和P4的ICV为{1,2,NIL,4}，因此所有非故障节点的ICV相同，达成共识。如果{3,Z,Y}中有两个元素以上相等，该非NIL值设为v，则可以分析得到最后P1，P2，P4的ICV也必相等，为{1,2,v,4}。 4 多点故障（n&gt;=3m+1） 对于单点故障 -&gt; 需要2轮信息交换 对于m点故障 -&gt; 需要m+1轮信息交换 其中第一轮是交换私有值，接下来的m轮交换上一轮收到的值。整个过程是指数级别的，所以也称为指数信息收集算法（EIG）。 设$P$为节点集合 , $V$为值的集合 k≥1: k-level scenario -&gt; mapping from a set of non-empty strings ${p1,p2,p3,…pn}$ over $P$ of length $&lt;=k+1$, to $V$ Example: For a k-level scenario σ and string $w=p1p2…pn ,σ(ω)$= the value of $pn$ that $pn$ tells $p_{n-1}$ … which $p_2$ tells $p_1$ 对于一个给定的k水平场景σ和字符串$ω=p1p2p3⋯pn$，$2&lt;=n&lt;=k+1$，$σ(ω)$用来表示pn的私有值经过$p{n-1} p{n-2})⋯p2$的传递最后到达传递给$p1$的值。 对于单元素的字符串$σ(p$)表明$p$的私有值。一个k水平的场景总结了经过k轮的信息交换的结果。对于每个非故障节点q，任意节点p以及字符串$w$，有$σ(pqω)=σ(qω)$成立。 计算过程节点p接收的信息以p开始的字符串限定，记为$σ_p$。对于任意m&gt;=0，n&gt;=3m+1，给定$σ_p$下对某个节点q的计算过程如下： 如果P的某个大小≥(n+m)/2的子集Q，如果对于每个长度不大于m的字符串w（Q中元素组成），有$σ_p$ (pωq)=v，则p记录v  如果没有，则算法将m-1，n-1带入进行递归。此时P用P-{q}代替，$σ_p (pωq)$用 $σ_p (pω)$代替。对于每个字符串长度不大于m的字符串w，如果在这向量n-1个元素里有至少(n+m)/2个元素值相同，p记录下该值，否则记录NIL值。 m=2 n=7下面以m=2,n=7为例介绍多点故障下的算法流程。如图所示一共有7个节点，其中节点4和节点6是故障节点，其余为非故障节点。第一轮信息交换，节点之间互相传递各自的私有值，可以看到节点4和节点6伪造各自的私有值进行传递。 以节点1为例，列出所有满足的$σ_p (pωq)$的情况进行判断，最后可以得到节点1的向量为{V1,V2,V3,NIL,V5,NIL,V7}。最后所谓非故障节点将得到的向量也是{V1,V2,V3,NIL,V5,NIL,V7}，满足交互一致性，达成协定。 5 n&lt;3m+1不能达成协定下面以m=1，n=3为例说明n&lt;3M+1时不能达成共识。如图所示，节点3是故障节点，节点1和节点2是非故障节点；我们可以看到节点1和节点2的向量中元素没有一个大多数值，例如节点1向量关于第2个元素值有一个B和一个V2，没有一个数占大多数，也就无法达成共识。 6 带认证的算法n&lt;3m+1情况下无法达成协定是基于故障节点可能拒绝传递或者伪造从其他节点那收到的值。 而使用认证可以保证故障节点虽然可能在传递自己私有值时撒谎或者拒绝发送自己的私有值，但是不能错误转发从其他节点收到的值。 使用认证的方法是在消息中加入签名，该签名只能由发送方创建。接收方可以使用验证器来检验发送方以及值是否正确。公钥和私钥结合对消息进行Hash可以达到以上目的。 下面以m=1，n=3举例。在使用带有认证的算法时，节点3无法伪造收到的节点1和节点2的值，所以可以看到节点1中两个向量的第二个元素都是V2，节点2中两个向量的第一个元素都是V1。最终两个节点得到的向量均相同，并且非故障节点元素为节点的私有值，满足交互一致性的定义，也就达成了协定。 7 总结 这篇论文是拜占庭问题论文的前身，基本介绍了拜占庭问题的内容。 提出了交互一致性的概念用来描述协定问题，对于分布式容错系统的设计而言交互一致性是必要的。 并且提出了EIG算法用于解决拜占庭协定问题。 在该问题中，故障节点可以伪造自己的私有值以及收到的来自其他节点的数据。在故障节点数目少于总结点数的三分之一时，使用该算法可以有效地使非故障节点达成一致。当故障节点数大于等于总结点数三分之一时，节点无法达成协定。 此外，当使用带有认证的机制时，在该协定条件下故障节点可以伪造自己的私有值但无法伪造收到的来自其他节点的数据，在此限定下非故障节点可以达成协定。]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议栈性能影响因素及优化技术]]></title>
    <url>%2F2018%2F05%2F23%2Fnetwork-stack-overhead%2F</url>
    <content type="text"><![CDATA[影响网络协议栈的性能开销及优化方法如下。 1 网卡中断开销轮询与中断是操作系统与外设进行 I/O 通信的两种主要方式。一般情况下，网络中数据分组的到来具有不可预测性。若采用轮询模式对数据分组进行持续监听，会造成很高的CPU占用率，进而影响系统其他进程的运行效率，故主流操作系统都采用中断来处理网络的请求。中断处理方式在低速网络I/O场景下非常有效，高速网络中，随着网络 I/O速率的不断上升，网卡面对大量高速数据分组引发频繁的中断，中断引起的上下文切换开销将变得不可忽视，造成较高的时延，并引起吞吐量下降。 1.1 轮询代替中断轮询不存在中断所固有的开销。以网卡接收分组为例，在轮询模式下，系统会在初始化时屏蔽收发分组中断， 并使用一个线程或进程不断检测收取分组描述符里的收取分组成功标志是否被网卡置位，以此来判断是否有数据分组，整个收取过程没有发生上下文切换，因此也就避免了相应的开销。在高速网络I/O下，轮询带来的性能提升是非常显著的。 轮询不一定总是优于中断。只有当I/O速率接近CPU速率时，中断的开销变得不可忽略，轮询模式的优势才能体现；相反，如果数据吞吐率很低，中断能有更好的CPU利用率，此时不宜采用中断模式。 基于以上分析，针对网络流量抖动较大的场景， 可以选用中断与轮询的混合模式，即：在流量小时使用中断模式，当遇到大流量时切换为轮询模式。 目前Linux内核（NAPI）与DPDK都支持这种混合中断轮询模式。NAPI（Linux New API）：可以动态地决定中断还是轮询。中断只有在一个batch的第一个数据包时是enable，然后polling定期enabled，用来检查收到数据包的设备。数据包参数存到DMA-able memory，等待CPU available。当DMA-able memory里面没有数据包时中断重新使能。这样使得，IO低时候用中断；IO高用轮询。 2 内存复制开销 提供服务的应用进程运行在用户空间，而通常情况下，操作系统首先将到来的数据分组读取到内核空间，为了使上层应用能够对接收到的数据进行相应处理，需要将内核将数据从内核空间复制到用户空间；而对于应用进程产生的数据， 也需要由用户空间复制到内核空间，最后由网卡发出。操作系统在处理数据过程中往往需要 进行多次复制操作，严重影响了高速网络服务的性能。 2.1 零拷贝技术(Zero-copy)零拷贝指的是除网卡将数据DMA复制进内存外（非CPU参与）， 从数据分组接收到应用程序处理数据分组，整个过程中不存在数据复制。高速网络下，网络IO性能甚至超过CPU处理能力，频繁数据拷贝会耗尽CPU计算资源，使CPU成为性能瓶颈。同时，数据从内核空间进入应用程序所处的用户空间，该过程中引发的上下文切换开销同样不可忽略。 DPDK、Netmap、PF-ring等高性能数据分组处理框架都用了零拷贝技术。 PF-ring：将内核中的数据包缓存区暴露给用户态程序，数据包缓存区预分配。PF_Ring DNA (Direct NIC Access)：利用特殊的driver，提供NIC内存到用户空间内存的映射。缺点：通过DMA可能错误使用内存地址，导致系统崩溃。 3 锁开销 当多个线程或进程需要对某一共享资源进行操作时，往往需要通过锁机制来保证数据的一致性和同步性，而加锁带来的开销会显著降低数据处理的性能。具体来说，锁机制造成的开销主要有两方面：一方面，线程在为共享资源上锁或者去锁的过程中通常需要耗时几十纳秒；另一方面，在竞争锁的过程中，等待线程在阻塞过程中无法进行有效的数据处理和计算，从而降低了整个系统的并发性能。无论是宿主机还是客户机的内核协议栈中，都存在大量的共享资源，这也制约着整个系统的可扩展性。 3.1 连接本地化​ 将共享的数据结构分区 &amp; 连接本地化以减少锁开销/跨核开销。即设法将同一个流的所有数据分组交由同一个CPU核处理，从而避免不同核对于同一资源的竞争， 进而也就避免了加锁的开销。同时， 在同一个CPU核处理同一条流也可以提升缓存的命中率，避免跨核的开销。 4 上下文切换开销数据平面进行资源的分配调度过程中涉及多种类型的上下文切换：在网卡中断、系统调用、进程调度与跨核资源访问 等上下文切换过程中，操作系统均需要保存当前状态，上下文切换开销大，严重影响系统性能。 4.1 用户态协议栈直接将协议栈移动到应用层实现，避免昂贵的上下文切换开销， 如mTCP、 lwIP等方案 4.2 批处理系统调用批处理系统调用平摊开销，MegaPipe、FlexSC、 VOS均使用批量系统调用来减小开销。 5 文件系统管理开销socket是一种文件抽象，Linux 为了实现统一文件管理，通过虚拟文件系统（virtual file system，VFS）为套接字绑定了一系列对应的数据结构如inode、dentry等。通常情况下， 这些重量级的数据结构对于套接字本身的功能来说是不必要的[Fastsocket]。而在NFV的应用场景下（或者高并发的短连接），往往需要对 socket进行频繁的分配和释放，因而操作系统在管理这些数据结构的过程中会引起较大的性能开销。 5.1 自定义轻量级socket自定义轻量级的 socket，一些优化方案如mTCP、lwIP等，选择直接绕过VFS，在用户态重新定义实现socket结构体；另外一些优化 方案如MegaPipe等，虽然在内核实现，但也通过自定义API避免了原有VFS的文件操作 5.2 继承VFS的socket实现但简化继承VFS的socket实现，但是简化掉inode与 dentry 的初始化与销毁过程，抛弃其中的锁。这是因为对于socket而言，inode与dentry是完全无用的。代表性工作是Fastsocket。 相比前一种方案，该方案的优点在于能够完全兼容传统 socket，便于应用抑制 继承VFS的socket实现，但是简化掉inode与 dentry 的初始化与销毁过程，抛弃其中的锁。这是因为对于socket而言，inode与dentry是完全无用的。代表性工作是Fastsocket。 相比前一种方案，该方案的优点在于能够完全兼容传统 socket，便于应用抑制 6 缓存未命中开销如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体如果在存在频繁的跨核调用， 由此带来的缓存未命中会造成严重的数据读写时延，从而降低系统整体性]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 13. Roman to Integer]]></title>
    <url>%2F2018%2F02%2F11%2Fleetcode-13%2F</url>
    <content type="text"><![CDATA[13. Roman to IntegerGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 思路将输入罗马数字字符串转换为数字 罗马数字罗马数字采用七个罗马字母作数字、即 I - 1V - 5X - 10L - 50C - 100D - 500M - 1000 记数的方法： 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 使用unordered_map存储罗马数字和阿拉伯数字的kv对，然后遍历字符串进行统计和处理。 solution1234567891011121314151617181920class Solution &#123;public: int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; T = &#123; &#123; 'I' , 1 &#125;, &#123; 'V' , 5 &#125;, &#123; 'X' , 10 &#125;, &#123; 'L' , 50 &#125;, &#123; 'C' , 100 &#125;, &#123; 'D' , 500 &#125;, &#123; 'M' , 1000 &#125; &#125;; int num = T[s[0]] ; for( int i=1 ;i&lt;s.size();i++)&#123; if(T[s[i]] &gt; T[s[i-1]]) num += T[s[i]] - 2*T[s[i-1]] ; else num += T[s[i]]; &#125; return num; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 12. Integer to Roman]]></title>
    <url>%2F2018%2F02%2F10%2Fleetcode-12%2F</url>
    <content type="text"><![CDATA[12. Integer to RomanGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 思路将输入整数转换为罗马数字 罗马数字罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法： 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9； 某一位上数字表示的规律： 1：直接表示 2、3：小数叠加 4：5-1 5：直接表示 6：5+1 7：5+2 8：5+3 9：10-1 10：直接表示 solution自己写的，比较长 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: string intToRoman(int num) &#123; string str; while(num&gt;= 1000)&#123; num -=1000; str += 'M'; &#125; int hun = (num%1000)/100; switch(hun)&#123; case 0:break; case 1:str+="C";break; case 2:str+="CC";break; case 3:str+="CCC";break; case 4:str+="CD";break; case 5:str+="D";break; case 6:str+="DC";break; case 7:str+="DCC";break; case 8:str+="DCCC";break; case 9:str+="CM";break; &#125; int dec = (num%100)/10; switch(dec)&#123; case 0:break; case 1:str+="X";break; case 2:str+="XX";break; case 3:str+="XXX";break; case 4:str+="XL";break; case 5:str+="L";break; case 6:str+="LX";break; case 7:str+="LXX";break; case 8:str+="LXXX";break; case 9:str+="XC";break; &#125; int unit = num%10 ; switch(unit)&#123; case 0:break; case 1:str+="I";break; case 2:str+="II";break; case 3:str+="III";break; case 4:str+="IV";break; case 5:str+="V";break; case 6:str+="VI";break; case 7:str+="VII";break; case 8:str+="VIII";break; case 9:str+="IX";break; &#125; return str ; &#125;&#125;; 参考网上精简的代码 12345678910class Solution &#123;public: string intToRoman(int num) &#123; string M[] = &#123;"","M","MM","MMM"&#125;; string C[] = &#123;"","C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; string X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; string I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 9. Palindrome Number]]></title>
    <url>%2F2018%2F02%2F07%2Fleetcode-9%2F</url>
    <content type="text"><![CDATA[9. Palindrome NumberDetermine whether an integer is a palindrome. Do this without extra space. 思路题目要求不能使用额外的空间，所以不能转成字符串来处理。解题思路很简单，将比较原来的数和倒置后的数是否为同一个数即可。 注意: 负数不是回文数 在倒置过程中不需要判断是否溢出，因为逆序后溢出的数必然和原来的数不同，肯定不是回文数 solution1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; int rev = 0, num = x; while(num &gt; 0)&#123; rev = rev *10 + num%10; num= num/10; &#125; if(rev == x) return true; else return false; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8. String to Integer (atoi)]]></title>
    <url>%2F2018%2F02%2F06%2Fleetcode-8%2F</url>
    <content type="text"><![CDATA[8. String to Integer (atoi)Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 思路这道题难度不高，主要是要理解题目的要求 题目的要求： 首先需要丢弃字符串前面的空格； 然后可能有正负号（注意只取一个，如果有多个正负号，那么说这个字符串是无法转换的，返回0。比如测试用例里就有个“+-2”）； 字符串可以包含0~9以外的字符，如果遇到非数字字符，那么只取该字符之前的部分，如“-00123a66”返回为“-123”； 如果超出int的范围，返回边界值（2147483647或-2147483648，INT_MAX和INT_MIN）。 注意判断是否溢出的条件： 1if(ret &gt;INT_MAX/10 || (ret == INT_MAX/10 &amp;&amp; str[i]-'0' &gt;7) 其中一个测试用例就是 12Input:&quot;2147483648&quot;Expected:2147483647 solution1234567891011121314151617181920212223242526class Solution &#123;public: int myAtoi(string str) &#123; int ret = 0,i=0; char sign = '+'; while(str[i]==' ') ++i; if(str[i]=='+'||str[i]== '-')&#123; // if string has sign if((str[i]=='+'&amp;&amp;str[i+1]=='-') || (str[i]=='-'&amp;&amp;str[i+1]=='+')) // 2 sign return 0; sign = str[i]; // get the sign ++i; &#125; while(i &lt; str.size())&#123; if(str[i]&gt; '9' || str[i] &lt;'0') break; if(ret &gt;INT_MAX/10 || (ret == INT_MAX/10 &amp;&amp; str[i]-'0' &gt;7))&#123; // if overflow if(sign =='+') return INT_MAX; else if(sign = '-') return INT_MIN; &#125; ret = ret * 10 + (str[i] -'0'); ++i; &#125; if(sign == '-') ret = -ret; return ret; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7. Reverse Integer]]></title>
    <url>%2F2018%2F02%2F05%2Fleetcode-7%2F</url>
    <content type="text"><![CDATA[7. Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 思路注意一点就是乘10的时候可能溢出，需要进行判断乘10之前是否已经大于 INT_MAX/10。 INT_MAX = 2147483647 = 2^31 -1 = 1&lt;&lt;31 -1 solution123456789101112131415class Solution &#123;public: int reverse(int x) &#123; if (x==0) return x; int sign = (x&gt;0)?1:-1 ; int ret = 0; x = abs(x); while(x&gt;0)&#123; if(ret&gt;INT_MAX/10) return 0; ret = ret*10 +x%10; x = x/10; &#125; return sign * ret; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6. ZigZag Conversion]]></title>
    <url>%2F2018%2F02%2F04%2Fleetcode-6%2F</url>
    <content type="text"><![CDATA[6. ZigZag ConversionThe string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: 1&quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); 1convert(&quot;PAYPALISHIRING&quot;, 3) should return 1&quot;PAHNAPLSIIGYIR&quot; 思路就是把字符串原顺序012345……按下图所示排列： 比较直观的解法是，用一个字符串数组 string[rows] 来存储每一行，最后一拼接就是最终结果。 用一个flag表示正向还是反向，即上图中从第一行到最后一行还是最后一行到第一行。 solution12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows==1) return s; string str[numRows]; int row = 0 ,flag=0; for(int i = 0;i&lt;s.size();i++)&#123; str[row] += s[i]; if(!flag&amp;&amp;row&lt;numRows-1) ++row; else if(row==numRows-1)&#123; flag=1; row--; &#125; else if(flag &amp;&amp; row&gt;0) row--; else if(row==0) &#123; flag=0; ++row; &#125; &#125; string ret; for(int i = 0;i&lt;numRows;i++)&#123; ret +=str[i]; &#125; return ret; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5. Longest Palindromic Substring]]></title>
    <url>%2F2018%2F02%2F03%2Fleetcode-5%2F</url>
    <content type="text"><![CDATA[5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 12345Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example: 123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路最长回文子串。就是给定一个字符串S，找出其中的最长回文子串，并返回该子串。 解法1：暴力枚举 时间复杂度$O(n^3)$ 解法2：中心扩展法 时间复杂度$O(n^2)$ 空间复杂度$O(1)$ 解法3：动态规划 时间复杂度$O(n^2)​$ 空间复杂度$O(n^2)​$ 解法4：Manacher算法 时间复杂度$O(N)$ 空间复杂度$O(n)$ 解法1：暴力枚举遍历该字符串的每一个子串，判断是不是回文串，最后给出最长回文子串。 时间复杂度$O(n^3)$，运行超时 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if(len &lt;= 1) return s; int maxlen = 0; string max_sub_string = ""; for(int i = 0;i&lt;len;i++)&#123; for(int j = i ; j &lt; len ;j++)&#123; string sub_string = s.substr(i,j-i+1); if(isPalindrome(sub_string))&#123; if(sub_string.size()&gt;maxlen)&#123; maxlen = sub_string.size(); max_sub_string = sub_string; &#125; &#125; &#125; &#125; return max_sub_string; &#125; bool isPalindrome(string s)&#123; int slen = s.size(); for(int i = 0;i&lt;(slen+1)/2;i++)&#123; if(s[i]!=s[slen-1-i]) return false; &#125; return true; &#125;&#125;; 解法2：中心扩展法优化：枚举回文串的中点 从某一个字符开始，左右向外扩展得到一个更长的子串，看是否是回文子串，如果是回文子串，则继续向外遍历，知道遇到非回文子串或者超出子串范围。需要注意针对一个字符向外扩张时，需要同时偶数字符个数回文子串和奇数字符个数回文子串两种情况。 时间复杂度$O(n^2)$ 空间复杂度$O(1)$ 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if(len &lt;= 1) return s; int maxlen = 0, left = 0,right = 0,substr_left,substr_right,substr_len; string max_sub_string = ""; for(int i = 1;i&lt;len;++i)&#123; left = i -1 ; right = i; // even Palindrome eg. "abba" while(left &gt;=0 &amp;&amp; right &lt; len &amp;&amp; s[left]==s[right])&#123; --left; ++right; &#125; substr_left = left +1; substr_right = right -1; substr_len = substr_right -substr_left +1 ; if(substr_len &gt; maxlen)&#123; max_sub_string = s.substr(substr_left,substr_len); maxlen = substr_len; &#125; // odd Palindrome eg. "abcba" left = i-1; right = i+1; while(left &gt;=0 &amp;&amp; right &lt; len &amp;&amp; s[left]==s[right])&#123; --left; ++right; &#125; substr_left = left +1; substr_right = right -1; substr_len = substr_right -substr_left +1 ; if(substr_len &gt; maxlen)&#123; max_sub_string = s.substr(substr_left,substr_len); maxlen = substr_len; &#125; &#125; return max_sub_string; &#125;&#125;; 解法3：动态规划时间复杂度$O(n^2)$ 空间复杂度$O(n^2)$ 首先写出动态转移方程：P[ i, j ] ← ( P[ i+1, j-1 ] and Si = Sj ) 显然，如果一个子串是回文串，并且如果从它的左右两侧分别向外扩展的一位也相等，那么这个子串就可以从左右两侧分别向外扩展一位。 其中的base case是 P[ i, i ] ← trueP[ i, i+1 ] ← ( Si = Si+1 ) 假设有个字符串是adade，现在要找到其中的最长回文子串。使用上面的动态转移方程，有如下的过程: 按照红箭头-&gt;黄箭头-&gt;蓝箭头-&gt;绿箭头-&gt;橙箭头的顺序依次填入矩阵，通过这个矩阵记录从i到j是否是一个回文串。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if(len &lt;= 1) return s; int maxlen = 1 ,begin; bool dp[len][len]; // dp[i][j] == true -&gt; s[i..j] is palindrome memset(dp,0,sizeof(dp)); for(int i = 0; i&lt;len ;i++)&#123; dp[i][i] = true; &#125; for(int i =0 ; i&lt; len -1;i++)&#123; if(s[i]==s[i+1])&#123; dp[i][i+1] = true; maxlen = 2; begin = i; &#125; &#125; for(int substr_len = 3; substr_len &lt;= len ;substr_len ++)&#123; for(int i =0; i &lt;= len -substr_len; i++)&#123; int j = i + substr_len -1 ; if(s[i] == s[j] &amp;&amp; dp[i+1][j-1] == true)&#123; dp[i][j] = true ; begin = i; maxlen = substr_len; &#125; &#125; &#125; return s.substr(begin,maxlen); &#125;&#125;; ##解法4：Manacher算法 时间复杂度$O(n)$ 空间复杂度$O(n)$ Manacher算法 该算法首先对字符串进行预处理，在字符串的每个字符前后都加入一个特殊符号，比如字符串 abcd 处理成 #a#b#c#d#,为了避免处理越界，在字符串首尾加上不同的两个特殊字符(c类型的字符串尾部不用加，因为自带‘\0’)，这样预处理后最终变成$#a#b#c#d#^，经过这样处理后有个好处是原来的偶数长度和奇数长度的回文在处理后的字符串中都是奇数长度。假设处理后的字符串为s。 对于已经预处理好的字符串我们用数组p[i]来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]）,以字符串“12212321”为例，p数组如下 12s： $ # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 # ^ p： 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1 可以看出，P[i]-1正好是原字符串中回文串的总长度, 如果p数组已知，遍历p数组找到最大的p[i]就可以求出最长回文的长度，也可以求出回文的位置 下面给出求p[]数组的方法： 设id是当前求得的最长回文子串中心的位置，mx为当前最长回文子串的右边界（回文子串不包括该右边界），即mx = id + p[id]。记j = 2*id – i ，即 j 是 i 关于 id 的对称点。 1、 当i &lt; mx 时，如下图。此时可以得出一个非常神奇的结论p[i] &gt;= min(p[2*id - i], mx - i)，下面我们来解释这个结论 如何根据p[j]来求p[i]呢，又要分成两种情况 （1.1）当mx – i &gt; p[j], 这时候以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以 P[i] 至少等于 p[j], 后面的再继续匹配。如下图 *注：这里其实p[i]一定等于p[j],后面不用再匹配了。因为如果p[i]后面还可以继续匹配，根据对称性，p[j]也可以继续扩展了* （1.2）当mx – i &lt;= p[j]， 以S[j]为中心的回文子串不完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] 至少等于 mx - i，至于mx之后的部分是否对称，就只能老老实实去匹配了。 注：如果mx – i &lt; p[j] ，这时p[i]一定等于mx - i, 因为如果p[i]在mx之后还可以继续匹配，根据对称性，mx之后匹配的点(包括mx)一定会出现在my的前面，这说明p[id]也可以继续扩展了 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string longestPalindrome(string s) &#123; if(s.size() &lt;= 1) return s; int id=0,mx=0; // Manacher Algorithm string str = preProcess(s); int len = str.size(); vector&lt;int&gt; p(len,0); for(int i =1; i&lt; len-1;i++)&#123; p[i] = mx &gt; i ? min(p[2*id -i],mx-i):1; //mx为当前最长回文子串的右边界 while(str[i+p[i]] == str[i-p[i]]) // 计算P[i] p[i]++; if( i + p[i] &gt; mx)&#123; mx = i+ p[i]; id = i; &#125; &#125; // 遍历p，寻找最大回文长度 int maxlen =0,index =0; for(int i =1;i&lt;len-1;i++)&#123; if(p[i] &gt; maxlen)&#123; maxlen = p[i]; index = i; &#125; &#125; return s.substr((index - maxlen)/2,maxlen-1); //p[i]-1为原字符串中的回文子串长度 &#125; string preProcess(string &amp;s)&#123; int n = s.size(); string res; res.push_back('$'); res.push_back('#'); for(int i = 0; i&lt;n ;i++)&#123; res.push_back(s[i]); res.push_back('#'); &#125; res.push_back('^'); return res; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4. Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F02%2F02%2Fleetcode-4%2F</url>
    <content type="text"><![CDATA[4. Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 思路要求在给定的两个有序数组中里面找其中的中位数，硬性要求时间复杂度为$O(log(m+n))$ 问题可以转化为两个有序序列找第num大的数，由于时间复杂度被限制死，所以不能采用排序后再找中位数的方法（时间复杂度高）。以下参考 两个有序数组中的中位数和Top K问题 预备知识先解释下“割” 我们通过切一刀，能够把有序数组分成左右两个部分，切的那一刀就被称为割(Cut)，割的左右会有两个元素，分别是左边最大值和右边最小值。 我们定义L = Max(LeftPart)，R = Min(RightPart) Ps. 割可以割在两个数中间，也可以割在1个数上，如果割在一个数上，那么这个数即属于左边，也属于右边。（后面讲单数组中值问题的时候会说） 比如说[2 3 5 7]这个序列，割就在3和5之间[2 3 / 5 7]中值就是（3+5）/2 = 4 如果[2 3 4 5 6]这个序列，割在4上，我们可以把4分成2个[2 3 (4/4) 5 7]中值就是（4+4）/2 = 4 这样可以保证不管中值是1个数还是2个数都能统一运算。 割和第k个元素对于单数组，找其中的第k个元素特别好做，我们用割的思想就是：如果在k的位置割一下，A[k]属于左边部分的最大值。 双数组我们设:Ci为第i个数组的割。Li为第i个数组割后的左元素.Ri为第i个数组割后的右元素。 如何从双数组里取出第k个元素 首先Li&lt;=Ri是肯定的（因为数组有序，左边肯定小于右边） 如果我们让L1&lt;=R2 &amp;&amp; L2&lt;=R1 那么左半边 全小于右半边，如果左边的元素个数相加刚好等于k，那么第k个元素就是Max(L1,L2)，参考上面常识1。 如果 L1&gt;R2，说明数组1的左边元素太大（多），我们把C1减小，把C2增大。L2&gt;R1同理，把C1增大，C2减小。 假设k=3对于[1 4 7 9][2 3 5] 设C1 = 2，那么C2 = k-C1 = 1[1 4/7 9][2/3 5] 这时候，L1(4)&gt;R2(3)，说明C1要减小，C2要增大，C1 = 1，C2=k-C1 = 2[1/4 7 9][2 3/5] 这时候，满足了L1&lt;=R2 &amp;&amp; L2&lt;=R1，第3个元素就是Max(1,3) = 3。 如果对于上面的例子，把k改成4就恰好是中值。 下面具体来看特殊情况的中值问题。 双数组的奇偶中值的关键在于，如何处理奇偶性，单数组的情况，我们已经讨论过了，那双数组的奇偶问题怎么办，m+n为奇偶处理方案都不同， 让数组恒为奇数有没有办法让两个数组长度相加一定为奇数或偶数呢？ 其实有的，虚拟加入‘#’(这个trick在manacher算法中也有应用)，让数组长度恒为奇数（2n+1恒为奇数）。Ps.注意是虚拟加，其实根本没这一步，因为通过下面的转换，我们可以保证虚拟加后每个元素跟原来的元素一一对应 之前 len 之后 len [1 4 7 9] 4 [# 1 # 4 # 7 # 9 #] 9 [2 3 5] 3 [# 2 # 3 # 5 #] 7 映射关系这有什么好处呢，为什么这么加?因为这么加完之后，每个位置可以通过/2得到原来元素的位置。 / 原位置 新位置 除2后 0 1 0 1 5 2 5 2 在虚拟数组里表示“割”不仅如此，割更容易，如果割在‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分。 奇妙的是不管哪种情况： Li = (Ci-1)/2Ri = Ci/2 例： 割在4/7之间‘#’，C = 4，L=(4-1)/2=1 ，R=4/2=2 刚好是4和7的原来位置！ 割在3上，C = 3，L=(3-1)/2=1，R=3/2 =1，刚好都是3的位置！ 剩下的事情就好办了，把2个数组看做一个虚拟的数组A，目前有2m+2n+2个元素，割在m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。左边：A[m+n+1] = Max(L1+L2)右边：A[m+n+2] = Min(R1+R2) Mid = (A[m+n+1]+A[m+n+2])/2= (Max(L1+L2) + Min(R1+R2) )/2 至于在两个数组里找割的方案，就是上面的方案。 分治的思路有了上面的知识后，现在的问题就是如何利用分治的思想。 怎么分？最快的分的方案是二分，有2个数组，我们对哪个做二分呢？根据之前的分析，我们知道了，只要C1或C2确定，另外一个也就确定了。这里，为了效率，我们肯定是选长度较短的做二分，假设为C1。 怎么治？也比较简单，我们之前分析了：就是比较L1,L2和R1,R2。 L1&gt;R2，把C1减小，C2增大。—&gt; C1向左二分 L2&gt;R1，把C1增大，C2减小。—&gt; C1向右二分 越界问题如果C1或C2已经到头了怎么办？这种情况出现在：如果有个数组完全小于或大于中值。可能有4种情况：C1 == 0 —— 数组1整体都比中值大 C1 == 2 x n —— 数组1整体比中值小 C2 == 0 —— 数组1整体都比中值小 C2 == 2 x m —— 数组1整体比中值大 具体实现nums1大小为n，nums2大小为m。默认在长度小的数组上进行二分查找。如果n&gt;m，交换。 根据“虚拟数组”，两个虚拟数组包含#一共有2m+2n+2个元素。若nums1割c1，则表示nums1左边有c1个数字，而总共数字有m+n个，为了两个数组在割的左右边总数相等，所以c2= m+n-c1 low和high是二分查找的区间头和尾。low初始值为0（[# 1 # 4 # 7 # 9 #]最左边的#），high初始值为2*n （[# 1 # 4 # 7 # 9 #]最右边的#），割c1=(low+high)/2，表示c1从nums1数组正中间位置开始，c2=m+n-c1，nums1左边和nums2左边元素数量 = nums1右边和nums2右边元素数量。 当越界时，巧妙设置INT_MIN和INT_MAX，使其中一个割无效。 如nums1 = [1 2] nums2 = [3 4 5 6 7 8]，因为nums1整体小于nums2，则经过几次循环后，c1 = 4，l1 = 2，r1 = INT_MAX。c2 = 4，l2 = 4，r2 = 5。low = high =4，此时因为满足了左边整体&lt;=右边，所以会break跳出循环，然后return (max(l1,l2) + min(r1,r2))/2.0，此时其实返回的就是nums2中割左右两端的中位数。 代码1234567891011121314151617181920212223242526class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n = nums1.size(); int m = nums2.size(); if(n &gt; m) return findMedianSortedArrays(nums2,nums1); int c1,c2,l1,l2,r1,r2,low =0,high = 2*n; while(low &lt;= high)&#123; c1 = (low + high)/2; c2 = m + n - c1; l1 = (c1==0)?INT_MIN:nums1[(c1-1)/2]; r1 = (c1==2*n)?INT_MAX:nums1[c1/2]; l2 = (c2==0)?INT_MIN:nums2[(c2-1)/2]; r2 = (c2==2*m)?INT_MAX:nums2[c2/2]; if(l1 &gt; r2)&#123; high = c1 - 1; &#125; else if (l2 &gt; r1)&#123; low = c1 + 1; &#125; else break ; &#125; return (max(l1,l2) + min(r1,r2))/2.0; &#125;&#125;; LeetCode具体实现代码和详细解题报告：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3. Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F02%2F01%2Fleetcode-3%2F</url>
    <content type="text"><![CDATA[3.Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot;is a subsequence and not a substring. 思路没有重复字符的最长子串 使用map来存储字符串以及对应的索引，建立一张索引表。以起点start开始查找，若无重复字符，则maxlen = i-start 123abcabcbb^ ^s i 当字符查表已存在，更新起点start为当前字符索引 Solution12345678910111213141516class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_map&lt;char,int&gt; char_map; int maxlen= 0; int start = -1; for(int i = 0; i&lt;s.length();i++)&#123; if(char_map.count(s[i])!=0)&#123; start = max(start,char_map[s[i]]); &#125; char_map[s[i]]=i; maxlen = max(maxlen,i-start); &#125; return maxlen; &#125;&#125;; LeetCode代码和详细解题报告 Github地址：https://github.com/zhengjingwei/LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP实验3:CacheLab]]></title>
    <url>%2F2018%2F01%2F31%2FCSAPP-lab3-cachelab%2F</url>
    <content type="text"><![CDATA[实验简介​ Cache LAB分为Part A和B两部分，这次实验的任务很明确，就是制作自己的缓存系统，具体来说是 实现一个缓存模拟器，根据给定的 trace 文件来输出对应的操作 利用缓存机制加速矩阵运算 我们需要修改的是 csim.c（Part A） 和 trans.c（Part B）。编译的时候只需要简单 make clean 和 make，然后就可以进行测试了。 文件说明Github地址：Cache Lab csim.c：实现缓存模拟器的文件 trans.c：实现矩阵转置的文件 csim-ref：标准的缓存模拟器 csim：由你实现的模拟器可执行程序 tracegen：测试你的矩阵转置是否正确，并给出错误信息 test-trans：测试你的矩阵转置优化的如何，并给出评分 driver.py：自动进行测试评分 在每一次更新之后，首先用make生成文件，之后用相应的test跑分即可。 Part A：Writing a Cache Simulator 实现一个缓存模拟器讲义上首先给我们提供了一个程序示例 1linux&gt; valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l 执行，我们可以看到如下面这样的输出：（输入的trace文件的内容） 1234567891011121314I 04ead900,3I 04ead903,3I 04ead906,5I 04ead838,3I 04ead83b,3I 04ead83e,5 L 1ffefff968,8I 04ead843,3I 04ead846,3I 04ead849,5 L 1ffefff960,8I 04ead84e,3I 04ead851,3...... 这样的trace文件中记载着每一次对内存的操作，前面的字母代表操作类型，统一的格式是: 1[空格][操作类型][空格][内存地址][逗号][大小] 其中如果第一个不是空格而是I，则代表加载，没有实际意义。 操作类型有以下三种： L：读取，从内存中读取 S：存储，向内存中存储 M：修改，这涉及一次读取，一次存储操作 地址指的是一个 64 位的 16 进制内存地址；大小表示该操作内存访问的字节数 其中I指令无空格，M/S/L指令前有1个空格（解析指令时注意） 然后实验给我们提供了一个程序csim-ref，我们要做的就是写出一个和它功能一样的程序。 123456789101112Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;Options: -h Print this help message. -v Optional verbose flag. -s &lt;num&gt; Number of set index bits. -E &lt;num&gt; Number of lines per set. -b &lt;num&gt; Number of block offset bits. -t &lt;file&gt; Trace file.Examples: linux&gt; ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace linux&gt; ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace 样例输出： 分析getopt 获取命令行参数 fscanf 读入trace文件内容 malloc 分配空间给cache 数据访问带来的miss： L：Load，数据载入，可能发生1次miss S：Store，可能发生1次miss M：store后再load，两次访存。1 miss &amp; 1 hit + 可能eviction 所以L/S指令结果是miss或者hit或者miss+eviction；而M指令结果是hit+hit或者miss+hit 或者 miss+eviction+hit 1 Cache结构设计Cache基本单元为 block，cache由cacheblock组成 123456typedef struct &#123; unsigned tag; unsigned usedtime;&#125; block;block *cache; 其中usedtime是判断LRU cache行。初始值为0表示没有用过，相当于invalid。非零值越小代表越少使用，usedtime最大代表刚使用。 2 命令行参数解析首先对命令行参数进行解析 12345678910111213141516int getOpt(int argc,char **argv,int *s,int *E,int *b,int *verbose,char *tracefile)&#123; int oc; while((oc=getopt(argc,argv,"hvs:E:b:t:"))!=-1)&#123; switch(oc)&#123; case 'h': printHelpMenu();break; // print usage case 'v': *verbose=1;break; case 's': *s = atoi(optarg);break; case 'E': *E = atoi(optarg);break; case 'b': *b = atoi(optarg);break; case 't': strcpy(tracefile,optarg);break; default : printf("input error\n");break; &#125; &#125; return 0;&#125; 3 初始化cache然后初始化cache： E&lt;&lt;s 是cache行数也就是E*2^s 12cache = (block *)malloc(sizeof(block)* E&lt;&lt;s);memset(cache,0,sizeof(block)* E&lt;&lt;s); 4 读取文件参数fscanf读取trace文件中的指令、地址 12345678910fp = fopen (tracefile,"r");while(fscanf(fp,"%s%x,%d\n",op,&amp;addr,&amp;size) &gt; 0)&#123; if(verbose) printf("%s %x,%d ",op,addr,size); switch(op[0])&#123; case 'M': hit++; case 'L': case 'S': find(op[0],addr,size,++t); &#125;&#125; 5 数据访问获取tag和 set index 12unsigned tag = addr &gt;&gt;b &gt;&gt;s ;unsigned set_index = addr &gt;&gt; b &amp;((1&lt;&lt;s) -1); 找到对应的set 12block *cache_set = cache + E * set_index ; // set addressblock *eviction_block = cache_set; // LRU cacheline 进行数据查找，其中eviction_block表示查询过程中LRU的cache行，也就是usedtime最小的（但是非0）在一个set里面遍历cache行 如果usedtime！=0且tag匹配：hit 如果usedtime=0，是个空block，使用这个block：miss 如果usedtime！=0，tag不匹配，跟eviction_block.usedtime比较，如果时间更小，更新eviction_block=该cacheblock 如果循环结束，也就证明这个set的所有cache行都满了，就替换LRU cache行。 12345678910111213141516171819202122232425262728293031void find(char op, unsigned addr,unsigned size,int time)&#123; int i; unsigned tag = addr &gt;&gt;b &gt;&gt;s ; unsigned set_index = addr &gt;&gt; b &amp;((1&lt;&lt;s) -1); block *cache_set = cache + E * set_index ; // set address block *eviction_block = cache_set; // LRU cacheline for(i = 0;i&lt;E;i++)&#123; if(cache_set[i].usedtime&gt;0 &amp;&amp; cache_set[i].tag ==tag)&#123; //hit cache_set[i].usedtime = time; hit++; if(verbose) cacheStateOut(op,0); return; &#125; else if(!cache_set[i].usedtime)&#123; // empty block miss++; cache_set[i].tag = tag; cache_set[i].usedtime = time; if(verbose) cacheStateOut(op,1); return; &#125; else if(cache_set[i].usedtime &lt; eviction_block-&gt;usedtime) // !=tag , current block is older eviction_block = cache_set+i; &#125; miss ++; eviction ++; eviction_block-&gt;tag = tag; // replace sacrifice cacheline eviction_block-&gt;usedtime = time; if(verbose) cacheStateOut(op,2); return ;&#125; 测试 结果正确 Part B：Optimizing Matrix Transpose 优化矩阵转置要求优化对不同规格的矩阵的转置操作。 这里有三个矩阵，他们的miss次数要求分别如下： 32 * 32: 8 points if m &lt; 300, 0 points if m &gt; 600 64 × 64: 8 points if m &lt; 1300, 0 points if m &gt; 2000 61 × 67: 10 points if m &lt; 2000, 0 points if m &gt; 3000 要求 在tranc.c里进行完成 transpose_submit函数 最多使用12个int型变量，不能使用数组和malloc函数，不能使用位运算，不能改变矩阵A Tips 题目的cache参数如下：s=5，E=1，b=5 是一个直接映射高速缓存 32字节的Block size 有32个set 分析首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。 但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。 在该实验中，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，矩阵大小&gt;cache大小。主要需要解决以下两个问题： 直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。 所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。 为了解决第一个问题，我们需要仔细地考虑对于矩阵访问顺序；第二个问题，采用矩阵的分块（Blocking）方法降低miss 矩阵分块的目的在于将大的、不能完全加载进入缓存的大矩阵分块成小的、可以完全加载进入缓存的小矩阵块来处理。小矩阵块具有良好的局部性，性能显著增加。 但同时也要注意，分块使得程序的可阅读性大大降低，因此一般只在常用的库函数中采用分块优化。 32 * 32对于32 * 32的矩阵，一次可以装下8行的值。于是我们用8 * 8的分块来处理，增加缓存命中。 在32*32的情况中，一行是32个int，也就是4个block，所以cache可以存8行，由此可以推出映射冲突的情况：只要两个int之间相差8行的整数倍，那么读取这两个元素所在的block就会发生替换 但是转置的过程中这样的情况会发生吗？不会。图中的BCD三点对于A来说仅仅是行差了8K，这在转置中是不可能发生的！因为转置是将A[i][j]送到B[j][i]，不会有B[i+8k][j]的情况出现（不会在行相差8整数倍的块中，除非对角线上的块）。所以B在写入时miss概率也是1/8（强制失效）。 一个cache block只有32个Byte，可以装下8个int。这个cache可以容纳矩阵的前8行。所以分块采用8 * 8合适。先读取A的一行，然后放入B的一列。12个int变量，4个用来循环，其余8个用来存A中块的一行。 简单8 * 8分块： 12345678910111213if(M == 32)&#123; for (i = 0; i &lt; N; i+=8) &#123; for (j = 0; j &lt; M; j+=8) &#123; for(k = i ;k &lt; i + 8 &amp;&amp; k&lt;N;k++)&#123; for(l = j ; l &lt; j + 8 &amp;&amp; l &lt; M;l++) &#123; a0 = A[k][l]; B[l][k] = a0; &#125; &#125; &#125; &#125;&#125; 测试结果如下：超过了300miss，原因是对角线访问问题 对角线上的block访问miss问题： 矩阵A和矩阵B的同一行实际上被映射到了同一个cache block。当进行对角线的引用时，一定会发生缓存的冲突不命中。并且，由于A和B的元素时一个一个处理的，必定会造成反复多次的冲突不命中。（如下图A第一个元素读miss，B第一个元素存miss，A读第二个元素miss） 解决方法：通过变量一次性读出A的一整行，再存入B cache miss分析 （经过对角线块优化后）对于32 × 32的矩阵，总共存在1024次读(32*32)和1024次写。 对于非对角线的分块（总共12个），其缓存不命中率是1/8（仅强制不命中）； 对于对角线的分块（总共4个），A读缓冲不命中率1/8（仅强制不命中），B写不命中率1/4（强制失效 1/8 + 冲突不命中 1/8（A刚读的那行B写的时候会miss）） 因此，理论上优化之后的总缓存不命中数为2048 × 0.75 × 0.125 + 1024 × 0.25 × 0.125 + 1024 × 0.25 × 0.25 = 288次。最后跑出来的答案是287，非常接近。 123456789101112131415161718192021222324252627282930for (i = 0; i &lt; N; i+=8) &#123; for (j = 0; j &lt; M; j+=8) &#123; if(i == j)&#123; for(k = i ;k &lt; i + 8 &amp;&amp; k&lt;N;k++)&#123; a0 = A[k][j]; a1 = A[k][j+1]; a2 = A[k][j+2]; a3 = A[k][j+3]; a4 = A[k][j+4]; a5 = A[k][j+5]; a6 = A[k][j+6]; a7 = A[k][j+7]; B[j][k] = a0; B[j+1][k] = a1; B[j+2][k] = a2; B[j+3][k] = a3; B[j+4][k] = a4; B[j+5][k] = a5; B[j+6][k] = a6; B[j+7][k] = a7; &#125; &#125; else&#123; for(k = i ;k &lt; i + 8 &amp;&amp; k&lt;N;k++)&#123; for(l = j ; l &lt; j + 8 &amp;&amp; l &lt; M;l++) B[l][k] = A[k][l]; &#125; &#125; &#125; &#125; 测试结果：287miss 64 * 64这题难度是最大的，miss必须1300以下 首先考虑Cache中只能放4行A中的行，如果再用8×8的块，前面4行可以填入，后面4行会在Cache中发生冲突，导致miss次数增加。 如果只用4×4的块呢？那么每次Cache中放入8个int，我们却只用4个，浪费严重，这个方法最少也只能做到1677次miss。 题目说不能对A进行操作，但是可以对B进行操作！将B作为缓存使用 改进方法：将8 * 8 块再分成4个4 * 4的块进一步处理，经过改进，达到1171miss 首先对左上角和右上角进行处理： B左上角 = A左上角转置。B右上角=A右上角转置。 我们最后只需要把这部分平移到B的左下角就好。 现在B左上角完成 首先用四个变量存储A的左下角的一列。 再用四个变量存储B的右上角的一行。 把四个变量存储的A的左下角的一列移动到B右上角的一行 把四个变量存储的B的右上角的一行平移到B左下角的一列 B的右下角=A的右下角转置 关键的操作在第二步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051for (i = 0; i &lt; N; i += 8) &#123; for (j = 0; j &lt; M; j += 8) &#123; for (k = i; k &lt; i + 4; k++) &#123; a0 = A[k][j]; a1 = A[k][j + 1]; a2 = A[k][j + 2]; a3 = A[k][j + 3]; a4 = A[k][j + 4]; a5 = A[k][j + 5]; a6 = A[k][j + 6]; a7 = A[k][j + 7]; B[j][k] = a0; B[j + 1][k] = a1; B[j + 2][k] = a2; B[j + 3][k] = a3; B[j][k + 4] = a4; B[j + 1][k + 4] = a5; B[j + 2][k + 4] = a6; B[j + 3][k + 4] = a7; &#125; for (l = j + 4; l &lt; j + 8; l++) &#123; a4 = A[i + 4][l - 4]; // A left-down col a5 = A[i + 5][l - 4]; a6 = A[i + 6][l - 4]; a7 = A[i + 7][l - 4]; a0 = B[l - 4][i + 4]; // B right-above line a1 = B[l - 4][i + 5]; a2 = B[l - 4][i + 6]; a3 = B[l - 4][i + 7]; B[l - 4][i + 4] = a4; // set B right-above line B[l - 4][i + 5] = a5; B[l - 4][i + 6] = a6; B[l - 4][i + 7] = a7; B[l][i] = a0; // set B left-down col B[l][i + 1] = a1; B[l][i + 2] = a2; B[l][i + 3] = a3; B[l][i + 4] = A[i + 4][l]; B[l][i + 5] = A[i + 5][l]; B[l][i + 6] = A[i + 6][l]; B[l][i + 7] = A[i + 7][l]; &#125; &#125; &#125; 测试结果：1171miss 通过 61 * 67不规则的matrix，本质也是用分块来优化Cache的读写，但是不能找到比较显然的规律看出来间隔多少可以填满一个Cache。但是由于要求比较松，因此无需考虑处理对角线，直接进行转置操作，仅尝试换用不同的边长分块即可。16 × 16的分块已可以保证满分。 测试：1992miss &lt;2000 自动评分脚本输出： 12345678910111213141516171819202122232425262728zjw@ubuntu:~/Desktop/cachelab-handout$ ./driver.py Part A: Testing cache simulatorRunning ./test-csim Your simulator Reference simulatorPoints (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27Part B: Testing transpose functionRunning ./test-trans -M 32 -N 32Running ./test-trans -M 64 -N 64Running ./test-trans -M 61 -N 67Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 8.0 8 287Trans perf 64x64 8.0 8 1171Trans perf 61x67 10.0 10 1992 Total points 53.0 53 Referrencehttp://zxcpyp.com/csapp/2017/11/20/Cache-Lab#part-awriting-a-cache-simulator-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E6%A8%A1%E6%8B%9F%E5%99%A8]]></content>
      <categories>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>操作系统</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux网络协议栈结构]]></title>
    <url>%2F2018%2F01%2F30%2Flinux-network-stack-structure%2F</url>
    <content type="text"><![CDATA[网络栈层次结构如下图： 应用层 由应用程序提供。它通常是一个语义层，能够理解要传输的数据。例如，超文本传输协议（HTTP）就负责传输服务器和客户机之间对 Web 内容的请求与响应 传输层 负责端到端的通信（一台机子内部）-TCP、UDP 网络层 负责管理主机之间的通信 -IP 链路层 对物理层访问的设备驱动程序，如网卡驱动 物理层 主要提供各种连接的物理设备，如各种网卡，串口卡等 Linux网络协议栈结构 系统调用接口层 实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。 协议无关的接口层，就是SOCKET层，这一层的目的是屏蔽底层的不同协议（更准确的来说主要是TCP与UDP，当然还包括RAW IP， SCTP等），以便与系统调用层之间的接口可以简单，统一。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个SOCKET，这个SOCKET其实是一个巨大的sock结构，它和下面一层的网络协议层联系起来，屏蔽了不同的网络协议的不同，只把数据部分呈现给应用层（通过系统调用接口来呈现）。 网络协议实现层，毫无疑问，这是整个协议栈的核心。这一层主要实现各种网络协议，最主要的当然是IP，ICMP，ARP，RARP，TCP，UDP等。这一层包含了很多设计的技巧与算法，相当的不错。 与具体设备无关的驱动接口层，这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如open，close，init等，这一层可以屏蔽底层不同的驱动程序。 驱动程序层，这一层的目的就很简单了，就是建立与硬件的接口层。 1 系统调用接口层系统调用接口层实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。系统调用接口可以从两个角度进行描述：当用户进行网络调用时，通过系统调用接口多路复用到内核中。这最终作为 sys_socketcall(./net/socket.c)中的调用，然后进一步解复用到其预期目标的调用。 12345678SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)SYSCALL_DEFINE2(listen, int, fd, int, backlog)SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen) SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen)... 系统调用接口的另一个角度是使用正常的文件操作进行网络I/O。例如，典型的读写操作可以在网络socket（由文件描述符表示，就像普通文件）一样执行。因此，虽然存在一些特定于网络的操作（调用socket创建socket，调用connect将socket连接到目的地等等），但还是有一些适用于网络对象的标准文件操作，就像常规文件一样。 123456789static const struct file_operations socket_file_ops = &#123; .owner = THIS_MODULE, .llseek = no_llseek, .read_iter = sock_read_iter, .write_iter = sock_write_iter,struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname)&#123; file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE, &amp;socket_file_ops); 最后，系统调用接口提供了在用户空间应用程序和内核之间传输控制的手段。 2 协议无关接口层(Socket层)socket层是协议无关接口，其提供一组通用功能，以支持各种不同的协议。socket层不仅支持典型的TCP和UDP协议，还支持原始以太网和其他传输协议，如流控制传输协议（SCTP）。 网络栈使用socket通信。Linux中的socket结构struct sock是在include/net/sock.h中定义的。该大型结构包含特定socket的所有必需状态，包括socket使用的特定协议以及可能在其上执行的操作。它屏蔽了不同网络协议的区别，只把数据部分呈现给应用层（通过系统调用接口）。 12345678struct sock &#123; /* * Now struct inet_timewait_sock also uses sock_common, so please just * don't add nothing before this first member (__sk_common) --acme */ struct sock_common __sk_common; #define sk_prot __sk_common.skc_prot struct proto *sk_prot_creator; 网络子系统通过定义了其功能的特殊结构（即proto）来了解各个可用协议。每个协议维护一个名为proto（在linux/include/net/sock.h中找到）的结构。该结构定义了可以从socket层到传输层执行的特定socket操作（例如，如何创建socket，如何与socket建立连接，如何关闭socket等，由各自协议决定如何实现）。 12345678struct proto tcp_prot = &#123; .name = "TCP", .owner = THIS_MODULE, .close = tcp_close, .connect = tcp_v4_connect, .disconnect = tcp_disconnect, .accept = inet_csk_accept,... 3 网络协议层网络协议部分定义了可用的特定网络协议（如TCP，UDP等的具体实现）。这些是在linux/net/ipv4/af_inet.c中的inet_init函数的开头进行初始化的（因为TCP和UDP是协议inet族的一部分）。inet_init函数调用proto_register注册每个内置协议。proto_register在linux/net/core/sock.c中定义，除了将协议添加到活动协议列表之外，还可以根据需要分配一个或多个slab缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int proto_register(struct proto *prot, int alloc_slab)&#123; if (alloc_slab) &#123; ... &#125; ... mutex_lock(&amp;proto_list_mutex); list_add(&amp;prot-&gt;node, &amp;proto_list); assign_proto_idx(prot); mutex_unlock(&amp;proto_list_mutex);... static int __init inet_init(void)&#123; struct inet_protosw *q; struct list_head *r; int rc = -EINVAL; sock_skb_cb_check_size(sizeof(struct inet_skb_parm)); rc = proto_register(&amp;tcp_prot, 1); if (rc) goto out; rc = proto_register(&amp;udp_prot, 1); if (rc) goto out_unregister_tcp_proto;.. for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); arp_init(); ip_init(); tcp_init(); udp_init();...static struct inet_protosw inetsw_array[] =&#123; &#123; .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &amp;tcp_prot, .ops = &amp;inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, &#125;, 您可以通过linux/net/ipv4/中的文件tcp_ipv4.c，udp.c和raw.c中的proto结构来了解各自的协议。这些协议的proto结构体都按照类型和协议映射到inetsw_array，将内部协议映射到对应的操作(which maps the built-in protocols to their operations.)。结构体inetsw_array及其关系如图3所示。该数组中的每个协议都在初始化inetsw时，通过在inet_init调用inet_register_protosw来初始化。函数inet_init还初始化各种inet模块，如ARP，ICMP，IP模块，TCP和UDP模块。 图3. Internet协议数组的结构 Socket协议关联 回想下，当创建一个socket时，它定义了类型和协议，如 my_sock = socket( AF_INET, SOCK_STREAM, 0 )。其中AF_INET表示基于Internet地址族，SOCK_STREAM表示其为流式socket（如上所示inetsw_array）。 从图3可以看出， proto结构定义了特定传输协议的方法，而proto_ops结构定义了一般的socket方法。其他额外的协议可以通过调用inet_register_protosw将自己加入到inetsw协议开关机(protocol switch) 。例如，SCTP通过在linux/net/sctp/protocol.c中调用sctp_init来添加自己。 123456789101112131415struct proto_ops &#123; int family; struct module *owner; int (*release) (struct socket *sock); int (*bind) (struct socket *sock, struct sockaddr *myaddr, int sockaddr_len); int (*connect) (struct socket *sock, struct sockaddr *vaddr, int sockaddr_len, int flags); int (*socketpair)(struct socket *sock1, struct socket *sock2); int (*accept) (struct socket *sock, struct socket *newsock, int flags); ... 补充：prot/prot_ops二者有点相似，这里特意说明下：kernel的调用顺序是先inet(即prot_ops)，后protocal（即prot），inet层处于socket和具体protocol之间。下面以connect为例，ops即为prot_ops，它调用的connect是inet_listen，然后才是具体protocol的tcp_v4_connect。这一关系主要记录在inetsw_array中。 1234567891011121314151617181920SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen)&#123; struct socket *sock;... err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen, sock-&gt;file-&gt;f_flags); int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags, int is_sendmsg) &#123; struct sock *sk = sock-&gt;sk; switch (sock-&gt;state) &#123; case SS_UNCONNECTED: err = -EISCONN; if (sk-&gt;sk_state != TCP_CLOSE) goto out; err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len); if (err &lt; 0) goto out; socket的数据移动使用核心结构socket缓冲区（sk_buff）来进行。一个sk_buff 包含包数据(package data)，和状态数据（state data, 覆盖协议栈的多个层）。每个发送或接收的数据包都用一个sk_buff来表示。该sk_buff 结构是在linux/include/linux/skbuff.h中定义的，并在图4中示出。 图4. Socket缓冲区及其与其他结构的关系 如图所示，一个给定连接的多个sk_buff可以串联在一起。每个sk_buff标识了要发送数据包或从其接收数据包的设备结构（net_device *dev）。由于每个包都表示为一个sk_buff，数据包报头可方便地通过一组指针来寻址（th，iph以及mac（MAC报头）），内核会保证这块内存是连续的。由于sk_buff 是socket数据管理的核心，因此kernel已经创建了许多支撑函数来管理它们，包括sk_buff的创建和销毁，克隆和队列管理等函数。 总的来说，内核socket缓冲器设计思路是，某一的socket的sk_buff串链接在一起，并且sk_buff包括许多信息，包括到协议头的指针，时间戳（发送或接收数据包的时间）以及与数据包相关的网络设备。 4 设备无关接口层协议层下面是另一个无关的接口层，将协议连接到具有不同功能的各种硬件设备的驱动程序。该层提供了一组通用的功能，由较低级别的网络设备驱动程序使用，以允许它们使用较高级协议栈进行操作。 首先，设备驱动程序可以通过调用register_netdevice/unregister_netdevice将自己注册/去注册到内核。调用者首先填写net_device结构，然后将其传入register_netdevice进行注册。内核调用其init功能（如果有定义），执行许多健全检查，创建一个 sysfs条目，然后将新设备添加到设备列表（在内核中Active设备的链表）。你可以 在linux/include/linux/netdevice.h中找到net_device结构。各个函数在linux/net/core/dev.c中实现。 使用dev_queue_xmit函数将sk_buff从协议层发送到网络设备。dev_queue_xmit函数会将sk_buff添加到底层网络设备驱动程序最终要传输的队列中（网络设备在net_device或者sk_buff-&gt;dev中定义）。dev结构包含函数hard_start_xmit，保存用于启动sk_buff传输的驱动程序功能的方法。 通常使用netif_rx接收报文数据。当下级设备驱动程序接收到一个包（包含在新分配的sk_buff）时，内核通过调用netif_rx将sk_buff传递给网络层。然后，netif_rx通过调用netif_rx_schedule将sk_buff排队到上层协议的队列以进行进一步处理。您可以在linux/net/core/dev.c 中找到dev_queue_xmit和netif_rx函数。 最近，在内核中引入了一个新的应用程序接口（NAPI），以允许驱动程序与设备无关层（dev）进行交互。一些驱动程序使用NAPI，但绝大多数仍然使用较旧的帧接收接口（by a rough factor of six to one）。NAPI可以通过避免每个传入帧的中断，在高负载下得到更好的性能。 5 设备驱动程序网络栈的底部是管理物理网络设备的设备驱动程序。该层的设备示例包括串行接口上的SLIP驱动程序或以太网设备上的以太网驱动程序。 在初始化时，设备驱动程序分配一个net_device结构，然后用其必需的例程进行初始化。dev-&gt;hard_start_xmit就是其中一个例程，它定义了上层如何排队sk_buff用以传输。这个程序需要一个sk_buff。此功能的操作取决于底层硬件，但通常将sk_buff中的数据包移动到硬件环或队列。如设备无关层所述，帧接收使用该netif_rx接口或符合NAPI的网络驱动程序的netif_receive_skb。NAPI驱动程序对底层硬件的功能提出了约束。 在设备驱动程序配置其结构中的dev接口后，调用register_netdevice以后驱动就可以使用了。您可以在linux/drivers/net中找到网络设备专用的驱动程序。 ReferenceLinux网络栈解剖]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kernel</tag>
        <tag>网络协议栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP实验2:BombLab]]></title>
    <url>%2F2018%2F01%2F30%2FCSAPP-lab2-bomblab%2F</url>
    <content type="text"><![CDATA[实验简介​ Bomb LAB 目的是熟悉汇编。 ​ 一共有7关，六个常规关卡和一个隐藏关卡，每次我们需要输入正确的拆弹密码才能进入下一关，而具体的拆弹密码藏在汇编代码中。实验中的bomb实际上是一个程序的二进制文件，该程序由一系列phase组成，每个phase需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印BOOM!!! ​ 完成整个实验的思路是通过objdump对bomb进行反编译（objdump -d bomb &gt; bomb.txt），获取所有的汇编代码。提取每个阶段对应的代码并借助gdb进行分析，逐一拆弹。 Github地址：Bomb Lab 准备汇编复习 类型 语法 例子 备注 常量 符号$ 开头 $-42, $0x15213 一定要注意十进制还是十六进制 寄存器 符号 % 开头 %esi, %rax 可能存的是值或者地址 内存地址 括号括起来 (%rbx), 0x1c(%rax), 0x4(%rcx, %rdi, 0x1) 括号实际上是去寻址的意思 一些汇编语句与实际命令的转换： 指令 效果 mov %rbx, %rdx rdx = rbx add (%rdx), %r8 r8 += value at rdx mul $3, %r8 r8 *= 3 sub $1, %r8 r8-- lea (%rdx, %rbx, 2), %rdx rdx = rdx + rbx*2 比较与跳转是拆弹的关键，基本所有的字符判断就是通过比较来实现的，比方说 cmp b,a 会计算 a-b 的值，test b, a 会计算 a&amp;b，注意运算符的顺序。例如 12cmpl %r9, %r10jg 8675309 等同于 if %r10 &gt; %r9, jump to 8675309 各种不同的跳转： 指令 效果 指令 效果 jmp Always jump ja Jump if above(unsigned &gt;) je/jz Jump if eq / zero jae Jump if above / equal jne/jnz Jump if !eq / !zero jb Jump if below(unsigned &lt;) jg Jump if greater jbe Jump if below / equal jge Jump if greater / eq js Jump if sign bits is 1(neg) jl Jump if less jns Jump if sign bit is 0 (pos) jle Jump if less / eq x x 举几个例子 12cmp $0x15213, %r12jge deadbeef 若 %r12 &gt;= 0x15213，则跳转到 0xdeadeef 12cmp %rax, %rdijae 15213b 如果 %rdi 的无符号值大于等于 %rax，则跳转到 0x15213b 12test %r8, %r8jnz (%rsi) 如果 %r8 &amp; %r8 不为零，那么跳转到 %rsi 存着的地址中。 x86-64寄存器规则： 默认函数的第一个参数是%rdi 第二个参数%rsi 第三个参数%rdx 反汇编12345678910# 检查符号表# 然后可以寻找跟 bomb 有关的内容objdump -t bomb | less # 反编译# 搜索 explode_bombobjdump -d bomb &gt; bomb.txt# 显示所有字符strings bomb | less GDB12345678910111213141516171819gdb bombhelp # 获取帮助break explode_bomb # 设置断点break phase_1run # 开始运行disas # 反汇编info registers # 查看寄存器内容print $rsp # 打印指定寄存器stepi # （单步跟踪进入）执行一行代码，如果函数调用，则进入该函数 可以使用s简化n # （单步跟踪） 执行一行代码，如果函数调用，则一并执行x/4wd $rsp # 检查寄存器或某个地址，查看内存地址里面的内容（常用） 用 ctl+c 可以退出，每次进入都要设置断点（保险起见），炸弹会用 sscanf 来读取字符串，了解清楚到底需要输入什么。 Phase 1123456789Dump of assembler code for function phase_1: 0x0000000000400ee0 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400ee4 &lt;+4&gt;: mov $0x402400,%esi 0x0000000000400ee9 &lt;+9&gt;: callq 0x401338 &lt;strings_not_equal&gt; 0x0000000000400eee &lt;+14&gt;: test %eax,%eax 0x0000000000400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt; 0x0000000000400ef2 &lt;+18&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400ef7 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400efb &lt;+27&gt;: retq 先 gdb bomb，然后设置断点 break explode_bomb 和 break phase_1 这段代码还是挺好理解的，保存Stack pointer,将$0x402400传给%esi,调用位于0x401338的strings_not_equal函数，比较%eax是否为0，不为零则调用explode_bomb函数，为零则返回设置断点 phase_1和explode_bomb，输入命令r运行会在断点处停下，此时随便输入一个字符串用于测试“abcd”，然后disas查看反汇编代码：=&gt;箭号为当前运行的位置 查看寄存器内容 info register，eax就是rax的低位用print $eax 打印出来，是一个地址用x/s $eax，查看出地址里的内容，发现是输入字符串 用stepi 逐步执行，执行完 mov 之后，把地址中的内容传到%esi中，用print查看！得到字符串，这就是第一关的答案。退出后新建一个文本 touch sol.txt，方便之后输入 Phase 2这次我们有了第一关的答案，进入gdb后设置好断点，和命令参数。 试运行，在phase_1停住，然后continue，答案正确，触发 phase_2的断点，这次输入abc 反汇编Phase2部分的代码 12345678910111213141516171819202122232425262728(gdb) disasDump of assembler code for function phase_2:=&gt; 0x0000000000400efc &lt;+0&gt;: push %rbp 0x0000000000400efd &lt;+1&gt;: push %rbx 0x0000000000400efe &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400f02 &lt;+6&gt;: mov %rsp,%rsi 0x0000000000400f05 &lt;+9&gt;: callq 0x40145c &lt;read_six_numbers&gt; #读取6个数字 0x0000000000400f0a &lt;+14&gt;: cmpl $0x1,(%rsp) #第一个数字和1比较，不相等则爆炸 0x0000000000400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt; #相等，跳转到&lt;52&gt; 0x0000000000400f10 &lt;+20&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f15 &lt;+25&gt;: jmp 0x400f30 &lt;phase_2+52&gt; 0x0000000000400f17 &lt;+27&gt;: mov -0x4(%rbx),%eax #将(%rbx)前一个数字存到%eax 0x0000000000400f1a &lt;+30&gt;: add %eax,%eax #%eax数字加倍 0x0000000000400f1c &lt;+32&gt;: cmp %eax,(%rbx) #%eax和(%rbx)比较，=(%rbx)则跳过爆炸 0x0000000000400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt; 0x0000000000400f20 &lt;+36&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f25 &lt;+41&gt;: add $0x4,%rbx #(%rbx)地址+4，下一个数字 0x0000000000400f29 &lt;+45&gt;: cmp %rbp,%rbx #比较%rbp和%rbx，循环是否结束 0x0000000000400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt; 0x0000000000400f2e &lt;+50&gt;: jmp 0x400f3c &lt;phase_2+64&gt; 0x0000000000400f30 &lt;+52&gt;: lea 0x4(%rsp),%rbx #指向第2个数字，%rbx保存第2个数字地址 0x0000000000400f35 &lt;+57&gt;: lea 0x18(%rsp),%rbp #0x18 = 0x0 + 4 bit * 6 个数字 0x0000000000400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt; 0x0000000000400f3c &lt;+64&gt;: add $0x28,%rsp 0x0000000000400f40 &lt;+68&gt;: pop %rbx 0x0000000000400f41 &lt;+69&gt;: pop %rbp 0x0000000000400f42 &lt;+70&gt;: retq End of assembler dump. 根据Phase1,很敏感的会发现movl $0x4025c3, %esi这行。通过之前一样的方法，得到0x4025c3内存里的字符串 12(gdb) x/s $esi0x4025c3: &quot;%d %d %d %d %d %d 再根据bomb[0x40148a] &lt;+46&gt;: callq 0x400bf0 ; symbol stub for: __isoc99_sscanf这句，猜一下，立马就能联想到scanf(&quot;%d %d %d %d %d %d&quot;,a,b,c,d,e,f);，也就是说，输入的格式已经确定了。 解读出循环中，从1开始，是一个等比数列，公比为2。1 2 4 8 16 32 Phase 312345678910111213141516171819202122232425262728293031323334353637Dump of assembler code for function phase_3:=&gt; 0x0000000000400f43 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx 0x0000000000400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx 0x0000000000400f51 &lt;+14&gt;: mov $0x4025cf,%esi 0x0000000000400f56 &lt;+19&gt;: mov $0x0,%eax 0x0000000000400f5b &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt; # 调用函数sscanf 0x0000000000400f60 &lt;+29&gt;: cmp $0x1,%eax # 说明%eax&gt;1，即输入参数个数&gt;1，跳过爆炸 0x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt; 0x0000000000400f65 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp) # 说明第一个数0x8(%rsp)&lt;7，否则爆炸 0x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt; 0x0000000000400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax # 第一个数存到%eax 0x0000000000400f75 &lt;+50&gt;: jmpq *0x402470(,%rax,8) # 跳转，起始地址0x402470+ rax*8（第一个数）内数据所指行数 0x0000000000400f7c &lt;+57&gt;: mov $0xcf,%eax # case0： 0xcf = 207 0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400f83 &lt;+64&gt;: mov $0x2c3,%eax # case2: 0x2c3 0x0000000000400f88 &lt;+69&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400f8a &lt;+71&gt;: mov $0x100,%eax 0x0000000000400f8f &lt;+76&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400f91 &lt;+78&gt;: mov $0x185,%eax 0x0000000000400f96 &lt;+83&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400f98 &lt;+85&gt;: mov $0xce,%eax 0x0000000000400f9d &lt;+90&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400f9f &lt;+92&gt;: mov $0x2aa,%eax 0x0000000000400fa4 &lt;+97&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400fa6 &lt;+99&gt;: mov $0x147,%eax 0x0000000000400fab &lt;+104&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400fad &lt;+106&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400fb2 &lt;+111&gt;: mov $0x0,%eax 0x0000000000400fb7 &lt;+116&gt;: jmp 0x400fbe &lt;phase_3+123&gt; 0x0000000000400fb9 &lt;+118&gt;: mov $0x137,%eax # 1 0x137 0x0000000000400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax # 比较第2个数 0x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt; 0x0000000000400fc4 &lt;+129&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000400fc9 &lt;+134&gt;: add $0x18,%rsp # rsp+24 0x0000000000400fcd &lt;+138&gt;: retq 查看地址内的内容，为输入格式，需要输入两个数，后面的 cmp $0x1,%eax 表明输入参数大于1个， 12(gdb) x/s 0x4025cf0x4025cf: "%d %d" 看到多个分片语句，反应类似siwtch语句，所以第一个数字是用来进行跳转的 p/x 命令查看跳转表，可以看到 用 p/x可以看跳转表的地址，但是没有x/s直观。用 x/s 命令可以查看跳转表，如case0，对应的就是&lt;phase_3+57&gt;，内容是$0xcf,%eax ，所以（0，207）就是一组输入，同理还可以得到其他的解 （0，207） （1，311） （2，707） （3,256） （4，389） （5，206） （6，682） （7，327） 123456789101112131415161718(gdb) x/s *(0x402470)0x400f7c &lt;phase_3+57&gt;: "\270", &lt;incomplete sequence \317&gt; //0:0xcf(gdb) x/s *(0x402470+8)0x400fb9 &lt;phase_3+118&gt;: "\270\067\001" //1:0x137 (gdb) x/s *(0x402470+16)0x400f83 &lt;phase_3+64&gt;: "\270\303\002" //2:0x2c3(gdb) x/s *(0x402470+24)0x400f8a &lt;phase_3+71&gt;: "\270" //3:0x100(gdb) x/s *(0x402470+32):0x400f91 &lt;phase_3+78&gt;: "\270\205\001" //4:0x185(gdb) x/s *(0x402470+40)0x400f98 &lt;phase_3+85&gt;: "\270", &lt;incomplete sequence \316&gt; //5:0xce(gdb) x/s *(0x402470+48)0x400f9f &lt;phase_3+92&gt;: "\270\252\002" //6:0x2aa(gdb) x/s *(0x402470+56)0x400fa6 &lt;phase_3+99&gt;: "\270G\001" //7:0x147(gdb) x/s *(0x402470+64)0x7564616d: &lt;error: Cannot access memory at address 0x7564616d&gt; 输入一组解，成功 Phase 4123456789101112131415161718192021222324Dump of assembler code for function phase_4:=&gt; 0x000000000040100c &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401010 &lt;+4&gt;: lea 0xc(%rsp),%rcx 0x0000000000401015 &lt;+9&gt;: lea 0x8(%rsp),%rdx 0x000000000040101a &lt;+14&gt;: mov $0x4025cf,%esi //%d %d 0x000000000040101f &lt;+19&gt;: mov $0x0,%eax 0x0000000000401024 &lt;+24&gt;: callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 0x0000000000401029 &lt;+29&gt;: cmp $0x2,%eax // 参数数量为2 0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt; 0x000000000040102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp) // 第一个参数&lt;=14 0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt; 0x0000000000401035 &lt;+41&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x000000000040103a &lt;+46&gt;: mov $0xe,%edx //14 0x000000000040103f &lt;+51&gt;: mov $0x0,%esi //0 0x0000000000401044 &lt;+56&gt;: mov 0x8(%rsp),%edi //a1 0x0000000000401048 &lt;+60&gt;: callq 0x400fce &lt;func4&gt; //把a1,0,14分别作为参数传到func4 0x000000000040104d &lt;+65&gt;: test %eax,%eax //%eax！=0，爆炸，所以fun4调用后要使得%eax=0 0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt; 0x0000000000401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp) //第二个数据为0 0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt; 0x0000000000401058 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x000000000040105d &lt;+81&gt;: add $0x18,%rsp 0x0000000000401061 &lt;+85&gt;: retq End of assembler dump. 跟上题一样，先看看可疑的0x4025cf中的内容 看到输入格式和上题一样都是两个整数。在执行 callq 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 指令后，返回值（参数数量）存储于%eax，然后判断%eax是否等于2，若不等于则爆炸。否则执行cmpl $0xe,0x8(%rsp) ，该指令将输入的第一个数和常数0xe进行比较，如果第一个数&gt;0xe，拆弹失败。否则跳转到0x40103a执行 1230x000000000040103a &lt;+46&gt;: mov $0xe,%edx //140x000000000040103f &lt;+51&gt;: mov $0x0,%esi //00x0000000000401044 &lt;+56&gt;: mov 0x8(%rsp),%edi //a1 这三条指令用来设置func4的参数，根据x86-64寄存器使用规范，第1,2,3,个参数分别存储在寄存器%edi，%esi，%edx中在查看func4对应的代码之前，先观察执行callq 400fce &lt;func4&gt;指令之后phase_4的操作：test %eax,%eax指令检查%eax的值是否等于0，如果不等于0，则会引爆炸弹，否则执行指令cmpl $0x0,0xc(%rsp)，该指令将输入的第二个数与0做比较，如果相等，那么phase_4正常退出，拆弹成功。因此，phase_4的第二个输入值即为0。经过以上的分析，可以意识到phase_4的核心目标在于要让func4执行后，%eax的值等于0，这取决于输入的第一个数。接着需要分析func4执行的操作，其对应代码如下所示。 反汇编func4 12345678910111213141516171819202122230000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp //x = %edi y = %esi z = %edx 400fd2: 89 d0 mov %edx,%eax // 400fd4: 29 f0 sub %esi,%eax //t = z-y t = %eax 400fd6: 89 c1 mov %eax,%ecx // 400fd8: c1 e9 1f shr $0x1f,%ecx //k=t&gt;&gt;31 t = %ecx 400fdb: 01 c8 add %ecx,%eax //t = t+k 400fdd: d1 f8 sar %eax //t&gt;&gt;1 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2:(+0x24) b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007:(+0x39) 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 在分析func4之前，不要忘了传递到func4的三个参数分别存储于寄存器%edi、%esi和%edx，其值分别为x(输入的第一个数)、0和14。在0x400fe9处执行了指令callq 400fce &lt;func4&gt;，因此func4很可能是个递归函数，我们将func4翻译成等价的C代码，如下所示。 123456789101112131415161718void func4(int x, int y, int z) &#123; int t = z - y; int k = t &gt;&gt; 31; t = (t + k) &gt;&gt; 1; k = t + y; if(k &lt;= x) &#123; t = 0; if(k &gt;= x) &#123; return; &#125;else &#123; y = k + 1; func4(x, y, z); &#125; &#125;else &#123; z = k - 1; func4(x, y, z); &#125;&#125; func4的目的是要让函数退出后%eax的值为0，而在0x400ff2处mov $0x0,%eax显示的将%eax的值设置为0，该指令对应于C代码中的t = 0。并且，func4执行递归的退出条件为k == x，其中x对应于输入的第一个数，而k则可以通过一系列计算得到，由于y = 0且z = 14，易知k = 7，因此输入的第一个数即为7。将字符串7 0作为phase_4的输入，拆弹成功，如下图所示。 Phase 512345678910111213141516171819202122232425262728293031323334353637383940Dump of assembler code for function phase_5:=&gt; 0x0000000000401062 &lt;+0&gt;: push %rbx 0x0000000000401063 &lt;+1&gt;: sub $0x20,%rsp 0x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx //把字符串起始地址保存在%rbx中 0x000000000040106a &lt;+8&gt;: mov %fs:0x28,%rax 0x0000000000401073 &lt;+17&gt;: mov %rax,0x18(%rsp) 0x0000000000401078 &lt;+22&gt;: xor %eax,%eax //%eax清零 0x000000000040107a &lt;+24&gt;: callq 0x40131b &lt;string_length&gt; 0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax //字符串输入长度=6 0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt; 0x0000000000401084 &lt;+34&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt; 0x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx // 0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp) 0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx 0x0000000000401096 &lt;+52&gt;: and $0xf,%edx 0x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx 0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1) 0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax 0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax 0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt; 0x00000000004010ae &lt;+76&gt;: movb $0x0,0x16(%rsp) 0x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi //字符串 flyers 0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi 0x00000000004010bd &lt;+91&gt;: callq 0x401338 &lt;strings_not_equal&gt; 0x00000000004010c2 &lt;+96&gt;: test %eax,%eax 0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt; 0x00000000004010c6 &lt;+100&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x00000000004010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1) 0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt; 0x00000000004010d2 &lt;+112&gt;: mov $0x0,%eax 0x00000000004010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt; 0x00000000004010d9 &lt;+119&gt;: mov 0x18(%rsp),%rax 0x00000000004010de &lt;+124&gt;: xor %fs:0x28,%rax 0x00000000004010e7 &lt;+133&gt;: je 0x4010ee &lt;phase_5+140&gt; 0x00000000004010e9 &lt;+135&gt;: callq 0x400b30 &lt;__stack_chk_fail@plt&gt; 0x00000000004010ee &lt;+140&gt;: add $0x20,%rsp 0x00000000004010f2 &lt;+144&gt;: pop %rbx 0x00000000004010f3 &lt;+145&gt;: retq End of assembler dump. 根据x86-64寄存器使用规范，%rdi寄存器存储的是第一个参数的值，由于输入的是字符串，因此%rdi存储的应该是输入字符串的起始地址。0x401067处的指令mov %rdi,%rbx将字符串起始地址保存在%rbx中，即%rbx为基址寄存器。指令xor %eax,%eax的作用是将%eax清零，接着调用string_length函数获取输入字符串的长度，并将长度值（返回值）存储于%eax。指令cmp $0x6,%eax将string_length的返回值与常数6作比较，若不相等则会引爆炸弹，由此可以得知，phase_5的输入字符串长度应该等于6。 12(gdb) x/s 0x40245e0x40245e: "flyers" 待比较的字符串为flyers，且长度也为6。所以，接下来的关键任务是需要对循环操作进行分析，理解该循环操作对输入字符串做了哪些操作。提取循环操作的代码，如下所示。 12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx40108f: 88 0c 24 mov %cl,(%rsp)401092: 48 8b 14 24 mov (%rsp),%rdx401096: 83 e2 0f and $0xf,%edx401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1)4010a4: 48 83 c0 01 add $0x1,%rax4010a8: 48 83 f8 06 cmp $0x6,%rax4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 由于%rbx存储的是输入字符串的起始地址，%rax初始化为0，其作用等价于下标，因此movzbl (%rbx,%rax,1),%ecx指令的作用是将字符串的第%rax个字符存储于%ecx，movzbl意味做了零扩展。接着，mov %cl,(%rsp)指令取%ecx的低8位，即一个字符的大小，通过内存间接存储至%rdx中。and $0xf,%edx指令将%edx的值与常数0xf进行位与，由指令movzbl 0x4024b0(%rdx),%edx可知，位与后的值将会作为偏移量，以0x4024b0为基址，将偏移后的值存储至%edx。最后，指令mov %dl,0x10(%rsp,%rax,1)以%edx低8位的值作为新的字符，对原有字符进行替换。综上，phase_5遍历输入字符串的每个字符，将字符的低4位作为偏移量，以0x4024b0为起始地址，将新地址对应的字符替换原有字符，最终得到flyers字符串。打印0x4024b0处的内容，如下图所示。 例如，如果要得到字符f，那么偏移量应为9，二进制表示为1001，通过查找ASCII表，可知字符i的ASCII编码为01101001，满足要求。（或者字符y（01111001）所以解不唯一）剩余5个字符采用同样的策略可以依次求得，最终，phase_5的输入字符串的一个解为ionefg。 Phase 6phase_6的代码很长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107Dump of assembler code for function phase_6:=&gt; 0x00000000004010f4 &lt;+0&gt;: push %r14 0x00000000004010f6 &lt;+2&gt;: push %r13 0x00000000004010f8 &lt;+4&gt;: push %r12 0x00000000004010fa &lt;+6&gt;: push %rbp 0x00000000004010fb &lt;+7&gt;: push %rbx 0x00000000004010fc &lt;+8&gt;: sub $0x50,%rsp 0x0000000000401100 &lt;+12&gt;: mov %rsp,%r13 0x0000000000401103 &lt;+15&gt;: mov %rsp,%rsi 0x0000000000401106 &lt;+18&gt;: callq 0x40145c &lt;read_six_numbers&gt; 0x000000000040110b &lt;+23&gt;: mov %rsp,%r14 # %r14存储数组起始地址 0x000000000040110e &lt;+26&gt;: mov $0x0,%r12d # 将%r12d初始化为0#################### Section 1:确认数组中所有的元素小于等于6且不存在重复值 ################### 0x0000000000401114 &lt;+32&gt;: mov %r13,%rbp # %r13和%rbp存储数组某个元素的地址，并不是第1个元素，意识到这点需要结合0x40114d处的指令 0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax 0x000000000040111b &lt;+39&gt;: sub $0x1,%eax # 将%eax的值减1 0x000000000040111e &lt;+42&gt;: cmp $0x5,%eax # 将%eax的值与常数5做比较 0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt; 0x0000000000401123 &lt;+47&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000401128 &lt;+52&gt;: add $0x1,%r12d # 如果%eax的值小于等于5，%r12d加1 0x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d # 将%r12d与常数6做比较 0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt; 0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx # %ebx起了数组下标的作用# 用于判断数组6个数是否存在重复值，若存在，引爆炸弹 0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax # 将数组下标存储至%rax 0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax # 将下一个数存储至%eax 0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp) # 将第1个数与%eax的值(当前数)做比较 0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt; # 若相等，引爆炸弹 0x0000000000401140 &lt;+76&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx # 数组下标加1 0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx # 判断数组下标是否越界(&lt;=5) 0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 0x000000000040114d &lt;+89&gt;: add $0x4,%r13 # %r13存储数组下一个数的地址 0x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt;####################################### Section 1 end ###################################################### Section 2：用7减去数组的每个元素，并将相减后的元素替换原有元素 #################---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi # 0x18(%rsp)是数组的边界地址：0x18 = 24 0x0000000000401158 &lt;+100&gt;: mov %r14,%rax # 将数组起始地址存储于%rax 0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx 0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx # %edx = 7 0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx # %edx = 7 - 数组元素 0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax) # 用相减后的元素(%edx)替换原有元素 0x0000000000401166 &lt;+114&gt;: add $0x4,%rax # %rax存储数组下一个元素的地址 0x000000000040116a &lt;+118&gt;: cmp %rsi,%rax # 判断是否越界 0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt;####################################### Section 2 end ################################################################ Section 3：根据输入数组重排结构体数组 ############################## 0x000000000040116f &lt;+123&gt;: mov $0x0,%esi # 将%esi初始化为0，作为数组下标 0x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt; 0x0000000000401176 &lt;+130&gt;: mov 0x8(%rdx),%rdx # 0x8(%rdx)为下一个元素的地址 0x000000000040117a &lt;+134&gt;: add $0x1,%eax 0x000000000040117d &lt;+137&gt;: cmp %ecx,%eax # %ecx存储了数组当前值(第%esi个元素) 0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt; 0x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt; 0x0000000000401183 &lt;+143&gt;: mov $0x6032d0,%edx # %edx存储结构体数组第1个元素的地址 0x0000000000401188 &lt;+148&gt;: mov %rdx,0x20(%rsp,%rsi,2) # %rsi的初始值为0；该指令的作用是将结构体数组的第%ecx个元素的地址存储在内存的某个位置(以%rsp + 0x20为基地址，%rsi为偏移量) 0x000000000040118d &lt;+153&gt;: add $0x4,%rsi # 增加偏移量 0x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi 0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 0x0000000000401197 &lt;+163&gt;: mov (%rsp,%rsi,1),%ecx # %ecx存储数组第%esi个元素 0x000000000040119a &lt;+166&gt;: cmp $0x1,%ecx # 将数组第%esi个元素与常数1做比较 0x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt; # 实际上不会小于1，如果数组的第1个元素等于1，那么跳转至0x401183处 0x000000000040119f &lt;+171&gt;: mov $0x1,%eax 0x00000000004011a4 &lt;+176&gt;: mov $0x6032d0,%edx # %edx存储结构体数组第1个元素的地址 0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt;####################################### Section 3 end ############################################################### Section 4：修改结构体数组元素的next域值 ############################# 0x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx # %rbx存储地址数组的第1个元素的值 0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax # %rax存储地址数组的第2个元素的地址 0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi 0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx # %rcx存储地址数组的第1个元素的值# 下面用i和i+1来表示元素位置 0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx # %rdx存储地址数组的第i+1个元素的值 0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx) # 把第i+1和元素的值存储于第i个结构体元素的next域中，next域的地址为0x8(%rcx)的值 0x00000000004011c4 &lt;+208&gt;: add $0x8,%rax 0x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax 0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt; 0x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx 0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt;####################################### Section 4 end ############################################################### Section 5：判断结构体数组是否是递减序列 ############################# 0x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx) 0x00000000004011da &lt;+230&gt;: mov $0x5,%ebp 0x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax 0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax 0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx) 0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt; 0x00000000004011e9 &lt;+245&gt;: callq 0x40143a &lt;explode_bomb&gt; 0x00000000004011ee &lt;+250&gt;: mov 0x8(%rbx),%rbx 0x00000000004011f2 &lt;+254&gt;: sub $0x1,%ebp 0x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt;####################################### Section 5 end ###################################### 0x00000000004011f7 &lt;+259&gt;: add $0x50,%rsp 0x00000000004011fb &lt;+263&gt;: pop %rbx 0x00000000004011fc &lt;+264&gt;: pop %rbp 0x00000000004011fd &lt;+265&gt;: pop %r12 0x00000000004011ff &lt;+267&gt;: pop %r13 0x0000000000401201 &lt;+269&gt;: pop %r14 0x0000000000401203 &lt;+271&gt;: retq End of assembler dump. 分析清楚phase_6非常需要耐心，我将phase_6划分为5个Section，每个Section完成特定的功能，详细的注释直接附到了相关代码。前两个Section不难理解：Section 1确保输入数组的值的范围在1 ~ 6且不存在重复值；Section 2用7减去输入数组的每个元素，相当于求补。Section 3中出现了一个常数地址，使用gdb将该地址存储的内容打印出来，如下图所示。 可以意识到这其实是一个链表数据结构，链表的节点由3部分组成：value 1、value 2和一个地址值(next域，指向下一个节点)。Section 3根据我们输入的数组，按照数组元素的值将对应结构体数组中的元素的首地址存储到内存的某个位置(mov %rdx,0x20(%rsp,%rsi,2))。例如，假设输入数组为[3, 4, 5, 6, 1, 2]，那么Section 3首先会将结构体数组的第3个元素的地址存储到0x20(%rsp,%rsi,2)处，接着将结构体数组的第4个元素……依次类推。Section 4根据Section 3构建的地址数组，修改结构体数组的next域的值，实现单链表的排序操作。Section 5进行验证，要求单链表递减排序，若满足要求，那么拆弹成功。 综上，根据已有的结构体数组以及phase_6的操作，若要实现单链表的递减排序，应将第3个节点放在第1位，将第4个节点放在第2位……最终得到序列：[3, 4, 5, 6, 1, 2]。不要忘记Section 2中的求补操作，所以phase_6的输入序列应该为[4, 3, 2, 1, 6, 5]。 reference 1.http://wdxtub.com/2016/04/16/thick-csapp-lab-2/]]></content>
      <categories>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>操作系统</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Soft-RoCE环境搭建]]></title>
    <url>%2F2018%2F01%2F27%2FSoft-RoCE-setup%2F</url>
    <content type="text"><![CDATA[Soft-RoCE是RoCE协议的软件栈版本，可以在普通网卡上搭建RDMA环境 先确保安装以下软件： 1234567sudo apt-get install gitsudo apt-get install libncurses5-devsudo apt-get install libssl-devsudo apt-get install libibverbs1 libibcm1libibcm-dev ibverbs-utils libibverbs-dev sudo apt-get install libibverbs1librdmacm-dev librdmacm1 rdmacm-utils sudo apt-get install openssh-serversudo apt-get install libswitch-perl Install KernelClone kernel 1git clone https://github.com/SoftRoCE/rxe-dev.git 切换到 ‘rxe_submission_v18’ 分支 1git checkout rxe_submission_v18 进入到rxe-dev 目录 cd rxe-dev 1cp /boot/config-$(uname –r) .config 切换到root用户权限，运行make menuconfig ，出现选择界面。（在使用 make menuconfig 之前需要安装ncurse-devel 输入”/“ ，然后输入RDMA_RXE，按下 enter，会查找有关RDMA_RXE 的选择项. 输入数字 1，就会选择到RDMA_RXE 的设置，输入”M” ，选中 RDMA 的配置. 然后 vi.config 来确认CONFIG_RDMA_RXE 为 m ，CONFIG_INFINIBAND_ADDR_TRANS和CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS 为 y 建议在Generalsetup –&gt;Local version中填写一个名称，便于之后编译出的内核与其他内核区别开。 ##编译内核 1234make –j 32make modules_installmake installmake headers_install INSTALL_HDR_PATH=/usr 上述步骤如果遇到permission denied，命令前加上sudo 再执行。且上述命令均应在源码目录即 /rxe-dev 下执行 确认新的内核是否在grub引导中，可以查看 /boot/grub/grub.conf 用新内核启动后查看内核版本号和rdma_rxe模块 1234567891011121314kevin@ubuntu:~$ uname -r4.7.0-rc3kevin+kevin@ubuntu:~$ modinfo rdma_rxefilename: /lib/modules/4.7.0-rc3kevin+/kernel/drivers/infiniband/hw/rxe/rdma_rxe.koversion: 0.2license: DualBSD/GPLdescription: SoftRDMA transportauthor: BobPearson, Frank Zago, John Groves, Kamal Heibsrcversion: 85F0433D44A5DAF81FBFE5Cdepends: ib_core,ip6_udp_tunnel,udp_tunnelintree: Yvermagic: 4.7.0-rc3kevin+ SMP mod_unload modversions parm: add:Create RXE device over network interfaceparm: remove:Remove RXE device over network interface Install user space library (librxe)安装以下的包 1234567libswitch-perllibibverbslibibverbs-devellibibverbs-utilslibrdmacmlibrdmacm-devellibrdmacm-utils 编译安装 install userspace library librxe: 12345git clone https://github.com/SoftRoCE/librxe-dev.gitcd librxe-dev./configure --libdir=/usr/lib64/ --prefix=makemake install （./configure --libdir=/usr/lib64/ --prefix= 中如果路径只有/lib 就用/lib） Configure Soft-RoCE (RXE)1234kevin@ubuntu:~$ rxe_cfg statusrxe modules not loaded Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens33 yes e1000 1500 192.168.188.132 Load ib_rxe kernel module, using the rxe_cfg script included in the librxe RPM: 1234kevin@ubuntu:~$ sudo rxe_cfg startsh: echo: I/O error Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens33 yes e1000 1500 192.168.188.132 rxe0 1024 To verify RXE kernel module is loaded, run: 12345kevin@ubuntu:~$ lsmod |grep rdma_rxerdma_rxe 102400 0ip6_udp_tunnel 16384 1 rdma_rxeudp_tunnel 16384 1 rdma_rxeib_core 208896 6 rdma_cm,ib_cm,iw_cm,ib_uverbs,rdma_rxe,rdma_ucm Create RXE device over network interface (e.g. ens33): 1sudo rxe_cfg add ens33 Check the status of rxe_cfg, make sure that rxe0 was added under RDEV (rxe device).It is also possible to check the ibv_devices command. 1234567kevin@ubuntu:~$ rxe_cfg Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens33 yes e1000 1500 192.168.188.132 rxe0 1024 (3) kevin@ubuntu:~$ ibv_devices device node GUID ------ ---------------- rxe0 020c29fffebd5e22 Test connectivity. On the server: 1ibv_rc_pingpong -d rxe0 -g 0 On the client: 1ibv_rc_pingpong -d rxe0 -g 0 &lt;server_management_ip&gt; e.g Client: 123kevin@ubuntu:~$ ibv_rc_pingpong -g 0 -d rxe0 -i 1 192.168.188.129 local address: LID 0x0000, QPN 0x000011, PSN 0x2cd726, GID fe80::20c:29ff:febd:5e22 remote address: LID 0x0000, QPN 0x000011, PSN 0x767a62, GID fe80::20c:29ff:fe44:4345 Testrpingserver client perftest1sudo apt-get install perftest 测试时需切换到root Sever: 1ib_send_bw –a Client: 1ib_send_bw 192.168.46.132 –a FAQ 用sudoapt-get update时出现“ E: 无法获得锁/var/lib/apt/lists/lock”错误 1sudo rm /var/lib/apt/lists/lock 如果出现缺少ssl的错误，就安装ssl 1apt-get install libssl-dev ERROR: make *No rule to make target”menuconfig”.stop. 原因是没有在内核源码目录下进行。例如，要编译或升级的内核解压后的目录为/usr/src/Linux-2.4.24,一定要进入到该目录后使用makemenuconfig命令，这样就不会提示上面的错误了。(在本文中就是在rxe-dev目录下编译) 克隆的虚拟机中找不到eth0。因为网卡是克隆的，所以在测试连通性的时候不能用。要手动修改网卡信息。 在试验 rdma 的时候，记得关闭防火墙 12- sudo iptables -F chkconfig iptables off #开机不启动 ​]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>RDMA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP实验1:DataLab]]></title>
    <url>%2F2018%2F01%2F27%2FCSAPP-lab1-datalab%2F</url>
    <content type="text"><![CDATA[实验简介​ Data LAB 目的是熟悉位运算 要求： 只修改bit.c 使用 btest 进行验证 每次修改完之后都要make clean再make 整数部分：要求只能使用规定的操作符并且不能使用循环、条件语句 在函数开始时声明所有变量，只能使用局部变量 不能使用其他函数/宏/int外的类型/类型转换 int都是默认二进制补码编码 2’s complement，32bit 要考虑数据溢出的情况，比如相减，同号才能相减，否则结果出错 Tips： # ./btest -f [函数名]，检验某个函数 ./btest 检验所有函数 关注int型的表示范围 -2^31~2^31-1以及一些特殊的数字的补码编码 -2^31：0x80 00 00 00 -1：0xff ff ff ff 一个数的相反数是 ~x+1 在float的实验中要对该数是不是规格化分情况 逻辑右移不带符号，&gt;&gt;是算术右移，带符号 0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00 个人认为最难的是ilog2 文件说明Github地址：Data Lab bit.c：实现缓存模拟器的文件 Examples：表示用例‘ Legal ops：允许的操作符 Max ops：最多操作数 Rating：难度系数 在每一次更新之后，首先用make生成文件，之后用相应的test跑分即可 整形logicalShift12345678910111213/* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; int val = ~(1&lt;&lt;31) ; // 0x7f ff ff ff val = ((val &gt;&gt; n) &lt;&lt;1)+1; return val &amp; (x&gt;&gt;n);&#125; 逻辑右移：需要去掉负数带来的符号位。产生一个数，前n-1位0，之后全为1，和算数右移后的数进行按位与操作，使左边n-1位为0。 bitCount123456789101112131415161718192021/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int mask = ((0x01&lt;&lt;8|0x01)&lt;&lt;8|0x01)&lt;&lt;8|0x01 ; int val = mask &amp; x; val += mask &amp; x&gt;&gt;1; val += mask &amp; x&gt;&gt;2; val += mask &amp; x&gt;&gt;3; val += mask &amp; x&gt;&gt;4; val += mask &amp; x&gt;&gt;5; val += mask &amp; x&gt;&gt;6; val += mask &amp; x&gt;&gt;7; val += val&gt;&gt;16; val += val&gt;&gt;8; return val&amp;0xff;&#125; 要求：计算32进制数x中1的个数 思路：如果依次检测，ops必然超过。可以每次检测4位，然后再进行累加。先初始化mask=0x01010101，用来检测x&gt;&gt;i的0,8,16,24位是否为1然后x顺序移动重复上述检测，一共8次。相当于将一个32位分成4段同时进行，结果存储在分别四段的8位中。整合：将前16位加到后16位上，然后把8~16位加到低8位。取最低8位为最后结果。 bang12345678910/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; return ((~((~x+1)^x))&gt;&gt;31) &amp; 0x01;&#125; 要求：输出！x。即x!=0, !x =0 ; x=0, !x =1 思路：根据0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00,所以不能用^）或运算之后取反，再取符号位。 tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 0x01&lt;&lt;31; // 0x80 00 00 00&#125; 要求：32位二进制补码的最小整数，也就是0x80 00 00 00。（如8位整数，补码编码最小数就是-128，和128是相等的，也就是1000 0000(2)） fitBits12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; int shiftBits = 32 + (~n+1); // 32-n return !(x^((x&lt;&lt;shiftBits)&gt;&gt;shiftBits));&#125; 要求：判断x是否可以用n位补码来表示。考虑的是数字是否在范围内能表示，也就是移动后符号位是否会变化 先左移32-n位，再右移32-n位。即保留最后n位。再和x进行异或，若两者相同，表示x可以被表示成一个n为整数，！0为1。eg.以5为例，5 =000….. 101（2），左移27位后再右移27位得到的是 1111….101，与原来不同。而-4 = 111…100（2），移动后得到的还是111…100，同一个数。 divpwr21234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int sgn = x &gt;&gt; 31; // 0xffffffff or 0x0 int mask = (1 &lt;&lt; n )+ (~0) ; //2^n -1 int bias = sgn &amp; mask; //if x &gt;= 0 bias = 0 return (x+bias) &gt;&gt; n;&#125; 要求：求x /(2^n)，向0取整。 若是非负数，可以直接右移。如果是负数需要分情况。eg. -33 &gt;&gt;4 =-3 。因为负数右移的结果是，如果除以2次幂出现小数，取小于它的最大整数。所以除非是-4 -8这类后几位全为0的负数，其他的都得+1。 构造一个偏置量，因为要右移n位，如果是负数的话，加上2^n-1（后几位全0的话不变，其余的数进1）后再移位。 negate12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 取反加一 isPositive123456789101112/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; //int nsgn = ((~x)&gt;&gt;31)&amp;0x01; //nsgn = !sgn int nsgn = !(x&gt;&gt;31); return nsgn ^ !x ;&#125; 判断正数。x&gt;0，返回1。其余返回0。主要是处理0的情况。取符号位，再取反，再和 !x 进行异或。 isLessOrEqual123456789101112131415/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int sgnx = (x&gt;&gt;31) &amp;0x01; int sgny = (y&gt;&gt;31) &amp;0x01; int sgn = (sgnx ^ sgny) &amp; sgnx; // x&lt;0 ,y&gt;=0 int val = y + (~x +1); // y-x val = ((val &gt;&gt;31) &amp; 0x01) | (sgnx^sgny); // x-y&lt;0 &amp;&amp; sgnx=sgny return (sgn|!val); &#125; 要求：判断x&lt;=y是否成立可以转化为判断x-y的正负。 注意：当x和y同号时，x-y不会发生溢出，判断符号位即可，当x和y异号时，x-y可能发生溢出，其结果不一定和x的符号一致。所以分解为三部分：x和y异号 / 同号 / 相等。 ilog212345678910111213141516/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int bitNum =0; bitNum = (!!(x&gt;&gt;16))&lt;&lt;4; bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+8)))&lt;&lt;3); bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+4)))&lt;&lt;2); bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+2)))&lt;&lt;1); bitNum = bitNum + (!!(x&gt;&gt;(bitNum+1))); return bitNum;&#125; 要求：由多少位二进制可以表示。log（2）1 = 0 二分法，先右移16位后，若大于0即得到（10000）2 =16，否则得到0，判断最高位是否为0（前16位部分是否为0），若不为0，则包含2^16，同理。 其实ilog2的结果不会超过31，可以想到用5位二进制来表示，也就是分成这5步. 浮点型浮点型数表示： float_neg12345678910111213141516171819/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; int tmp =0,ret=0; ret = uf ^ 0x80000000; // sign reverse tmp = uf &amp; 0x7fffffff; // if(tmp &gt; 0x7f800000) // NaN ret = uf; return ret;&#125; 要求：计算-x （unsigned表示的浮点型），可以使用条件语句和其他运算符，当x=NaN时，返回其NaN本身；x！=NaN时，返回-x。 非NaN的数，对最高位异或，将符号位取反。判断NaN，返回本身。 float_i2f123456789101112131415161718192021222324252627unsigned float_i2f(int x) &#123; int sign = (x&gt;&gt;31)&amp;0x01; int frac_mask = 0x7fffff; // (1&lt;&lt;23) -1 int frac=0,exp=0,delta=0; int i = 0; if(!x) return x; else if(x==0x80000000)// -2^31 exp = 158; // 158 = 127 +31 else&#123; if(sign) x=-x; // abs(x) i=30; while(!(x&gt;&gt;i)) i--; exp = i+127; // exp = Bias + E x= x&lt;&lt;(31-i); // clean all those zeroes of high bits frac = (x&gt;&gt;8) &amp; frac_mask;//right shift 8 bits to become the fraction,sign and exp have 8 bits total x = x &amp; 0xff; delta = x&gt;0x80||((x==0x80 )&amp;&amp; (frac&amp;0x01)); //if lowest 8 bits of x is larger than a half,or is 1.5,round up 1 frac += delta; if(frac&gt;&gt;23)&#123; //if after rounding fraction is larger than 23bits exp += 1; frac = frac &amp; frac_mask; &#125; &#125; return (sign&lt;&lt;31)|(exp&lt;&lt;23)|frac;&#125; 要求：int转float 分别求出符号位sign，指数部分exp和小数部分frac。原来整数称x 首先把特殊情况的0x0 和 0x80 00 00 00（-2^31）挑出来，因为不能用移位的办法求exp和frac。 求绝对值，找出x的最高位（最左边的1），此时要从第30位找起，因为第31位是符号位。找到之后该位数就是$ v = (-1)^SM(2)^E $中的E，可以求得exp=E+127 求frac：取x最高位后的23位。步骤：先去掉x高位的0，然后右移8位将最高位后的23位移到低23位。 求精度：int转float型会丢失最后8位的精度（31-23=8），所以要判断x的最后八位需不需要进位，如果最后8位超过128（0x80）或者最后8位=128且frac最后一位=1，则进位。 进位后：需要检查frac有没有再进位，frac&gt;&gt;23进行判断，如果frac进位了，那么exp+1，frac再取最后23位。把sign exp frac组合成结果 float_twice1234567891011121314151617181920212223242526/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; int sign = uf&gt;&gt;31&amp;&amp;0x01; int exp = uf&gt;&gt;23 &amp; 0xff; int frac = uf &amp; 0x7fffff; if(exp!=0xff)&#123; if(!exp) frac=frac&lt;&lt;1; else&#123; exp += 1; if(exp==0xff) frac=0; &#125; &#125; return sign&lt;&lt;31|exp&lt;&lt;23|frac;&#125; 要求：求2*uf，uf是一个用unsigned表示的float，当遇到NaN时返回该NaN 检查是否NaN：exp==0xff 然后分两种情况： 1、exp=全0的，frac&lt;&lt;1,exp不变 2、exp≠全0的，exp++，检查exp==0xff，若exp==0xff，此时该数超范围（无穷大），frac=0 取符号位：uf&gt;&gt;31&amp;0x01 取frac：uf&amp;((1&lt;&lt;23)-1) 取exp：(uf&gt;&gt;23)&amp;0xff]]></content>
      <categories>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>操作系统</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux添加新协议]]></title>
    <url>%2F2018%2F01%2F26%2Flinux-add-new-protocol%2F</url>
    <content type="text"><![CDATA[添加协议号​ \include\linux\socket.h中定义了地址协议族，修改AF_MAX+1（地址协议族数），并加上自己的协议族 123456789101112#define AF_KCM 41 /* Kernel Connection Multiplexor*/#define AF_QIPCRTR 42 /* Qualcomm IPC Router */#define AF_AS 43 /* 新协议*/#define AF_MAX 44 /* For now.. */#define PF_AS AF_AS /* 新协议*//* Protocol families, same as address families. */#define PF_UNSPEC AF_UNSPEC#define PF_UNIX AF_UNIX#define PF_LOCAL AF_LOCAL ​ 通过添加协议号的方式，需要重新编译内核 编译内核下载linux源码，进入源码根目录编译 123456sumake menuconfigmake -j 32make modules_installmake installmake headers_install INSTALL_HDR_PATH=/usr 然后重启，查看新内核版本 12zjw@ubuntu:~$ uname -r4.10.0 添加新协议模块添加一个空协议 aproto.c，大部分函数是空函数。根据/net/rds.c修改的，将原来rds改成as，AF_INET改成AF_AS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/gfp.h&gt;#include &lt;linux/in.h&gt;#include &lt;linux/poll.h&gt;#include &lt;net/sock.h&gt;#include &lt;linux/init.h&gt;static int as_release(struct socket *sock)&#123; return 0;&#125;static int as_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)&#123; return 0;&#125;static int as_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)&#123; return 0;&#125;static int as_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)&#123; int ret =0; return ret;&#125;static int as_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int msg_flags)&#123; int ret =0; return ret; &#125;static unsigned int as_poll(struct file *file, struct socket *sock, poll_table *wait)&#123; int ret = 0; return ret;&#125;static int as_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)&#123; return -ENOIOCTLCMD;&#125;static int as_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)&#123; int ret =0 ; return ret;&#125;static int as_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)&#123; int ret = 0; return ret;&#125;static int as_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)&#123; int ret =0 ; return ret;&#125;static struct proto as_proto = &#123; .name = "A_PROTO", .owner = THIS_MODULE, .obj_size = sizeof(struct sock),&#125;;static const struct proto_ops as_proto_ops = &#123; .family = AF_AS, // 自定义协议族 .owner = THIS_MODULE, .release = as_release, .bind = as_bind, .connect = as_connect, .socketpair = sock_no_socketpair, .accept = sock_no_accept, .getname = as_getname, .poll = as_poll, .ioctl = as_ioctl, .listen = sock_no_listen, .shutdown = sock_no_shutdown, .setsockopt = as_setsockopt, .getsockopt = as_getsockopt, .sendmsg = as_sendmsg, .recvmsg = as_recvmsg, .mmap = sock_no_mmap, .sendpage = sock_no_sendpage,&#125;;static int __as_create(struct socket *sock, struct sock *sk, int protocol)&#123; struct as_sock *as; sock_init_data(sock, sk); sock-&gt;ops = &amp;as_proto_ops; sk-&gt;sk_protocol = protocol; return 0;&#125;static int as_create(struct net *net, struct socket *sock, int protocol, int kern)&#123; struct sock *sk; if (sock-&gt;type != SOCK_SEQPACKET || protocol) return -ESOCKTNOSUPPORT; sk = sk_alloc(net, AF_AS, GFP_ATOMIC, &amp;as_proto, kern); if (!sk) return -ENOMEM; return __as_create(sock, sk, protocol);&#125;static const struct net_proto_family as_family_ops = &#123; .family = AF_AS, .create = as_create, .owner = THIS_MODULE,&#125;;static int __init as_init(void)&#123; int ret; printk(KERN_INFO "as_init\n"); ret = proto_register(&amp;as_proto, 1); //注册协议 if (ret) &#123; printk(KERN_ERR "proto_register ERROR\n"); goto out; &#125; ret = sock_register(&amp;as_family_ops); if (ret) &#123; printk(KERN_ERR "sock_register ERROR\n"); goto out; &#125; goto out; printk(KERN_INFO "device has been registered\n");out: return ret;&#125;static void __exit as_exit(void)&#123; printk(KERN_INFO "aproto exit\n");&#125;module_init(as_init);module_exit(as_exit);#define DRV_RELDATE "2017/12/07"MODULE_AUTHOR("Jingwei Zheng");MODULE_DESCRIPTION("AS:A NEW PROTOCOL" DRV_RELDATE); 应用程序1234#define AF_AS 43...socket_fd = socket(AF_AS, SOCK_SEQPACKET, 0)...]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
