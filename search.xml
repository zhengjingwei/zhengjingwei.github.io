<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux网络协议栈结构]]></title>
    <url>%2F2018%2F01%2F30%2Flinux-network-stack-structure%2F</url>
    <content type="text"><![CDATA[网络栈层次结构如下图： 应用层 由应用程序提供。它通常是一个语义层，能够理解要传输的数据。例如，超文本传输协议（HTTP）就负责传输服务器和客户机之间对 Web 内容的请求与响应 传输层 负责端到端的通信（一台机子内部）-TCP、UDP 网络层 负责管理主机之间的通信 -IP 链路层 对物理层访问的设备驱动程序，如网卡驱动 物理层 主要提供各种连接的物理设备，如各种网卡，串口卡等 Linux网络协议栈结构 系统调用接口层 实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。 协议无关的接口层，就是SOCKET层，这一层的目的是屏蔽底层的不同协议（更准确的来说主要是TCP与UDP，当然还包括RAW IP， SCTP等），以便与系统调用层之间的接口可以简单，统一。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个SOCKET，这个SOCKET其实是一个巨大的sock结构，它和下面一层的网络协议层联系起来，屏蔽了不同的网络协议的不同，只把数据部分呈现给应用层（通过系统调用接口来呈现）。 网络协议实现层，毫无疑问，这是整个协议栈的核心。这一层主要实现各种网络协议，最主要的当然是IP，ICMP，ARP，RARP，TCP，UDP等。这一层包含了很多设计的技巧与算法，相当的不错。 与具体设备无关的驱动接口层，这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如open，close，init等，这一层可以屏蔽底层不同的驱动程序。 驱动程序层，这一层的目的就很简单了，就是建立与硬件的接口层。 1 系统调用接口层系统调用接口层实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。系统调用接口可以从两个角度进行描述：当用户进行网络调用时，通过系统调用接口多路复用到内核中。这最终作为 sys_socketcall(./net/socket.c)中的调用，然后进一步解复用到其预期目标的调用。 12345678SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)SYSCALL_DEFINE2(listen, int, fd, int, backlog)SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen) SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen)... 系统调用接口的另一个角度是使用正常的文件操作进行网络I/O。例如，典型的读写操作可以在网络socket（由文件描述符表示，就像普通文件）一样执行。因此，虽然存在一些特定于网络的操作（调用socket创建socket，调用connect将socket连接到目的地等等），但还是有一些适用于网络对象的标准文件操作，就像常规文件一样。 123456789static const struct file_operations socket_file_ops = &#123; .owner = THIS_MODULE, .llseek = no_llseek, .read_iter = sock_read_iter, .write_iter = sock_write_iter,struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname)&#123; file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE, &amp;socket_file_ops); 最后，系统调用接口提供了在用户空间应用程序和内核之间传输控制的手段。 2 协议无关接口层(Socket层)socket层是协议无关接口，其提供一组通用功能，以支持各种不同的协议。socket层不仅支持典型的TCP和UDP协议，还支持原始以太网和其他传输协议，如流控制传输协议（SCTP）。 网络栈使用socket通信。Linux中的socket结构struct sock是在include/net/sock.h中定义的。该大型结构包含特定socket的所有必需状态，包括socket使用的特定协议以及可能在其上执行的操作。它屏蔽了不同网络协议的区别，只把数据部分呈现给应用层（通过系统调用接口）。 12345678struct sock &#123; /* * Now struct inet_timewait_sock also uses sock_common, so please just * don't add nothing before this first member (__sk_common) --acme */ struct sock_common __sk_common; #define sk_prot __sk_common.skc_prot struct proto *sk_prot_creator; 网络子系统通过定义了其功能的特殊结构（即proto）来了解各个可用协议。每个协议维护一个名为proto（在linux/include/net/sock.h中找到）的结构。该结构定义了可以从socket层到传输层执行的特定socket操作（例如，如何创建socket，如何与socket建立连接，如何关闭socket等，由各自协议决定如何实现）。 12345678struct proto tcp_prot = &#123; .name = "TCP", .owner = THIS_MODULE, .close = tcp_close, .connect = tcp_v4_connect, .disconnect = tcp_disconnect, .accept = inet_csk_accept,... 3 网络协议层网络协议部分定义了可用的特定网络协议（如TCP，UDP等的具体实现）。这些是在linux/net/ipv4/af_inet.c中的inet_init函数的开头进行初始化的（因为TCP和UDP是协议inet族的一部分）。inet_init函数调用proto_register注册每个内置协议。proto_register在linux/net/core/sock.c中定义，除了将协议添加到活动协议列表之外，还可以根据需要分配一个或多个slab缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int proto_register(struct proto *prot, int alloc_slab)&#123; if (alloc_slab) &#123; ... &#125; ... mutex_lock(&amp;proto_list_mutex); list_add(&amp;prot-&gt;node, &amp;proto_list); assign_proto_idx(prot); mutex_unlock(&amp;proto_list_mutex);... static int __init inet_init(void)&#123; struct inet_protosw *q; struct list_head *r; int rc = -EINVAL; sock_skb_cb_check_size(sizeof(struct inet_skb_parm)); rc = proto_register(&amp;tcp_prot, 1); if (rc) goto out; rc = proto_register(&amp;udp_prot, 1); if (rc) goto out_unregister_tcp_proto;.. for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); arp_init(); ip_init(); tcp_init(); udp_init();...static struct inet_protosw inetsw_array[] =&#123; &#123; .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &amp;tcp_prot, .ops = &amp;inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, &#125;, 您可以通过linux/net/ipv4/中的文件tcp_ipv4.c，udp.c和raw.c中的proto结构来了解各自的协议。这些协议的proto结构体都按照类型和协议映射到inetsw_array，将内部协议映射到对应的操作(which maps the built-in protocols to their operations.)。结构体inetsw_array及其关系如图3所示。该数组中的每个协议都在初始化inetsw时，通过在inet_init调用inet_register_protosw来初始化。函数inet_init还初始化各种inet模块，如ARP，ICMP，IP模块，TCP和UDP模块。 图3. Internet协议数组的结构 Socket协议关联 回想下，当创建一个socket时，它定义了类型和协议，如 my_sock = socket( AF_INET, SOCK_STREAM, 0 )。其中AF_INET表示基于Internet地址族，SOCK_STREAM表示其为流式socket（如上所示inetsw_array）。 从图3可以看出， proto结构定义了特定传输协议的方法，而proto_ops结构定义了一般的socket方法。其他额外的协议可以通过调用inet_register_protosw将自己加入到inetsw协议开关机(protocol switch) 。例如，SCTP通过在linux/net/sctp/protocol.c中调用sctp_init来添加自己。 123456789101112131415struct proto_ops &#123; int family; struct module *owner; int (*release) (struct socket *sock); int (*bind) (struct socket *sock, struct sockaddr *myaddr, int sockaddr_len); int (*connect) (struct socket *sock, struct sockaddr *vaddr, int sockaddr_len, int flags); int (*socketpair)(struct socket *sock1, struct socket *sock2); int (*accept) (struct socket *sock, struct socket *newsock, int flags); ... 补充：prot/prot_ops二者有点相似，这里特意说明下：kernel的调用顺序是先inet(即prot_ops)，后protocal（即prot），inet层处于socket和具体protocol之间。下面以connect为例，ops即为prot_ops，它调用的connect是inet_listen，然后才是具体protocol的tcp_v4_connect。这一关系主要记录在inetsw_array中。 1234567891011121314151617181920SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen)&#123; struct socket *sock;... err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen, sock-&gt;file-&gt;f_flags); int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags, int is_sendmsg) &#123; struct sock *sk = sock-&gt;sk; switch (sock-&gt;state) &#123; case SS_UNCONNECTED: err = -EISCONN; if (sk-&gt;sk_state != TCP_CLOSE) goto out; err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len); if (err &lt; 0) goto out; socket的数据移动使用核心结构socket缓冲区（sk_buff）来进行。一个sk_buff 包含包数据(package data)，和状态数据（state data, 覆盖协议栈的多个层）。每个发送或接收的数据包都用一个sk_buff来表示。该sk_buff 结构是在linux/include/linux/skbuff.h中定义的，并在图4中示出。 图4. Socket缓冲区及其与其他结构的关系 如图所示，一个给定连接的多个sk_buff可以串联在一起。每个sk_buff标识了要发送数据包或从其接收数据包的设备结构（net_device *dev）。由于每个包都表示为一个sk_buff，数据包报头可方便地通过一组指针来寻址（th，iph以及mac（MAC报头）），内核会保证这块内存是连续的。由于sk_buff 是socket数据管理的核心，因此kernel已经创建了许多支撑函数来管理它们，包括sk_buff的创建和销毁，克隆和队列管理等函数。 总的来说，内核socket缓冲器设计思路是，某一的socket的sk_buff串链接在一起，并且sk_buff包括许多信息，包括到协议头的指针，时间戳（发送或接收数据包的时间）以及与数据包相关的网络设备。 4 设备无关接口层协议层下面是另一个无关的接口层，将协议连接到具有不同功能的各种硬件设备的驱动程序。该层提供了一组通用的功能，由较低级别的网络设备驱动程序使用，以允许它们使用较高级协议栈进行操作。 首先，设备驱动程序可以通过调用register_netdevice/unregister_netdevice将自己注册/去注册到内核。调用者首先填写net_device结构，然后将其传入register_netdevice进行注册。内核调用其init功能（如果有定义），执行许多健全检查，创建一个 sysfs条目，然后将新设备添加到设备列表（在内核中Active设备的链表）。你可以 在linux/include/linux/netdevice.h中找到net_device结构。各个函数在linux/net/core/dev.c中实现。 使用dev_queue_xmit函数将sk_buff从协议层发送到网络设备。dev_queue_xmit函数会将sk_buff添加到底层网络设备驱动程序最终要传输的队列中（网络设备在net_device或者sk_buff-&gt;dev中定义）。dev结构包含函数hard_start_xmit，保存用于启动sk_buff传输的驱动程序功能的方法。 通常使用netif_rx接收报文数据。当下级设备驱动程序接收到一个包（包含在新分配的sk_buff）时，内核通过调用netif_rx将sk_buff传递给网络层。然后，netif_rx通过调用netif_rx_schedule将sk_buff排队到上层协议的队列以进行进一步处理。您可以在linux/net/core/dev.c 中找到dev_queue_xmit和netif_rx函数。 最近，在内核中引入了一个新的应用程序接口（NAPI），以允许驱动程序与设备无关层（dev）进行交互。一些驱动程序使用NAPI，但绝大多数仍然使用较旧的帧接收接口（by a rough factor of six to one）。NAPI可以通过避免每个传入帧的中断，在高负载下得到更好的性能。 5 设备驱动程序网络栈的底部是管理物理网络设备的设备驱动程序。该层的设备示例包括串行接口上的SLIP驱动程序或以太网设备上的以太网驱动程序。 在初始化时，设备驱动程序分配一个net_device结构，然后用其必需的例程进行初始化。dev-&gt;hard_start_xmit就是其中一个例程，它定义了上层如何排队sk_buff用以传输。这个程序需要一个sk_buff。此功能的操作取决于底层硬件，但通常将sk_buff中的数据包移动到硬件环或队列。如设备无关层所述，帧接收使用该netif_rx接口或符合NAPI的网络驱动程序的netif_receive_skb。NAPI驱动程序对底层硬件的功能提出了约束。 在设备驱动程序配置其结构中的dev接口后，调用register_netdevice以后驱动就可以使用了。您可以在linux/drivers/net中找到网络设备专用的驱动程序。 ReferenceLinux网络栈解剖]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kernel</tag>
        <tag>网络协议栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Soft-RoCE环境搭建]]></title>
    <url>%2F2018%2F01%2F27%2FSoft-RoCE-setup%2F</url>
    <content type="text"><![CDATA[Soft-RoCE是RoCE协议的软件栈版本，可以在普通网卡上搭建RDMA环境 先确保安装以下软件： 1234567sudo apt-get install gitsudo apt-get install libncurses5-devsudo apt-get install libssl-devsudo apt-get install libibverbs1 libibcm1libibcm-dev ibverbs-utils libibverbs-dev sudo apt-get install libibverbs1librdmacm-dev librdmacm1 rdmacm-utils sudo apt-get install openssh-serversudo apt-get install libswitch-perl Install KernelClone kernel 1git clone https://github.com/SoftRoCE/rxe-dev.git 切换到 ‘rxe_submission_v18’ 分支 1git checkout rxe_submission_v18 进入到rxe-dev 目录 cd rxe-dev 1cp /boot/config-$(uname –r) .config 切换到root用户权限，运行make menuconfig ，出现选择界面。（在使用 make menuconfig 之前需要安装ncurse-devel 输入”/“ ，然后输入RDMA_RXE，按下 enter，会查找有关RDMA_RXE 的选择项. 输入数字 1，就会选择到RDMA_RXE 的设置，输入”M” ，选中 RDMA 的配置. 然后 vi.config 来确认CONFIG_RDMA_RXE 为 m ，CONFIG_INFINIBAND_ADDR_TRANS和CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS 为 y 建议在Generalsetup –&gt;Local version中填写一个名称，便于之后编译出的内核与其他内核区别开。 ##编译内核 1234make –j 32make modules_installmake installmake headers_install INSTALL_HDR_PATH=/usr 上述步骤如果遇到permission denied，命令前加上sudo 再执行。且上述命令均应在源码目录即 /rxe-dev 下执行 确认新的内核是否在grub引导中，可以查看 /boot/grub/grub.conf 用新内核启动后查看内核版本号和rdma_rxe模块 1234567891011121314kevin@ubuntu:~$ uname -r4.7.0-rc3kevin+kevin@ubuntu:~$ modinfo rdma_rxefilename: /lib/modules/4.7.0-rc3kevin+/kernel/drivers/infiniband/hw/rxe/rdma_rxe.koversion: 0.2license: DualBSD/GPLdescription: SoftRDMA transportauthor: BobPearson, Frank Zago, John Groves, Kamal Heibsrcversion: 85F0433D44A5DAF81FBFE5Cdepends: ib_core,ip6_udp_tunnel,udp_tunnelintree: Yvermagic: 4.7.0-rc3kevin+ SMP mod_unload modversions parm: add:Create RXE device over network interfaceparm: remove:Remove RXE device over network interface Install user space library (librxe)安装以下的包 1234567libswitch-perllibibverbslibibverbs-devellibibverbs-utilslibrdmacmlibrdmacm-devellibrdmacm-utils 编译安装 install userspace library librxe: 12345git clone https://github.com/SoftRoCE/librxe-dev.gitcd librxe-dev./configure --libdir=/usr/lib64/ --prefix=makemake install （./configure --libdir=/usr/lib64/ --prefix= 中如果路径只有/lib 就用/lib） Configure Soft-RoCE (RXE)1234kevin@ubuntu:~$ rxe_cfg statusrxe modules not loaded Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens33 yes e1000 1500 192.168.188.132 Load ib_rxe kernel module, using the rxe_cfg script included in the librxe RPM: 1234kevin@ubuntu:~$ sudo rxe_cfg startsh: echo: I/O error Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens33 yes e1000 1500 192.168.188.132 rxe0 1024 To verify RXE kernel module is loaded, run: 12345kevin@ubuntu:~$ lsmod |grep rdma_rxerdma_rxe 102400 0ip6_udp_tunnel 16384 1 rdma_rxeudp_tunnel 16384 1 rdma_rxeib_core 208896 6 rdma_cm,ib_cm,iw_cm,ib_uverbs,rdma_rxe,rdma_ucm Create RXE device over network interface (e.g. ens33): 1sudo rxe_cfg add ens33 Check the status of rxe_cfg, make sure that rxe0 was added under RDEV (rxe device).It is also possible to check the ibv_devices command. 1234567kevin@ubuntu:~$ rxe_cfg Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens33 yes e1000 1500 192.168.188.132 rxe0 1024 (3) kevin@ubuntu:~$ ibv_devices device node GUID ------ ---------------- rxe0 020c29fffebd5e22 Test connectivity. On the server: 1ibv_rc_pingpong -d rxe0 -g 0 On the client: 1ibv_rc_pingpong -d rxe0 -g 0 &lt;server_management_ip&gt; e.g Client: 123kevin@ubuntu:~$ ibv_rc_pingpong -g 0 -d rxe0 -i 1 192.168.188.129 local address: LID 0x0000, QPN 0x000011, PSN 0x2cd726, GID fe80::20c:29ff:febd:5e22 remote address: LID 0x0000, QPN 0x000011, PSN 0x767a62, GID fe80::20c:29ff:fe44:4345 Testrpingserver client perftest1sudo apt-get install perftest 测试时需切换到root Sever: 1ib_send_bw –a Client: 1ib_send_bw 192.168.46.132 –a FAQ 用sudoapt-get update时出现“ E: 无法获得锁/var/lib/apt/lists/lock”错误 1sudo rm /var/lib/apt/lists/lock 如果出现缺少ssl的错误，就安装ssl 1apt-get install libssl-dev ERROR: make *No rule to make target”menuconfig”.stop. 原因是没有在内核源码目录下进行。例如，要编译或升级的内核解压后的目录为/usr/src/Linux-2.4.24,一定要进入到该目录后使用makemenuconfig命令，这样就不会提示上面的错误了。(在本文中就是在rxe-dev目录下编译) 克隆的虚拟机中找不到eth0。因为网卡是克隆的，所以在测试连通性的时候不能用。要手动修改网卡信息。 在试验 rdma 的时候，记得关闭防火墙 12- sudo iptables -F chkconfig iptables off #开机不启动 ​]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>RDMA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP实验1:DataLab]]></title>
    <url>%2F2018%2F01%2F27%2FCSAPP-lab1-datalab%2F</url>
    <content type="text"><![CDATA[实验简介​ Data LAB 目的是熟悉位运算 要求： 只修改bit.c 使用 btest 进行验证 每次修改完之后都要make clean再make 整数部分：要求只能使用规定的操作符并且不能使用循环、条件语句 在函数开始时声明所有变量，只能使用局部变量 不能使用其他函数/宏/int外的类型/类型转换 int都是默认二进制补码编码 2’s complement，32bit 要考虑数据溢出的情况，比如相减，同号才能相减，否则结果出错 Tips： # ./btest -f [函数名]，检验某个函数 ./btest 检验所有函数 关注int型的表示范围 -2^31~2^31-1以及一些特殊的数字的补码编码 -2^31：0x80 00 00 00 -1：0xff ff ff ff 一个数的相反数是 ~x+1 在float的实验中要对该数是不是规格化分情况 逻辑右移不带符号，&gt;&gt;是算术右移，带符号 0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00 个人认为最难的是ilog2 文件说明Github地址：Data Lab bit.c：实现缓存模拟器的文件 Examples：表示用例‘ Legal ops：允许的操作符 Max ops：最多操作数 Rating：难度系数 在每一次更新之后，首先用make生成文件，之后用相应的test跑分即可 整形logicalShift12345678910111213/* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; int val = ~(1&lt;&lt;31) ; // 0x7f ff ff ff val = ((val &gt;&gt; n) &lt;&lt;1)+1; return val &amp; (x&gt;&gt;n);&#125; 逻辑右移：需要去掉负数带来的符号位。产生一个数，前n-1位0，之后全为1，和算数右移后的数进行按位与操作，使左边n-1位为0。 bitCount123456789101112131415161718192021/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int mask = ((0x01&lt;&lt;8|0x01)&lt;&lt;8|0x01)&lt;&lt;8|0x01 ; int val = mask &amp; x; val += mask &amp; x&gt;&gt;1; val += mask &amp; x&gt;&gt;2; val += mask &amp; x&gt;&gt;3; val += mask &amp; x&gt;&gt;4; val += mask &amp; x&gt;&gt;5; val += mask &amp; x&gt;&gt;6; val += mask &amp; x&gt;&gt;7; val += val&gt;&gt;16; val += val&gt;&gt;8; return val&amp;0xff;&#125; 要求：计算32进制数x中1的个数 思路：如果依次检测，ops必然超过。可以每次检测4位，然后再进行累加。先初始化mask=0x01010101，用来检测x&gt;&gt;i的0,8,16,24位是否为1然后x顺序移动重复上述检测，一共8次。相当于将一个32位分成4段同时进行，结果存储在分别四段的8位中。整合：将前16位加到后16位上，然后把8~16位加到低8位。取最低8位为最后结果。 bang12345678910/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; return ((~((~x+1)^x))&gt;&gt;31) &amp; 0x01;&#125; 要求：输出！x。即x!=0, !x =0 ; x=0, !x =1 思路：根据0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00,所以不能用^）或运算之后取反，再取符号位。 tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 0x01&lt;&lt;31; // 0x80 00 00 00&#125; 要求：32位二进制补码的最小整数，也就是0x80 00 00 00。（如8位整数，补码编码最小数就是-128，和128是相等的，也就是1000 0000(2)） fitBits12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; int shiftBits = 32 + (~n+1); // 32-n return !(x^((x&lt;&lt;shiftBits)&gt;&gt;shiftBits));&#125; 要求：判断x是否可以用n位补码来表示。考虑的是数字是否在范围内能表示，也就是移动后符号位是否会变化 先左移32-n位，再右移32-n位。即保留最后n位。再和x进行异或，若两者相同，表示x可以被表示成一个n为整数，！0为1。eg.以5为例，5 =000….. 101（2），左移27位后再右移27位得到的是 1111….101，与原来不同。而-4 = 111…100（2），移动后得到的还是111…100，同一个数。 divpwr21234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int sgn = x &gt;&gt; 31; // 0xffffffff or 0x0 int mask = (1 &lt;&lt; n )+ (~0) ; //2^n -1 int bias = sgn &amp; mask; //if x &gt;= 0 bias = 0 return (x+bias) &gt;&gt; n;&#125; 要求：求x /(2^n)，向0取整。 若是非负数，可以直接右移。如果是负数需要分情况。eg. -33 &gt;&gt;4 =-3 。因为负数右移的结果是，如果除以2次幂出现小数，取小于它的最大整数。所以除非是-4 -8这类后几位全为0的负数，其他的都得+1。 构造一个偏置量，因为要右移n位，如果是负数的话，加上2^n-1（后几位全0的话不变，其余的数进1）后再移位。 negate12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 取反加一 isPositive123456789101112/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; //int nsgn = ((~x)&gt;&gt;31)&amp;0x01; //nsgn = !sgn int nsgn = !(x&gt;&gt;31); return nsgn ^ !x ;&#125; 判断正数。x&gt;0，返回1。其余返回0。主要是处理0的情况。取符号位，再取反，再和 !x 进行异或。 isLessOrEqual123456789101112131415/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int sgnx = (x&gt;&gt;31) &amp;0x01; int sgny = (y&gt;&gt;31) &amp;0x01; int sgn = (sgnx ^ sgny) &amp; sgnx; // x&lt;0 ,y&gt;=0 int val = y + (~x +1); // y-x val = ((val &gt;&gt;31) &amp; 0x01) | (sgnx^sgny); // x-y&lt;0 &amp;&amp; sgnx=sgny return (sgn|!val); &#125; 要求：判断x&lt;=y是否成立可以转化为判断x-y的正负。 注意：当x和y同号时，x-y不会发生溢出，判断符号位即可，当x和y异号时，x-y可能发生溢出，其结果不一定和x的符号一致。所以分解为三部分：x和y异号 / 同号 / 相等。 ilog212345678910111213141516/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int bitNum =0; bitNum = (!!(x&gt;&gt;16))&lt;&lt;4; bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+8)))&lt;&lt;3); bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+4)))&lt;&lt;2); bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+2)))&lt;&lt;1); bitNum = bitNum + (!!(x&gt;&gt;(bitNum+1))); return bitNum;&#125; 要求：由多少位二进制可以表示。log（2）1 = 0 二分法，先右移16位后，若大于0即得到（10000）2 =16，否则得到0，判断最高位是否为0（前16位部分是否为0），若不为0，则包含2^16，同理。 其实ilog2的结果不会超过31，可以想到用5位二进制来表示，也就是分成这5步. 浮点型浮点型数表示： float_neg12345678910111213141516171819/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; int tmp =0,ret=0; ret = uf ^ 0x80000000; // sign reverse tmp = uf &amp; 0x7fffffff; // if(tmp &gt; 0x7f800000) // NaN ret = uf; return ret;&#125; 要求：计算-x （unsigned表示的浮点型），可以使用条件语句和其他运算符，当x=NaN时，返回其NaN本身；x！=NaN时，返回-x。 非NaN的数，对最高位异或，将符号位取反。判断NaN，返回本身。 float_i2f123456789101112131415161718192021222324252627unsigned float_i2f(int x) &#123; int sign = (x&gt;&gt;31)&amp;0x01; int frac_mask = 0x7fffff; // (1&lt;&lt;23) -1 int frac=0,exp=0,delta=0; int i = 0; if(!x) return x; else if(x==0x80000000)// -2^31 exp = 158; // 158 = 127 +31 else&#123; if(sign) x=-x; // abs(x) i=30; while(!(x&gt;&gt;i)) i--; exp = i+127; // exp = Bias + E x= x&lt;&lt;(31-i); // clean all those zeroes of high bits frac = (x&gt;&gt;8) &amp; frac_mask;//right shift 8 bits to become the fraction,sign and exp have 8 bits total x = x &amp; 0xff; delta = x&gt;0x80||((x==0x80 )&amp;&amp; (frac&amp;0x01)); //if lowest 8 bits of x is larger than a half,or is 1.5,round up 1 frac += delta; if(frac&gt;&gt;23)&#123; //if after rounding fraction is larger than 23bits exp += 1; frac = frac &amp; frac_mask; &#125; &#125; return (sign&lt;&lt;31)|(exp&lt;&lt;23)|frac;&#125; 要求：int转float 分别求出符号位sign，指数部分exp和小数部分frac。原来整数称x 首先把特殊情况的0x0 和 0x80 00 00 00（-2^31）挑出来，因为不能用移位的办法求exp和frac。 求绝对值，找出x的最高位（最左边的1），此时要从第30位找起，因为第31位是符号位。找到之后该位数就是$ v = (-1)^SM(2)^E $中的E，可以求得exp=E+127 求frac：取x最高位后的23位。步骤：先去掉x高位的0，然后右移8位将最高位后的23位移到低23位。 求精度：int转float型会丢失最后8位的精度（31-23=8），所以要判断x的最后八位需不需要进位，如果最后8位超过128（0x80）或者最后8位=128且frac最后一位=1，则进位。 进位后：需要检查frac有没有再进位，frac&gt;&gt;23进行判断，如果frac进位了，那么exp+1，frac再取最后23位。把sign exp frac组合成结果 float_twice1234567891011121314151617181920212223242526/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; int sign = uf&gt;&gt;31&amp;&amp;0x01; int exp = uf&gt;&gt;23 &amp; 0xff; int frac = uf &amp; 0x7fffff; if(exp!=0xff)&#123; if(!exp) frac=frac&lt;&lt;1; else&#123; exp += 1; if(exp==0xff) frac=0; &#125; &#125; return sign&lt;&lt;31|exp&lt;&lt;23|frac;&#125; 要求：求2*uf，uf是一个用unsigned表示的float，当遇到NaN时返回该NaN 检查是否NaN：exp==0xff 然后分两种情况： 1、exp=全0的，frac&lt;&lt;1,exp不变 2、exp≠全0的，exp++，检查exp==0xff，若exp==0xff，此时该数超范围（无穷大），frac=0 取符号位：uf&gt;&gt;31&amp;0x01 取frac：uf&amp;((1&lt;&lt;23)-1) 取exp：(uf&gt;&gt;23)&amp;0xff]]></content>
      <categories>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>操作系统</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux添加新协议]]></title>
    <url>%2F2018%2F01%2F26%2Flinux-add-new-protocol%2F</url>
    <content type="text"><![CDATA[添加协议号​ \include\linux\socket.h中定义了地址协议族，修改AF_MAX+1（地址协议族数），并加上自己的协议族 123456789101112#define AF_KCM 41 /* Kernel Connection Multiplexor*/#define AF_QIPCRTR 42 /* Qualcomm IPC Router */#define AF_AS 43 /* 新协议*/#define AF_MAX 44 /* For now.. */#define PF_AS AF_AS /* 新协议*//* Protocol families, same as address families. */#define PF_UNSPEC AF_UNSPEC#define PF_UNIX AF_UNIX#define PF_LOCAL AF_LOCAL ​ 通过添加协议号的方式，需要重新编译内核 编译内核下载linux源码，进入源码根目录编译 123456sumake menuconfigmake -j 32make modules_installmake installmake headers_install INSTALL_HDR_PATH=/usr 然后重启，查看新内核版本 12zjw@ubuntu:~$ uname -r4.10.0 添加新协议模块添加一个空协议 aproto.c，大部分函数是空函数。根据/net/rds.c修改的，将原来rds改成as，AF_INET改成AF_AS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/gfp.h&gt;#include &lt;linux/in.h&gt;#include &lt;linux/poll.h&gt;#include &lt;net/sock.h&gt;#include &lt;linux/init.h&gt;static int as_release(struct socket *sock)&#123; return 0;&#125;static int as_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)&#123; return 0;&#125;static int as_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)&#123; return 0;&#125;static int as_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)&#123; int ret =0; return ret;&#125;static int as_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int msg_flags)&#123; int ret =0; return ret; &#125;static unsigned int as_poll(struct file *file, struct socket *sock, poll_table *wait)&#123; int ret = 0; return ret;&#125;static int as_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)&#123; return -ENOIOCTLCMD;&#125;static int as_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)&#123; int ret =0 ; return ret;&#125;static int as_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)&#123; int ret = 0; return ret;&#125;static int as_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)&#123; int ret =0 ; return ret;&#125;static struct proto as_proto = &#123; .name = "A_PROTO", .owner = THIS_MODULE, .obj_size = sizeof(struct sock),&#125;;static const struct proto_ops as_proto_ops = &#123; .family = AF_AS, // 自定义协议族 .owner = THIS_MODULE, .release = as_release, .bind = as_bind, .connect = as_connect, .socketpair = sock_no_socketpair, .accept = sock_no_accept, .getname = as_getname, .poll = as_poll, .ioctl = as_ioctl, .listen = sock_no_listen, .shutdown = sock_no_shutdown, .setsockopt = as_setsockopt, .getsockopt = as_getsockopt, .sendmsg = as_sendmsg, .recvmsg = as_recvmsg, .mmap = sock_no_mmap, .sendpage = sock_no_sendpage,&#125;;static int __as_create(struct socket *sock, struct sock *sk, int protocol)&#123; struct as_sock *as; sock_init_data(sock, sk); sock-&gt;ops = &amp;as_proto_ops; sk-&gt;sk_protocol = protocol; return 0;&#125;static int as_create(struct net *net, struct socket *sock, int protocol, int kern)&#123; struct sock *sk; if (sock-&gt;type != SOCK_SEQPACKET || protocol) return -ESOCKTNOSUPPORT; sk = sk_alloc(net, AF_AS, GFP_ATOMIC, &amp;as_proto, kern); if (!sk) return -ENOMEM; return __as_create(sock, sk, protocol);&#125;static const struct net_proto_family as_family_ops = &#123; .family = AF_AS, .create = as_create, .owner = THIS_MODULE,&#125;;static int __init as_init(void)&#123; int ret; printk(KERN_INFO "as_init\n"); ret = proto_register(&amp;as_proto, 1); //注册协议 if (ret) &#123; printk(KERN_ERR "proto_register ERROR\n"); goto out; &#125; ret = sock_register(&amp;as_family_ops); if (ret) &#123; printk(KERN_ERR "sock_register ERROR\n"); goto out; &#125; goto out; printk(KERN_INFO "device has been registered\n");out: return ret;&#125;static void __exit as_exit(void)&#123; printk(KERN_INFO "aproto exit\n");&#125;module_init(as_init);module_exit(as_exit);#define DRV_RELDATE "2017/12/07"MODULE_AUTHOR("Jingwei Zheng");MODULE_DESCRIPTION("AS:A NEW PROTOCOL" DRV_RELDATE); 应用程序1234#define AF_AS 43...socket_fd = socket(AF_AS, SOCK_SEQPACKET, 0)...]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
