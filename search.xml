<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSAPP实验1:DataLab]]></title>
    <url>%2F2018%2F01%2F27%2FCSAPP-lab1-datalab%2F</url>
    <content type="text"><![CDATA[实验简介​ Data LAB 目的是熟悉位运算 要求： 只修改bit.c 使用 btest 进行验证 每次修改完之后都要make clean再make 整数部分：要求只能使用规定的操作符并且不能使用循环、条件语句 在函数开始时声明所有变量，只能使用局部变量 不能使用其他函数/宏/int外的类型/类型转换 int都是默认二进制补码编码 2’s complement，32bit 要考虑数据溢出的情况，比如相减，同号才能相减，否则结果出错 Tips： # ./btest -f [函数名]，检验某个函数 ./btest 检验所有函数 关注int型的表示范围 -2^31~2^31-1以及一些特殊的数字的补码编码 -2^31：0x80 00 00 00 -1：0xff ff ff ff 一个数的相反数是 ~x+1 在float的实验中要对该数是不是规格化分情况 逻辑右移不带符号，&gt;&gt;是算术右移，带符号 0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00 个人认为最难的是ilog2 文件说明Github地址：Data Lab bit.c：实现缓存模拟器的文件 Examples：表示用例‘ Legal ops：允许的操作符 Max ops：最多操作数 Rating：难度系数 在每一次更新之后，首先用make生成文件，之后用相应的test跑分即可 整形logicalShift12345678910111213/* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; int val = ~(1&lt;&lt;31) ; // 0x7f ff ff ff val = ((val &gt;&gt; n) &lt;&lt;1)+1; return val &amp; (x&gt;&gt;n);&#125; 逻辑右移：需要去掉负数带来的符号位。产生一个数，前n-1位0，之后全为1，和算数右移后的数进行按位与操作，使左边n-1位为0。 bitCount123456789101112131415161718192021/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int mask = ((0x01&lt;&lt;8|0x01)&lt;&lt;8|0x01)&lt;&lt;8|0x01 ; int val = mask &amp; x; val += mask &amp; x&gt;&gt;1; val += mask &amp; x&gt;&gt;2; val += mask &amp; x&gt;&gt;3; val += mask &amp; x&gt;&gt;4; val += mask &amp; x&gt;&gt;5; val += mask &amp; x&gt;&gt;6; val += mask &amp; x&gt;&gt;7; val += val&gt;&gt;16; val += val&gt;&gt;8; return val&amp;0xff;&#125; 要求：计算32进制数x中1的个数 思路：如果依次检测，ops必然超过。可以每次检测4位，然后再进行累加。先初始化mask=0x01010101，用来检测x&gt;&gt;i的0,8,16,24位是否为1然后x顺序移动重复上述检测，一共8次。相当于将一个32位分成4段同时进行，结果存储在分别四段的8位中。整合：将前16位加到后16位上，然后把8~16位加到低8位。取最低8位为最后结果。 bang12345678910/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; return ((~((~x+1)^x))&gt;&gt;31) &amp; 0x01;&#125; 要求：输出！x。即x!=0, !x =0 ; x=0, !x =1 思路：根据0的特性，若x=0, ~x+1和x的符号位都为0。而其他情况则至少有一个数符号位为1。（也可能两个符号位都为1的情况，如x=0x80 00 00 00,所以不能用^）或运算之后取反，再取符号位。 tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 0x01&lt;&lt;31; // 0x80 00 00 00&#125; 要求：32位二进制补码的最小整数，也就是0x80 00 00 00。（如8位整数，补码编码最小数就是-128，和128是相等的，也就是1000 0000(2)） fitBits12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; int shiftBits = 32 + (~n+1); // 32-n return !(x^((x&lt;&lt;shiftBits)&gt;&gt;shiftBits));&#125; 要求：判断x是否可以用n位补码来表示。考虑的是数字是否在范围内能表示，也就是移动后符号位是否会变化 先左移32-n位，再右移32-n位。即保留最后n位。再和x进行异或，若两者相同，表示x可以被表示成一个n为整数，！0为1。eg.以5为例，5 =000….. 101（2），左移27位后再右移27位得到的是 1111….101，与原来不同。而-4 = 111…100（2），移动后得到的还是111…100，同一个数。 divpwr21234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int sgn = x &gt;&gt; 31; // 0xffffffff or 0x0 int mask = (1 &lt;&lt; n )+ (~0) ; //2^n -1 int bias = sgn &amp; mask; //if x &gt;= 0 bias = 0 return (x+bias) &gt;&gt; n;&#125; 要求：求x /(2^n)，向0取整。 若是非负数，可以直接右移。如果是负数需要分情况。eg. -33 &gt;&gt;4 =-3 。因为负数右移的结果是，如果除以2次幂出现小数，取小于它的最大整数。所以除非是-4 -8这类后几位全为0的负数，其他的都得+1。 构造一个偏置量，因为要右移n位，如果是负数的话，加上2^n-1（后几位全0的话不变，其余的数进1）后再移位。 negate12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 取反加一 isPositive123456789101112/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; //int nsgn = ((~x)&gt;&gt;31)&amp;0x01; //nsgn = !sgn int nsgn = !(x&gt;&gt;31); return nsgn ^ !x ;&#125; 判断正数。x&gt;0，返回1。其余返回0。主要是处理0的情况。取符号位，再取反，再和 !x 进行异或。 isLessOrEqual123456789101112131415/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int sgnx = (x&gt;&gt;31) &amp;0x01; int sgny = (y&gt;&gt;31) &amp;0x01; int sgn = (sgnx ^ sgny) &amp; sgnx; // x&lt;0 ,y&gt;=0 int val = y + (~x +1); // y-x val = ((val &gt;&gt;31) &amp; 0x01) | (sgnx^sgny); // x-y&lt;0 &amp;&amp; sgnx=sgny return (sgn|!val); &#125; 要求：判断x&lt;=y是否成立可以转化为判断x-y的正负。 注意：当x和y同号时，x-y不会发生溢出，判断符号位即可，当x和y异号时，x-y可能发生溢出，其结果不一定和x的符号一致。所以分解为三部分：x和y异号 / 同号 / 相等。 ilog212345678910111213141516/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int bitNum =0; bitNum = (!!(x&gt;&gt;16))&lt;&lt;4; bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+8)))&lt;&lt;3); bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+4)))&lt;&lt;2); bitNum = bitNum + ((!!(x&gt;&gt;(bitNum+2)))&lt;&lt;1); bitNum = bitNum + (!!(x&gt;&gt;(bitNum+1))); return bitNum;&#125; 要求：由多少位二进制可以表示。log（2）1 = 0 二分法，先右移16位后，若大于0即得到（10000）2 =16，否则得到0，判断最高位是否为0（前16位部分是否为0），若不为0，则包含2^16，同理。 其实ilog2的结果不会超过31，可以想到用5位二进制来表示，也就是分成这5步. 浮点型浮点型数表示： float_neg12345678910111213141516171819/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; int tmp =0,ret=0; ret = uf ^ 0x80000000; // sign reverse tmp = uf &amp; 0x7fffffff; // if(tmp &gt; 0x7f800000) // NaN ret = uf; return ret;&#125; 要求：计算-x （unsigned表示的浮点型），可以使用条件语句和其他运算符，当x=NaN时，返回其NaN本身；x！=NaN时，返回-x。 非NaN的数，对最高位异或，将符号位取反。判断NaN，返回本身。 float_i2f123456789101112131415161718192021222324252627unsigned float_i2f(int x) &#123; int sign = (x&gt;&gt;31)&amp;0x01; int frac_mask = 0x7fffff; // (1&lt;&lt;23) -1 int frac=0,exp=0,delta=0; int i = 0; if(!x) return x; else if(x==0x80000000)// -2^31 exp = 158; // 158 = 127 +31 else&#123; if(sign) x=-x; // abs(x) i=30; while(!(x&gt;&gt;i)) i--; exp = i+127; // exp = Bias + E x= x&lt;&lt;(31-i); // clean all those zeroes of high bits frac = (x&gt;&gt;8) &amp; frac_mask;//right shift 8 bits to become the fraction,sign and exp have 8 bits total x = x &amp; 0xff; delta = x&gt;0x80||((x==0x80 )&amp;&amp; (frac&amp;0x01)); //if lowest 8 bits of x is larger than a half,or is 1.5,round up 1 frac += delta; if(frac&gt;&gt;23)&#123; //if after rounding fraction is larger than 23bits exp += 1; frac = frac &amp; frac_mask; &#125; &#125; return (sign&lt;&lt;31)|(exp&lt;&lt;23)|frac;&#125; 要求：int转float 分别求出符号位sign，指数部分exp和小数部分frac。原来整数称x 首先把特殊情况的0x0 和 0x80 00 00 00（-2^31）挑出来，因为不能用移位的办法求exp和frac。 求绝对值，找出x的最高位（最左边的1），此时要从第30位找起，因为第31位是符号位。找到之后该位数就是$ v = (-1)^SM(2)^E $中的E，可以求得exp=E+127 求frac：取x最高位后的23位。步骤：先去掉x高位的0，然后右移8位将最高位后的23位移到低23位。 求精度：int转float型会丢失最后8位的精度（31-23=8），所以要判断x的最后八位需不需要进位，如果最后8位超过128（0x80）或者最后8位=128且frac最后一位=1，则进位。 进位后：需要检查frac有没有再进位，frac&gt;&gt;23进行判断，如果frac进位了，那么exp+1，frac再取最后23位。把sign exp frac组合成结果 float_twice1234567891011121314151617181920212223242526/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; int sign = uf&gt;&gt;31&amp;&amp;0x01; int exp = uf&gt;&gt;23 &amp; 0xff; int frac = uf &amp; 0x7fffff; if(exp!=0xff)&#123; if(!exp) frac=frac&lt;&lt;1; else&#123; exp += 1; if(exp==0xff) frac=0; &#125; &#125; return sign&lt;&lt;31|exp&lt;&lt;23|frac;&#125; 要求：求2*uf，uf是一个用unsigned表示的float，当遇到NaN时返回该NaN 检查是否NaN：exp==0xff 然后分两种情况： 1、exp=全0的，frac&lt;&lt;1,exp不变 2、exp≠全0的，exp++，检查exp==0xff，若exp==0xff，此时该数超范围（无穷大），frac=0 取符号位：uf&gt;&gt;31&amp;0x01 取frac：uf&amp;((1&lt;&lt;23)-1) 取exp：(uf&gt;&gt;23)&amp;0xff]]></content>
      <categories>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>操作系统</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux添加新协议]]></title>
    <url>%2F2018%2F01%2F26%2Flinux%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[添加协议号​ \include\linux\socket.h中定义了地址协议族，修改AF_MAX+1（地址协议族数），并加上自己的协议族 123456789101112#define AF_KCM 41 /* Kernel Connection Multiplexor*/#define AF_QIPCRTR 42 /* Qualcomm IPC Router */#define AF_AS 43 /* 新协议*/#define AF_MAX 44 /* For now.. */#define PF_AS AF_AS /* 新协议*//* Protocol families, same as address families. */#define PF_UNSPEC AF_UNSPEC#define PF_UNIX AF_UNIX#define PF_LOCAL AF_LOCAL ​ 通过添加协议号的方式，需要重新编译内核 编译内核下载linux源码，进入源码根目录编译 123456sumake menuconfigmake -j 32make modules_installmake installmake headers_install INSTALL_HDR_PATH=/usr 然后重启，查看新内核版本 12zjw@ubuntu:~$ uname -r4.10.0 添加新协议模块添加一个空协议 aproto.c，大部分函数是空函数。根据/net/rds.c修改的，将原来rds改成as，AF_INET改成AF_AS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/gfp.h&gt;#include &lt;linux/in.h&gt;#include &lt;linux/poll.h&gt;#include &lt;net/sock.h&gt;#include &lt;linux/init.h&gt;static int as_release(struct socket *sock)&#123; return 0;&#125;static int as_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)&#123; return 0;&#125;static int as_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)&#123; return 0;&#125;static int as_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)&#123; int ret =0; return ret;&#125;static int as_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int msg_flags)&#123; int ret =0; return ret; &#125;static unsigned int as_poll(struct file *file, struct socket *sock, poll_table *wait)&#123; int ret = 0; return ret;&#125;static int as_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)&#123; return -ENOIOCTLCMD;&#125;static int as_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)&#123; int ret =0 ; return ret;&#125;static int as_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)&#123; int ret = 0; return ret;&#125;static int as_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)&#123; int ret =0 ; return ret;&#125;static struct proto as_proto = &#123; .name = "A_PROTO", .owner = THIS_MODULE, .obj_size = sizeof(struct sock),&#125;;static const struct proto_ops as_proto_ops = &#123; .family = AF_AS, // 自定义协议族 .owner = THIS_MODULE, .release = as_release, .bind = as_bind, .connect = as_connect, .socketpair = sock_no_socketpair, .accept = sock_no_accept, .getname = as_getname, .poll = as_poll, .ioctl = as_ioctl, .listen = sock_no_listen, .shutdown = sock_no_shutdown, .setsockopt = as_setsockopt, .getsockopt = as_getsockopt, .sendmsg = as_sendmsg, .recvmsg = as_recvmsg, .mmap = sock_no_mmap, .sendpage = sock_no_sendpage,&#125;;static int __as_create(struct socket *sock, struct sock *sk, int protocol)&#123; struct as_sock *as; sock_init_data(sock, sk); sock-&gt;ops = &amp;as_proto_ops; sk-&gt;sk_protocol = protocol; return 0;&#125;static int as_create(struct net *net, struct socket *sock, int protocol, int kern)&#123; struct sock *sk; if (sock-&gt;type != SOCK_SEQPACKET || protocol) return -ESOCKTNOSUPPORT; sk = sk_alloc(net, AF_AS, GFP_ATOMIC, &amp;as_proto, kern); if (!sk) return -ENOMEM; return __as_create(sock, sk, protocol);&#125;static const struct net_proto_family as_family_ops = &#123; .family = AF_AS, .create = as_create, .owner = THIS_MODULE,&#125;;static int __init as_init(void)&#123; int ret; printk(KERN_INFO "as_init\n"); ret = proto_register(&amp;as_proto, 1); //注册协议 if (ret) &#123; printk(KERN_ERR "proto_register ERROR\n"); goto out; &#125; ret = sock_register(&amp;as_family_ops); if (ret) &#123; printk(KERN_ERR "sock_register ERROR\n"); goto out; &#125; goto out; printk(KERN_INFO "device has been registered\n");out: return ret;&#125;static void __exit as_exit(void)&#123; printk(KERN_INFO "aproto exit\n");&#125;module_init(as_init);module_exit(as_exit);#define DRV_RELDATE "2017/12/07"MODULE_AUTHOR("Jingwei Zheng");MODULE_DESCRIPTION("AS:A NEW PROTOCOL" DRV_RELDATE); 应用程序1234#define AF_AS 43...socket_fd = socket(AF_AS, SOCK_SEQPACKET, 0)...]]></content>
      <categories>
        <category>网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
